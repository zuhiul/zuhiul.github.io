<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round 552]]></title>
    <url>%2F2019%2F04%2F17%2FCodeforces_Round_552%2F</url>
    <content type="text"><![CDATA[F. Shovels Shop开启传送门 题目描述There are $n$ shovels in the nearby shop. The $i$-th shovel costs $a_i$ bourles. Misha has to buy exactly $k$ shovels. Each shovel can be bought no more than once. Misha can buy shovels by several purchases. During one purchase he can choose any subset of remaining (non-bought) shovels and buy this subset. There are also $m$ special offers in the shop. The $j$-th of them is given as a pair $(x_j,y_j)$, and it means that if Misha buys exactly $x_j$ shovels during one purchase then $y_j$ most cheapest of them are for free (i.e. he will not pay for $y_j$ most cheapest shovels during the current purchase). Misha can use any offer any (possibly, zero) number of times, but he cannot use more than one offer during one purchase (but he can buy shovels without using any offers). Your task is to calculate the minimum cost of buying $k$ shovels, if Misha buys them optimally. ###Input The first line of the input contains three integers $n,m$ and $k$ ($1\leq n,m\leq 2\cdot 10^5,1\leq k\leq min(n,2000)$) - the number of shovels in the shop, the number of special offers and the number of shovels Misha has to buy, correspondingly. The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_1\leq 2\cdot 10^5$), where $a_i$ is the cost of the $i$-th shovel. The next $m$ lines contain special offers. The $j$-th of them is given as a pair of integers ($x_i,y_i$) ($1\leq y_i\leq x_i\leq n) and means that if Misha buys exactly $x_i$ shovels during some purchase, then he can take $y_i$ most cheapest of them for free. OutputPrint one integer $-$ the minimum cost of buying $k$ shovels if Misha buys them optimally. Examplesinpus17 4 5 2 5 4 2 6 3 1 2 1 6 5 2 1 3 1 output17 input29 4 8 6 8 5 1 8 1 1 2 1 9 2 8 4 5 3 9 7 output217 input35 1 4 2 5 7 4 6 5 4 output317 NoteIn the first example Misha can buy shovels on positions 1 and 4 (both with costs 2) during the first purchase and get one of them for free using the first or the third special offer. And then he can buy shovels on positions 3 and 6 (with costs 4 and 3) during the second purchase and get the second one for free using the first or the third special offer. Then he can buy the shovel on a position 7 with cost 1. So the total cost is 4+2+1=7. In the second example Misha can buy shovels on positions 1, 2, 3, 4 and 8 (costs are 6, 8, 5, 1 and 2) and get three cheapest (with costs 5, 1 and 2) for free. And then he can buy shovels on positions 6, 7 and 9 (all with costs 1) without using any special offers. So the total cost is 6+8+1+1+1=17. In the third example Misha can buy four cheapest shovels without using any special offers and get the total cost 17. 题意zuhiul 都20了，还没有对象，然后家里人给安排了n个菇凉和他相亲，他需要挑出k个来相亲。相亲当然是男方请客，和每个妹子相亲的成本是不一样的，每个妹子都有一个固定成本，为了促进zuhiul相亲，家里人说，如果一次邀约了$x_i$个菇凉，家里就给报销这次相亲的所有菇凉中，成本最低的$y_i$个菇凉的花费，现在zuhiul想花最少的钱相完所有的亲，他最少要花多少钱呢？ 分析首先可以确定的是，我们一定找n各种最便宜的k个来相亲，因为如果不是这k个，我们一定可以合理的交换，得到一个不劣的解。 然后排序，干掉贵的那一部分。 那么如果不考虑报销的话，成本是固定的，所以剩下的问题就是怎么得到尽可能多的报销。 然后，显然是一个$n^2$的dp了。 我们可以预处理出，如果一次约j个女孩的话，可以省掉多少个女孩的费用，设为sub[j] 假设每个女孩的费用为values[i] 考虑转移，设dp[i]表示邀约前n个妹子的最小花费，那么可以得到$$dp[i] = \min_{j=1}^{i} (dp[i-j] + \sum_{k=i-j+sub[j]+1}^{i} values[k])$$ 然后对于后面的求和，可以搞一个前缀和来维护，复杂度$O(n^2)$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int maxk = 2005;const int maxm = 2e5+10;int sub[maxk];int n,m,k;int values[maxm];long long sum[maxm];int ans[maxk];long long cost[maxk];int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i = 1;i&lt;=n;i++) scanf("%d",values+i); sort(values+1,values+n+1); for(int i = 1;i&lt;=n;i++) sum[i] = sum[i-1]+values[i]; while(m--) &#123;/*&#123;&#123;&#123;*/ int a,b; scanf("%d%d",&amp;a,&amp;b); if(a&gt;k) continue; sub[a] = max(sub[a],b); &#125;/*&#125;&#125;&#125;*/ for(int i = 1;i&lt;=k;i++) sub[i] = max(sub[i],sub[i-1]); memset(cost,0x3f,sizeof(cost)); cost[0] = 0; for(int i = 1;i&lt;=k;i++)&#123; cost[i] = sum[i]; for(int j = 1;j&lt;=i;j++)&#123; cost[i] = min(cost[i],cost[i-j]+sum[i]-sum[i-j+sub[j]]); &#125; &#125; printf("%lld\n",cost[k]); return 0;&#125; G. Minimum Possible LCM开启传送门 题目描述You are given an array $a$ consisting of $n$ integers $a_1,a_2,\dots,a_n$. Your problem is to find such pair of indices $i,j (1\leq i&lt;j\leq n)$ that $lcm(a_i,a_j)$ is minimum possible. $lcm(x,y)$ is the least common multiple of $x$ and $y$ (minimum positive number such that both $x$ and $y$ are divisors of this number). ###Input The first line of the input contains one integer $n$ ($2\leq n\leq10^6$) — the number of elements in $a$. The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_i\leq 10^7$), where $a_i$ is the $i$-th element of $a$. OutputPrint two integers $i$ and $j$ ($1\leq i&lt;j\leq n$) such that the value of $lcm(a_i,a_j)$ is minimum among all valid pairs $i,j$. If there are multiple answers, you can print any. Examplesinpus15 2 4 8 3 6 output11 2 input25 5 2 11 3 7 output22 4 input36 2 5 10 1 10 2 output31 4 题意zuhiul有很多妹子，今天他想找两个妹子出去吃饭，每个妹子都有一个权值，他今天要花的钱等于这两个妹子权值的lcm，他想花尽可能少的钱，他该约哪两个妹子呢？ 分析我们考虑一下那种情况可以构成解。 首先对于重复的数据，我们可以干掉，因为相同值的lcm等于本身，所以我们可以把相同的权值干掉，然后剩下的数据都是不同的。 然后我们考虑权值都不相同的时候怎么构成解。 首先，这两个数肯定有一个gcd，哪怕gcd = 1，然后我们考虑一下，这$n*(n-1)&gt;&gt;1$这么多对数中，哪些对可以构成解，一个显而易见的想法就是，我们可以枚举gcd。 然后我们枚举这个gcd的所有倍数，这样能不重不漏的枚举出所有对数，然后我们考虑怎么减少枚举量。假设当前的$gcd=x$,因为前一步保证了没有相同的数据，所以我们只要找到最小的$i,j$使得$i%x==0&amp;&amp;j%x==0$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+10;int n;int app[maxm];struct p&#123; long long ans; int ind1,ind2; bool operator&lt;(const p a) const &#123; return ans&lt;a.ans; &#125;&#125;;int main()&#123; scanf("%d",&amp;n); p ans = &#123;1000000000000000000ll,-1,-1&#125;; for(int i = 1,buf;i&lt;=n;i++)&#123; scanf("%d",&amp;buf); if(app[buf]) ans = min(ans,&#123;buf,app[buf],i&#125;); app[buf] = i; &#125; for(int i = 1;i&lt;maxm;i++)&#123; int buf[3] = &#123;0&#125;; for(int j = i;j&lt;maxm;j+=i)&#123; if(app[j])&#123; buf[++buf[0]] = j; if(buf[0]==2)&#123; ans = min(ans,&#123;1ll*buf[1]*buf[2]/i,app[buf[1]],app[buf[2]]&#125;); break; &#125; &#125; &#125; &#125; if(ans.ind1&gt;ans.ind2) swap(ans.ind1,ans.ind2); printf("%d %d\n",ans.ind1,ans.ind2); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 551]]></title>
    <url>%2F2019%2F04%2F14%2FCodeforces_Round_551%2F</url>
    <content type="text"><![CDATA[A. Serval and Bus开启传送门 题目描述It is raining heavily. But this is the first day for Serval, who just became 3 years old, to go to the kindergarten. Unfortunately, he lives far from kindergarten, and his father is too busy to drive him there. The only choice for this poor little boy is to wait for a bus on this rainy day. Under such circumstances, the poor boy will use the first bus he sees no matter where it goes. If several buses come at the same time, he will choose one randomly. Serval will go to the bus station at time $t$, and there are $n$ bus routes which stop at this station. For the $i$-th bus route, the first bus arrives at time $s_i$ minutes, and each bus of this route comes $d_i$ minutes later than the previous one. As Serval’s best friend, you wonder which bus route will he get on. If several buses arrive at the same time, you can print any of them. InputThe first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station. Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route. OutputPrint one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them. Examplesinput12 2 6 4 9 5 output11 input25 5 3 3 2 5 5 6 4 9 6 1 output23 input33 7 2 2 2 3 2 4 output31 题意zuhiul很忙，他要约妹子，他一共有$n$个妹子要约，但是他$t$天后才有空，妹子们也不是每天都有时间，但是妹子都是周期性有时间，比如，第$i$个妹子，$s_i$天之后才有时间，而且每$d_i$天就会再次出线，现在问你，zuhiul最早会和哪个妹子约会，如果会和多个妹子约会，只需要输出任意一个妹子就行了。 分析只需要枚举每个妹子，然后看一下这个妹子什么时候最早可以邀约，然后算一下min就可以了 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 105;int s[maxm],d[maxm];int main()&#123; int n,t; cin&gt;&gt;n&gt;&gt;t; int ind,sum = 1e8; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;s[i]&gt;&gt;d[i]; if(s[i]&gt;=t)&#123; if(sum&gt;s[i])&#123; sum = s[i]; ind = i; &#125; &#125;else &#123; int nee = t-s[i]; if(nee%d[i]!=0) nee = (nee/d[i]+1)*d[i]; nee+=s[i]; if(nee&lt;sum)&#123; sum = nee; ind = i; &#125; &#125; &#125; cout&lt;&lt;ind&lt;&lt;endl; return 0;&#125; B. Serval and Toy Bricks开启传送门 题目描述Luckily, Serval got onto the right bus, and he came to the kindergarten on time. After coming to kindergarten, he found the toy bricks very funny. He has a special interest to create difficult problems for others to solve. This time, with many $1\times 1\times 1$ toy bricks, he builds up a 3-dimensional object. We can describe this object with a $n\times m$ matrix, such that in each cell $(i,j)$ , there are $h_{i,j}$ bricks standing on the top of each other. However, Serval doesn’t give you any $h_{i,j}$, and just give you the front view, left view, and the top view of this object, and he is now asking you to restore the object. Note that in the front view, there are $m$ columns, and in the $i$-th of them, the height is the maximum of $h_{1,i},h_{2,i},\dots,h_{n,i}$. It is similar for the left view, where there are $n$ columns. And in the top view, there is an 𝑛×𝑚 matrix $t_{i,j}$, where $t_{i,j}$ is 0 or 1. If $t_{i,j}$ equals 1, that means $h_{i,j}$&gt;0, otherwise, $h_{i,j}$=0. However, Serval is very lonely because others are bored about his unsolvable problems before, and refused to solve this one, although this time he promises there will be at least one object satisfying all the views. As his best friend, can you have a try? InputThe first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station. Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route. OutputPrint one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them. Examplesinput13 7 3 2 3 0 0 2 0 1 2 1 3 1 0 0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 output11 0 0 0 2 0 0 0 0 0 0 0 0 1 2 3 0 0 0 0 0 input24 5 5 3 5 2 0 4 4 2 5 4 0 0 0 0 1 1 0 1 0 0 0 1 0 0 0 1 1 1 0 0 output20 0 0 0 4 1 0 2 0 0 0 5 0 0 0 3 4 1 0 0 Note The graph above illustrates the object in the first example. The first graph illustrates the object in the example output for the second example, and the second graph shows the three-view drawing of it. 题意zuhiul和妹子玩游戏，妹子搭了一个积木，然后zuhiul猜积木长啥样，zuhiul必然不会，于是小姐姐放过了他，告诉了他现在的主视图，侧视图和俯视图，然后让zuhiul猜，zuhiul还是不会，但是为了脸面不能说不会，然后来问你了。你需要输出一种可能的解满足这个三视图。 分析告诉了主视图和左视图，相当于限制了最大值，告诉俯视图相当于告诉哪里可能有方块。然后枚举俯视图的每个位置，输出答案即可。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxm = 105;int hang[maxm],lie[maxm],nouse;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;nouse; for(int i = 0;i&lt;m;i++) cin&gt;&gt;hang[i]; for(int i = 0;i&lt;n;i++) cin&gt;&gt;lie[i]; for(int i = 0;i&lt;n;i++)&#123; for(int j = 0,a;j&lt;m;j++)&#123; cin&gt;&gt;a; if(a) cout&lt;&lt;min(lie[i],hang[j])&lt;&lt;' '; else cout&lt;&lt;0&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; C. Serval and Parenthesis Sequence开启传送门 题目描述Serval soon said goodbye to Japari kindergarten, and began his life in Japari Primary School. In his favorite math class, the teacher taught him the following interesting definitions. A parenthesis sequence is a string, containing only characters “(“ and “)”. A correct parenthesis sequence is a parenthesis sequence that can be transformed into a correct arithmetic expression by inserting characters “1” and “+” between the original characters of the sequence. For example, parenthesis sequences “()()”, “(())” are correct (the resulting expressions are: “(1+1)+(1+1)”, “((1+1)+1)”), while “)(“ and “)” are not. Note that the empty string is a correct parenthesis sequence by definition. We define that $|s|$ as the length of string $s$. A strict prefix $s[1\dots l]$ (1 ≤ $l$ &lt; $|s|$) of a string $s=s_{1}s_{2}\dots s_{|s|}$ is string $s_{1}s_{2}\dots s_{l}$. Note that the empty string and the whole string are not strict prefixes of any string by the definition. Having learned these definitions, he comes up with a new problem. He writes down a string $s$ containing only characters “(“, “)” and “?”. And what he is going to do, is to replace each of the “?” in $s$ independently by one of “(“ and “)” to make all strict prefixes of the new sequence not a correct parenthesis sequence, while the new sequence should be a correct parenthesis sequence. After all, he is just a primary school student so this problem is too hard for him to solve. As his best friend, can you help him to replace the question marks? If there are many solutions, any of them is acceptable. InputThe first line contains a single integer $|s|$ (1≤$|s|$≤$3\cdot 10^5$), the length of the string. The second line contains a string $s$, containing only “(“, “)” and “?”. OutputA single line contains a string representing the answer. If there are many solutions, any of them is acceptable. If there is no answer, print a single line containing “:(“ (without the quotes). Examplesinput16(????? output1(()()) input210(???(???(? output2:( NoteIt can be proved that there is no solution for the second sample, so print “:(“. 题意给你一堆左括号右括号和问号，问你能否把问号变成左括号或者右括号，使得这个变成一个括号匹配的序列，并且序列的任何前缀不是一个括号匹配序列。 分析显然对于后一个条件，我们只需要让最左边的左括号和最右边的右括号匹配就行了，然后中间是一个括号匹配序列就行了。然后填充的时候贪心的让左边填充左括号,右边填充右括号,然后check一下就行了. 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int len;const int maxm = 3e5+10;char que[maxm];void NO()&#123; cout&lt;&lt;":("&lt;&lt;endl; exit(0);&#125;int main()&#123; cin&gt;&gt;len&gt;&gt;que; if(len&amp;1) NO(); if(que[0]=='?') que[0] = '('; if(que[len-1]=='?') que[len-1] = ')'; if(que[0]!='(') NO(); if(que[len-1]!=')') NO(); if(len==2) &#123; puts("()"); return 0; &#125; int l = 0,r = 0,has = 0; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='(') l++; else if(que[i]==')') r++; else has++; &#125; if(abs(l-r)&gt;has) NO(); l = (len-2)/2 - l; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='?') &#123; if(l)&#123; que[i] = '('; l--; &#125;else que[i] = ')'; &#125; &#125; has = 0; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='(') has++; else has--; if(has&lt;0) NO(); &#125; puts(que); return 0;&#125; D. Serval and Rooted Tree开启传送门 题目描述Now Serval is a junior high school student in Japari Middle School, and he is still thrilled on math as before. As a talented boy in mathematics, he likes to play with numbers. This time, he wants to play with numbers on a rooted tree. A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a node $v$ is the last different from $v$ vertex on the path from the root to the vertex $v$. Children of vertex $v$ are all nodes for which $v$ is the parent. A vertex is a leaf if it has no children. The rooted tree Serval owns has $n$ nodes, node 1 is the root. Serval will write some numbers into all nodes of the tree. However, there are some restrictions. Each of the nodes except leaves has an operation max or min written in it, indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons, respectively. Assume that there are $k$ leaves in the tree. Serval wants to put integers $1,2,\dots,k$ to the $k$ leaves (each number should be used exactly once). He loves large numbers, so he wants to maximize the number in the root. As his best friend, can you help him? InputThe first line contains an integer $n$ (2≤$n$≤$3\cdot 10^5$), the size of the tree. The second line contains $n$ integers, the $i$-th of them represents the operation in the node $i$. 0 represents min and 1 represents max. If the node is a leaf, there is still a number of 0 or 1, but you can ignore it. The third line contains $n-1$ integers $f_2,f_3,\dots,f_n$ (1≤$f_i≤$i-1$), where $f_i$ represents the parent of the node $i$. OutputOutput one integer $-$ the maximum possible number in the root of the tree. Examplesinput16 1 0 1 1 0 1 1 2 2 2 2 output11 input25 1 0 1 0 1 1 1 1 1 output24 input38 1 0 0 1 0 1 1 0 1 1 2 2 3 3 3 output34 input49 1 1 0 0 1 0 1 0 1 1 1 2 2 3 3 4 4 output45 NotePictures below explain the examples. The numbers written in the middle of the nodes are their indices, and the numbers written on the top are the numbers written in the nodes. In the first example, no matter how you arrange the numbers, the answer is $1$. In the second example, no matter how you arrange the numbers, the answer is $4$. In the third example, one of the best solution to achieve $4$ is to arrange $4$ and $5$ to nodes $4$ and $5$. In the fourth example, the best solution is to arrange $5$ to node $5$. 题意给你一颗有根树，每个非叶节点上有一个函数，可能为min或者max，你需要在k个叶节点上填上$1,2,\dots,k$,使得经过非叶节点的操作之后，根节点的值最大。 分析显然是要分析函数的作用。 如果是取max，说明所有的子节点中，我们可以把某一个子节点的值取到最大，然后其他的节点全塞垃圾值。 如果是取min，说明所有子节点都起作用，说明我们对于每个子节点都要尽可能的大。 然后就可以得到，max的策略是，找到孙子节点最少的子节点，填充大值，min的策略是，对所有子节点求和。 然后这样得到的就是所有对答案有贡献的节点数，然后用总结点数减去贡献节点数就是答案。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 3e5+10;int n,cnt;int maxn[maxm];vector&lt;int&gt; son[maxm];int dfs(int a)&#123; if(son[a].size()==0)&#123; cnt++; return 1; &#125; if(maxn[a])&#123; int minm = 1e8; for(int i:son[a]) minm = min(minm,dfs(i)); return minm; &#125; int sum = 0; for(int i:son[a]) sum+=dfs(i); return sum;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++) cin&gt;&gt;maxn[i]; for(int i = 2,pre;i&lt;=n;i++)&#123; cin&gt;&gt;pre; son[pre].push_back(i); &#125; int nouse = dfs(1); cout&lt;&lt;cnt - nouse+1&lt;&lt;endl; return 0;&#125; E. Serval and Snake开启传送门 题目描述This is an interactive problem. Now Serval is a senior high school student in Japari Middle School. However, on the way to the school, he must go across a pond, in which there is a dangerous snake. The pond can be represented as a $n\times n$ grid. The snake has a head and a tail in different cells, and its body is a series of adjacent cells connecting the head and the tail without self-intersecting. If Serval hits its head or tail, the snake will bite him and he will die. Luckily, he has a special device which can answer the following question: you can pick a rectangle, it will tell you the number of times one needs to cross the border of the rectangle walking cell by cell along the snake from the head to the tail. The pictures below show a possible snake and a possible query to it, which will get an answer of $4$. Today Serval got up too late and only have time to make 2019 queries. As his best friend, can you help him find the positions of the head and the tail? Note that two cells are adjacent if and only if they have a common edge in the grid, and a snake can have a body of length 0, that means it only has adjacent head and tail. Also note that the snake is sleeping, so it won’t move while Serval using his device. And what’s obvious is that the snake position does not depend on your queries. InputThe first line contains a single integer $n$ (2≤$n$≤1000) $-$ the size of the grid. OutputWhen you are ready to answer, you should print ! x1 y1 x2 y2, where $(x_1,y_1)$ represents the position of the head and $(x_2,y_2)$ represents the position of the tail. You can print head and tail in any order. InteractionTo make a query, you should print ? x1 y1 x2 y2 (1≤$x_1$≤$x_2$≤𝑛, 1≤$y_1$≤$y_2$≤$n$), representing a rectangle consisting of all cells $(x,y)$ such that $x_1$≤$x$≤$x_2$ and $y_1$≤$y$≤$y_2$. You will get a single integer as the answer. After printing a query, do not forget to output the end of line and flush the output, otherwise you will get Idleness limit exceeded. To do this, use: fflush(stdout) or cout.flush() in C++; System.out.flush() in Java; flush(output) in Pascal; stdout.flush() in Python;see documentation for other languages. Answer $-1$ instead of a valid answer means that you made an invalid query or exceeded the maximum number of queries. Exit immediately after receiving $-1$ and you will see Wrong answer verdict. Otherwise you can get an arbitrary verdict because your solution will continue to read from a closed stream. If your program cannot find out the head and tail of the snake correctly, you will also get a Wrong Answer verdict. HacksTo make a hack, print a single integer $n$ (2≤$n$≤1000) in the first line, indicating the size of the grid. Then print an integer $k$ (2≤$k$≤𝑛2) in the second line, indicating the length of the snake. In the next $k$ lines, print $k$ pairs of integers $x_i,y_i$ (1≤$x_i,y_i$≤𝑛), each pair in a single line, indicating the $i$-th cell of snake, such that the adjacent pairs are adjacent, and all $k$ pairs are distinct. Examplesinput12 1 0 0 output1? 1 1 1 1 ? 1 2 1 2 ? 2 2 2 2 ! 1 1 2 1 input23 2 0 output2? 2 2 2 2 ? 2 1 2 3 ! 2 1 2 3 Note The pictures above show our queries and the answers in the first example. We first made a query for (1,1) and got an answer 1, then found that it must be connected to exactly one other cell. Then we made a query for (1,2) and got an answer of 0, then knew that the snake never entered it. So the cell connected to (1,1) must be (2,1). Then we made a query for (2,2) and got an answer 0, then knew that it never entered (2,2) as well. So the snake cannot leave (2,1), which implies that the answer is (1,1) and (2,1). The pictures above show our queries and the answers in the second example. By making query to (2,2) and receiving 2, we found that the snake occupies (2,2). And by making query to rectangle from (2,1) to (2,3) and receiving answer 0, we knew that it never goes out of the rectangle from (2,1) to (2,3). Since the first answer is 2, both (2,1) and (2,3) must be occupied but none of others, so the answer is (2,1) and (2,3). 题意现在有一条蛇在一个方格图中，你可以给出不超过2019次询问，每次询问一个矩形，回答是，你用这个矩形去切蛇，可以得到这个蛇被切了多少刀，现在问你蛇头和蛇尾的位置。 分析首先我们可以观察到，当一个矩形切下去之后发现切了奇数刀，那么可以有必然存在一个头或者尾在矩形中。 然后我们可以用$(n-1)&lt;&lt;1$次询问得到所有的行和列对应的切的次数。 然后可以证明的是，所有的数据中必然存在奇数。反证法易得。 然后可以证明奇数对应的行或者列左右必然存在头或者尾。 所以可以得到一个很直观的$O(6n)$的做法，$2n$用来寻找，剩下的$4n$来搜索答案。但是这必然会超过2019. 考虑哪些步骤可以优化？ $2n$不可优化，必然就只能优化搜索过程。 需要注意的是，可能存在行或者列不存在奇数的情况，稍微分析可以得到这种情况的特点了，头和尾在同一行或者同一列中。 我们考虑到，我们只用考虑奇偶的情况，而不用考虑具体值。 因为奇偶的加减特性，我们可以二分这个答案。 除此之外，如果行和列都有奇数值，那么可以得到行和列对应的四个点中，两个点是答案，枚举任何一个就可以得到答案。 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1005;int n;vector&lt;int&gt; r,c;int que(int u,int d,int l,int r)&#123; printf("? %d %d %d %d\n",u,l,d,r); fflush(stdout); int nouse; scanf("%d",&amp;nouse); return nouse&amp;1;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1;i&lt;=n;i++) if(que(i,i,1,n)) r.push_back(i); for(int i = 1;i&lt;=n;i++) if(que(1,n,i,i)) c.push_back(i); assert(r.size()+c.size()&gt;=2); if(c.empty()||r.empty())&#123; bool change = false; if(c.empty()) &#123; swap(r,c); change = true; &#125; int l = 1,r = n; while(l&lt;r)&#123; int mid = l+r&gt;&gt;1; int upper = l,down = mid,left = c[0],right = c[0]; if(change) swap(left,upper),swap(down,right); if(que(upper,down,left,right)) r = mid; else l = mid+1; &#125; if(!change) printf("! %d %d %d %d\n",l,c[1],l,c[0]); else printf("! %d %d %d %d\n",c[0],l,c[1],l); fflush(stdout); return 0; &#125; if(que(r[0],r[0],c[0],c[0])) printf("! %d %d %d %d\n",r[0],c[0],r[1],c[1]); else printf("! %d %d %d %d\n",r[0],c[1],r[1],c[0]); fflush(stdout); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[factorio]]></title>
    <url>%2F2019%2F03%2F31%2Ffactorio%2F</url>
    <content type="text"><![CDATA[level 1]]></content>
      <tags>
        <tag>factorio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试]]></title>
    <url>%2F2019%2F02%2F21%2Fgluten%2F</url>
    <content type="text"><![CDATA[头条面试回忆录废话这两天参加了头条的面试,总体来说,感觉不错,公司效率很高… 一面当天上午投的简历,下午让我第二天面试,时间很紧,很多东西都没来得及准备…. 1.自我介绍一下(balabalabala) 2.学过操作系统和计算机网络吗?(网络学了,操作系统下学期开,其实我很想说操作系统自学了,您可以问……) 3.说一下tcp和udp的区别(balabalabala) 2.1那个快?为什么?(udp快,因为三次握手四次挥手会占用cpu时间?) 2.2去掉三次握手四次挥手那个快?(不知道) 4.写两个题吧 3.1 给你一个数字矩阵,每行每列都是增序,问你某个值是否存在(剑指offer原题,我100%做过,但是我忘了怎么做的,只知道从角上枚举,然后先说了一下从右下角枚举,说不对,然后换成右上角,没啥问题….) 3.2 给一个矩阵,四联通,找到一个最长上升子序列(简单dp,写完就过了) 3.2.1 能把路径输出一下吗?(记录前驱….) 3.2.2 能把前驱数组去掉吗?(可以,瞎搞一下就行了…..) 4.闲聊(emmmmm) 二面二面感觉更严格,感觉答的不好….. 1.自我介绍(balabalabala) 2.有什么数据结构可以做到查询和插入都是o(1)的?(第一反映,显然不可能啊,这不是不可调和的矛盾吗?面试官说:知道hash吗?哇,感觉被鄙视了,确实傻了) 3.给你n个有序链表(从大到小),怎么找到这n个链表的前K大,(先取出每个链表的最大,然后建最大堆,然后每次取出堆顶,然后取出对应链表的后续元素,加入堆,然后一次操作,直到有k个元素) 3.1 复杂度多少?(o(n+klogn)) 3.2 n是怎么来的?(建堆时间) 3.3 能证明一下吗?(假设堆是用类树状数组的结构维护,先把数据随机放进来,然后每次从大到小枚举一个下标ind,比较当前位置ind和(ind&gt;&gt;1),然后根据大小关系交换一下,可以证明每次都是两个数比较,并且最多有n次比较,所以o(n)) 4.写两个题吧 2.1 给你一个字典,给你一个询问串,问你能否用字典中的某些单词(每个单词只能用一次),构成询问串.(想复杂了,一直在想怎么优化,后来才知道直接暴力就行,我当时还傻乎乎的用了lower_bound企图缩小范围,结果返回结果还死活不对,搞了30分钟才搞定,感觉要凉) 2.2 可能是看我太菜,没问第二道题,感觉好像对我不感兴趣就溜了??? 三面不知道自己怎么活过二面的……. 1.聊天,纯聊天,可能是怕我太紧张,感觉面试官很好 2.提出自我介绍被拒绝……. 3.简单说一下项目,(也不用详细说,因为项目就是很简单……) 4.有啥很厉害的技术要说明的吗?(没有……) 5.我们写两个题吧 5.1 给你一个无根树,让你转化成有根树,使得树的深度最小(一眼直径的中点,写了一下,好像有点问题,我问他我是调一下还是?他说不用调了,想法没啥大问题) 5.2 初始位置0,速度1,两个操作 1.position+=spead,spead*=2 2.spead&gt;0,spead = -1;else spead = 1 问你最少操作几次,使得,从0到x 我第一想法二进制拆分,然后瞎搞,写了一下,没啥大问题 复杂度?(32^2?) 怎么证明,我说每次考虑最高位的1,然后瞎搞一下balabalabala 说正解是dp,比我复杂,emmmmm…….. 6.浏览器输入baidu.com会发生啥?(balabalabala,昨天看过,不知道说的对不对) 7.你有啥觉得自己的技术亮点要说吗?(感觉瞎bb都能加分,但是我怂,老老实实说自己没啥技能点……) 8.你想过一些大的厂商,背后的技术部门都是怎么运行的吗?(不知道……..) 9.面试官可能觉得没啥聊的了,就放我走了…… 总结总的来说,面试官还是很和蔼的,有些问题还会引导你向正确的方向思考,问题都不难,好好准备应该好过,就这样吧…….]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 276 Primitive Triangles]]></title>
    <url>%2F2019%2F01%2F17%2FPE276%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Consider the triangles with integer sides $a, b$ and $c$ with $a \leq b \leq c$.An integer sided triangle $(a,b,c)$ is called primitive if $gcd(a,b,c)=1$.How many primitive integer sided triangles exist with a perimeter not exceeding $10,000,000$? 题意问你存在多少个边长是整数的三角形,并且满足三边长的gcd为1,周长不超过$1e7$. 分析有一个比较奇奇怪怪的结论 我直接把结论搬过来$\dots$ \begin{eqnarray} F(n) = \begin{cases} \lfloor\frac{(n+3)^2+24}{48}\rfloor\ \ \ \ &amp;n\ \ is\ \ odd\\ \lfloor\frac{n^2+24}{48}\rfloor\ \ \ \ &amp;n\ \ is\ \ even\ \end{cases}\end{eqnarray} 这个结论说的是,周长为$n$的边长都是整数的三角形的数量.然后我们可以预处理出所有的周长为$n$的数量出来,然后我们怎么保证gcd呢,比较好想的就是容斥,我们容斥掉所有gcd不是1的就行了,也就是说我们用周长为$2\cdot n,3\cdot n,\dots$的减去周长为$n$的就行啦啦啦 给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+1;long long num[maxm];long long get(long long a)&#123; if(a&amp;1) return ((a+3)*(a+3)+24)/48; return (a*a+24)/48;&#125;void init()&#123;//预处理出每个周长对应的三角形数量,容斥得到正确的数量 for(int i = 1;i&lt;maxm;i++) num[i] = get(i); for(int i = 1;i&lt;maxm;i++) for(int j = i&lt;&lt;1;j&lt;maxm;j+=i) num[j]-=num[i];&#125;int main()&#123; init(); long long ans = 0; for(int i = 1;i&lt;maxm;i++) ans+=num[i]; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 643 2-Friendly]]></title>
    <url>%2F2019%2F01%2F09%2FPE643%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Two positive integers $a$ and $b$ are 2-friendly when $gcd(a,b)=2^t,t&gt;0$. For example, $24$ and $40$ are 2-friendly because $gcd(24,40)=8=2^3$ while $24$ and $36$ are not because $gcd(24,36)=12=2^2\cdot 3$ not a power of $2$. Let $f(n)$ be the number of pairs, $(p,q)$, of positive integers with $1\leq p&lt;q\leq n$ such that $p$ and $q$ are 2-friendly. You are given $f(10^2)=1031$ and $f(10^6)=321418433$ modulo $1000000007$ . Find $f(10^{11})$ modulo $1000000007$. 题意问你所有满足$1\leq p&lt;q\leq 1e11$,并且$gcd(p,q)==2^t$的对数 分析显然可以对于每个$2^t$单独考虑,不妨设$2^t = x$,可以得到 $$ans = \sum_{i=1}^{upper/x} \varphi(i)$$ 然后显然是各种筛法搞一下,我这里用的杜教筛,然后稍微推一推就可以得到 $$s(m) = \frac{m\ast (m+1)}{2} - \sum_{d=2}^{m} s(\lfloor \frac{m}{d} \rfloor)$$ 然后分块一下,递归搞下去就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const long long upper = 1e11;const int maxm = 2e7+10;const int mod = 1e9+7;int add(int a,int b)&#123;return (a+b)%mod;&#125;int mul(long long a,long long b)&#123;return (a%mod)*(b%mod)%mod;&#125;int inv(long long a)&#123; return a==1?1:mul(mod-mod/a,inv(mod%a)); &#125;int inv2 = inv(2);bool p[maxm];int pri[maxm];//质数int phi[maxm];//欧拉函数前缀和void init()&#123; phi[1] = 1; for(int i =2;i&lt;maxm;i++)&#123; if(!p[i])&#123; pri[++pri[0]] = i; phi[i] = i-1; &#125; for(int j = 1;j&lt;=pri[0]&amp;&amp;i*pri[j]&lt;maxm;j++)&#123; p[i*pri[j]] = true; if(i%pri[j]) phi[i*pri[j]] = phi[i]*(pri[j]-1); else&#123; phi[i*pri[j]] = phi[i]*pri[j]; break; &#125; &#125; &#125; for(int i = 2;i&lt;maxm;i++) phi[i] = add(phi[i],phi[i-1]);//因为只会用到前缀和,所以我们直接预处理成前缀和&#125;map&lt;long long,int&gt; mp;int solve(long long m)&#123; if(m&lt;maxm) return phi[m];//查表 if(mp[m]) return mp[m];//记忆化 int ret = mul(m,mul(m+1,inv2)); for(long long l = 2,r;l&lt;=m;l = r+1) &#123;//分块 r = m/(m/l); ret = add(ret,mod-mul(solve(m/l),r-l+1)); &#125; return mp[m] = ret;&#125;int main()&#123; init(); int ans = 0; for(long long x = 2;x&lt;=upper;x&lt;&lt;=1) &#123;//单独统计每一个2的幂 cout&lt;&lt;x&lt;&lt;endl; ans = add(ans,solve(upper/x)); ans = add(ans,mod-1); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 222 Sphere Packing]]></title>
    <url>%2F2019%2F01%2F04%2FPE222%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 What is the length of the shortest pipe, of internal radius $50$mm, that can fully contain $21$ balls of radii $30$mm, $31$mm, …, $50$mm? Give your answer in micrometres ($10^{-6}$ m) rounded to the nearest integer. 题意让你在一个内径$50$的圆管里塞$21$个内径分别为$31-50$的小球,问你圆管最短是多少 分析比较显然是dp 考虑dp状态:dp[i][j]表示选择小球对应的集合为j,并且用第i个小球结尾,然后我们转移的时候就直接添加一个小球,对于剩余的小球枚举一个结尾,取最优解就行了 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 21;double ans[maxm][1&lt;&lt;maxm];int num[maxm+10];double cal(int a,int b)&#123;//得到两个小球的距离 int t = a+b+60; return 10*sqrt(t*2-100);&#125;int main()&#123; for(int i = 0;i&lt;maxm;i++) for(int j = 0;j&lt;(1&lt;&lt;maxm);j++) ans[i][j] = 1e8; for(int s = 0;s&lt;(1&lt;&lt;maxm);s++) for(int i = 0;i&lt;maxm;i++)&#123; if(s==0)&#123;//初值条件 ans[i][1&lt;&lt;i] = i+30; continue; &#125; if((s &gt;&gt; i &amp; 1)==1) continue; int t = s|(1&lt;&lt;i);//用S来扩展t for(int j = 0;j&lt;maxm;j++) if(s&gt;&gt;j&amp;1) ans[i][t] = min(ans[i][t],ans[j][s]+cal(i,j)); &#125; double rans = 1e8; for(int i = 0;i&lt;maxm;i++) rans = min(rans,ans[i][(1&lt;&lt;maxm)-1]+i+30); printf("%.0f\n",rans*1000); return 0;&#125;]]></content>
      <tags>
        <tag>PE</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 122 Efficient exponentiation]]></title>
    <url>%2F2019%2F01%2F02%2FPE122%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The most naive way of computing $n^{15}$ requires fourteen multiplications: $n \times n \times \dots \times n = n^{15}$ But using a “binary” method you can compute it in six multiplications: \begin{eqnarray}n \times n &amp;= n^2\\n^2 \times n^2 &amp;= n^4\\n^4 \times n^4 &amp;= n^8\\n^8 \times n^4 &amp;= n^{12}\\n^{12} \times n^2 &amp;= n^{14}\\n^{14} \times n &amp;= n^{15}\\\end{eqnarray} However it is yet possible to compute it in only five multiplications: \begin{eqnarray}n \times n &amp;= n^2\\n^2 \times n &amp;= n^3\\n^3 \times n^3 &amp;= n^6\\n^6 \times n^6 &amp;= n^{12}\\n^{12} \times n^3 &amp;= n^{15}\\\end{eqnarray} We shall define $m(k)$ to be the minimum number of multiplications to compute $n^k$; for example $m(15) = 5$. For $1 \leq k \leq 200$, find $\sum m(k)$. 题意我们知道快速计算一个数的幂次有各种不同的方法,快速幂只是其中一种而且不是最快的,然后问你对于1~200的幂次来说,最少需要几次乘法操作. 分析有一个wiki讲的就是这个问题,可以看一看…. 我们可以发现,对于所有幂次来说,我们按照最后一步操作的数来构成他的前驱,然后我们会发现他是一棵树,然后我们直接构造出这颗树出来,就是最优答案….. 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s[222];void cal(int a)&#123; int now = 1e8,ind = 0; for(int i = 1;i&lt;=a;i++)&#123;//枚举每一个比他小的数,看是否可以作为他的前驱 if(s[i].size()+1&gt;=now) continue;//如果不能优化解就不继续搜索 for(int x:s[i])//枚举每一个前驱的子元素 if(s[i].find(a-x)!=s[i].end())&#123;//如果能构成a now = s[i].size()+1;//更新解 ind = i; break; &#125; &#125; for(int i:s[ind]) s[a].insert(i);//保存路径 s[a].insert(a);&#125;int main()&#123; s[1].insert(1); for(int i = 2;i&lt;=200;i++) cal(i); int ans = 0; for(int i = 1;i&lt;=200;i++) ans+=s[i].size()-1;//要把里面的1剪掉,因为合成1不要代价 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 143 Investigating the Torricelli point of a triangle]]></title>
    <url>%2F2018%2F12%2F28%2FPE143%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Let ABC be a triangle with all interior angles being less than $120$ degrees. Let $X$ be any point inside the triangle and let $XA = p, XC = q$, and $XB = r$. Fermat challenged Torricelli to find the position of X such that $p + q + r$ was minimised. Torricelli was able to prove that if equilateral triangles AOB, BNC and AMC are constructed on each side of triangle ABC, the circumscribed circles of AOB, BNC, and AMC will intersect at a single point, T, inside the triangle. Moreover he proved that T, called the Torricelli/Fermat point, minimises $p + q + r$. Even more remarkable, it can be shown that when the sum is minimised, $AN = BM = CO = p + q + r$ and that AN, BM and CO also intersect at T. If the sum is minimised and a, b, c, p, q and r are all positive integers we shall call triangle ABC a Torricelli triangle. For example, $a = 399, b = 455, c = 511$ is an example of a Torricelli triangle, with $p + q + r = 784$. Find the sum of all distinct values of $p + q + r ≤ 120000$ for Torricelli triangles. 题意就是三个角都小于120度的三角形存在费马点,然后让你找到所有这样的三角形,使得图上对应的六条边都是整数,其中$T$就是费马点.然后你要找到所有$p+q+r$不同的所有三角形,然后把$p+q+r$求和. 分析对于每一个圆来说,因为里面的三角形是对边三角形,然后因为$T$在园上,于是有$T$对应的角大小一定是$180-60 = 120$度,然后同理可得,三个角都是$120$度,然后我们运用余弦定理可以得到$p^2+q^2+pq=b^2$,因为我们只要$p+q+r$不同的解,所以我们不妨设$p&gt;=q&gt;=r$,因为三个角都是$120$度,所以余弦定理都成立,所以我们可以得到 \begin{eqnarray}q^2+r^2+qr &amp;= a^2\\p^2+q^2+pq &amp;= b^2\\p^2+r^2+pr &amp;= c^2\\p&gt;=q&gt;=r\\\end{eqnarray} 然后我们对于每对关系,可以显然发现都应该是类似的,然后我们可以存下来每个关系,然后暴搜就行了,emmmmmm$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int upper = 1.2e5;set&lt;int&gt; to[upper+10];bool ans[upper&lt;&lt;2];int main()&#123; for(long long i = 1;i&lt;=upper;i++)&#123; for(long long j = min(upper-i,i);j&gt;=1;j--)&#123; long long x = i*i+j*j+i*j; long long y = sqrt(x); if(y*y==x) to[i].insert(j); &#125; if(i%10==0) cout&lt;&lt;i&lt;&lt;'\n'; &#125; for(int i = 1;i&lt;=upper;i++)&#123; for(int j:to[i])&#123; for(int k:to[j])&#123; if(i+j+k&gt;upper) continue; if(to[i].count(k))&#123; ans[i+j+k] = true; &#125; &#125; &#125; &#125; int rans = 0; for(int i = 1;i&lt;=upper;i++) if(ans[i]) rans+=i; cout&lt;&lt;rans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcd and fibonacii]]></title>
    <url>%2F2018%2F12%2F28%2Fgcd_fibonacci%2F</url>
    <content type="text"><![CDATA[前两天看到一个比较奇怪的公式,然后队友让证明一下,公式如下 $$gcd(f_i,f_j) = f_{gcd(i,j)}$$ 下面给出证明 $gcd(f_i,f_{i-1}) = 1$\begin{eqnarray}gcd(f_i,f_{i-1}) &amp;=&amp; gcd(f_{i-1}+f_{i-2},f_{i-1})\\&amp;=&amp; gcd(f_{i-2},f_{i-1})\\&amp;=&amp; gcd(f_{i-3},f_{i-2})\\&amp;=&amp; \dots\\&amp;=&amp; gcd(f_1,f_2)\\&amp;=&amp; 1\\\end{eqnarray} $f_{i+j} = f_{i-1}\cdot f_j + f_i\cdot f_{j+1}$首先,$j = 1$时有 $f_{i+1} = f_{i-1}+f_i$ 显然成立, 当$j = 2$时有 \begin{eqnarray}f_{i+2} &amp;=&amp; f_{i+1} + f_{i}\\&amp;=&amp; (f_{i}+f_{i-1}) + f_{i}\\&amp;=&amp; f_{i-1} \cdot 1 + f_{i} \cdot 2\\&amp;=&amp; f_{i-1} \cdot f_j + f_i \cdot f_{j+1}\\\end{eqnarray} 然后我们证明,当$j = k-1$和$j = k-2$成立时,$j = k$也成立 也就是说已知 $$\begin{cases}f_{i+k-1} &amp;=&amp; f_{i-1}\cdot f_{k-1} + f_{i}\cdot f_k\\f_{i+k-2} &amp;=&amp; f_{i-1}\cdot f_{k-2} + f_{i}\cdot f_{k-1}\\\end{cases}$$ 然后我们累加上面两式,可以得到 $$f_{i+k-1}+f_{i+k-2} = f{i-1}\cdot f_{k-1} + f_{i}\cdot f_k + f{i-1}\cdot f_{k-2} + f_{i}\cdot f_{k-1}$$ $$\therefore\begin{eqnarray}f_{i+k} &amp;=&amp; f_{i-1}\cdot (f_{k-1}+f{k-2}) + f_{i}\cdot (f_{k}+f_{k-1})\\ &amp;=&amp; f_{i-1}\cdot f_{k} + f_{i}\cdot f_{k+1}\\\end{eqnarray}$$ $ gcd(f_{i+j},f_{i}) = gcd(f_{i},f_{j}) $$$\begin{eqnarray}gcd(f_{i+j},f_{i}) &amp;=&amp; gcd(f_{i-1}\cdot f_j + f_i\cdot f_{j+1},f_{i})\\&amp;=&amp; gcd(f_{i-1}\cdot f_{j},f_{i})\\&amp;=&amp; gcd(f_{j},f_{i}) (\because gcd(f_{i},f_{i-1}) = 1)\\\end{eqnarray}$$ 所以上面的结论可以继续推广,容易得到 $$gcd(f_{i},f_{j}) = gcd(f_{i\%j},f_{j})$$ $gcd(f_{i},f_{j}) = f_{gcd(i,j)} $由上面的结论,我们容易得到,我们不断调用上面的结论,直到$i==1||j==1$,然后可以得到,如果$k=gcd(i,j)$,那么有$gcd(f_{i},f_{j}) = gcd(f_{k},f_{1}) = f_{k} = f_{gcd(i,j)}$ 命题得证]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IC(answer.chepter1)]]></title>
    <url>%2F2018%2F12%2F24%2FIC_chepter1%2F</url>
    <content type="text"><![CDATA[作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢 1.利用反证法容易得到,如果$n$和$m$都是奇数,那么$n*m$也是奇数,显然不可覆盖,所以$n$和$m$至少有一个偶数 2.我们定义行号从上到下为$1\dots m$,列号从左到右为$1\dots n$,然后我们就可以得到被切掉的那个方块只可能是奇数行奇数列,或者偶数行偶数列,我们考虑对这两种方案分别进行构造来得到我们想要的答案. 奇数行奇数列:对于和他在同一行同一列的方块来说,因为他去掉了,所以剩下的一定是可以匹配的偶数,也就是说我们可以匹配上这一行一列,对于剩下的一定都是偶数行偶数列的联通块,显然可以构造 奇数行奇数列:这个稍微麻烦一点,我们可以选择他周围的奇数行奇数列的一个子矩阵,显然可以螺旋式的构造,也就是说我们用完左上角,对于剩下的容易证明也是两个偶数的联通块,同样可以构造,看图 3.显然是不能获得自由的,因为我们可以将这个棋盘黑白二染色,然后可以发现对顶角颜色相同,每一步颜色都会反转,一共要走63步,所以最后一步一定会在异色块上,所以不行. 4.(a)对于每一个$n$来说我们直接考虑最后一块的摆放方法,如果是竖着放,那么剩下的就是$f(n-1)$的子问题,如果是横着放,那么倒数第二块显然也是横着放的,所以剩下的就是$f(n-2)$的子问题,所以显然可以得到的是$f(n) = f(n-1)+f(n-2)$,也就是说答案就是fibonacci.$\therefore f(12) = 233$ 4.(b)这里我们可以考虑DP来做,具体程序如下: 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e5+10;int dp[maxm][8];int main()&#123; dp[0][0] = dp[0][3] = dp[0][6] = dp[1][1] = dp[1][4] = dp[1][7] = 1; for(int i = 2;i&lt;maxm;i++)&#123; dp[i][0] = dp[i-2][3]+dp[i-2][6]+dp[i-2][0]; dp[i][1] = dp[i-1][0]+dp[i-2][1]; dp[i][3] = dp[i][0]+dp[i-2][3]; dp[i][4] = dp[i][1]; dp[i][6] = dp[i][3]; &#125; return 0;&#125; 然后可以发现$g(n) = 4\ast g(n-2)-g(n-4)$ 5.用4.(b)的代码容易可得,$g(4) = 11$ 6.同样采用反证法容易证得$n$是偶数,下面我们考虑$n$是奇数扣掉中间一块的情况.不妨假设八个角上的颜色是黑色,可以得到黑块数量是$4k^3+6k^2+3k+1$,白块的数量是$4k^3+6k^2+3k$,我们可以分两种情况讨论,我们假设$n = 2k+1$ 当k是奇数时,也就是$k = 2t+1$,即$n = 4t+3$,中间块是白色的.然后扣掉白块后,显然黑块和白块不匹配,然后不行鸭. 当k是偶数时,也就是$k = 2t$,即$n = 4t+1$,中间块是黑色的,扣掉黑块后,白块和黑块是匹配的,可能可以.下面我们证明$n = 4t+1$时是可行的 我们按照层数拆分,我们抽掉其中的第$2t+1$层,我们可以得到,这一层显然是可行的,类比于二阶的时候,我们扣掉中心块 对于剩下的两个联通块,我们显然可以得到是他们对称,我们只考虑上面的$2t$层的部分,我们每两层考虑一下 对于相连的两层,也就是$2\ast n\ast n$的形状,我们显然可以构造,所以整个三维结构是可以构造的. 7.首先证明$a$既是$n$的因子,又是$m$的因子 因为$a$是$b$的因子,所以$a\ast b$的可以看成多个$a\ast a$的,采用反证法,假设$a$不是$m$的因子,那么对于剩下的$(m%a)\ast (n%a)$的矩阵显然不可以用$a\ast a$的矩阵填满,所以$m%a==0&amp;&amp;n%a==0$. 再证$b$是$n$或者$m$的因子 同样反证法,我们将$a,b,m,n$同时缩小$a$倍,然后可以转化成,现在有一个$x\ast y$的棋盘,我要用一个$1\ast z$的棋盘去覆盖他,但是$gcd(x,z)=gcd(y,z)=1$,这个可以显然发现是不可能的 8.先证:存在完美覆盖$\rightarrow$存在平凡完美覆盖 利用习题7,我们得到如果存在完美覆盖,那么$gcd(n,a)=gcd(m,a)=a$并且$gcd(m,b)=b$,然后我们显然可以让$b$的朝向指向$m$的方向,也就是存在平凡完美覆盖 再证:存在平凡完美覆盖$\rightarrow$存在完美覆盖 显然 9.显然,举个简单例子$n=5,m=6,a=2,b=3$存在完美覆盖,但是不存在平凡完美覆盖. 10.假设存在不妨设四个变量是$a,b,c,d$,那么可以得到$a+b=b+c$即$a=c$显然不能构成幻方 11.12.13 如图 14.所有可能的构造如图 15.暴力枚举的,确实没有解,并不知道为什么…… 16.$n$阶幻方,幻方总和是$n^2\ast (n^2+1)/2$,所以每一行每一列求和都是$n\ast (n^2+1)/2$,现在替换后每一行每一列的和换成了$n\ast (n^2+1) - n\ast (n^2+1)/2 = n\ast (n^2+1)/2$所以可能是个幻方,然后因为里面的元素都是属于$[1,n^2]$之间的,所以$n^2+1-a$可以保证换完之后每个元素还是只出现一次,所以新生成的还是幻方. 17.给出$n=4$和$n=8$时的图……. 18.这个应该是显然的,因为二阶幻方都没有,显然没有二阶幻方体. 19.首先我们拆开来看没一个单独的平面,我们可以得到,对于一个四阶幻方来说,如果对角线也满足幻和,那么显然可以得到任意三阶子矩阵的对顶角之和等于幻和的一半,所以我们任取出四阶幻方体的任一三阶子体,可以得到类似于$a+b=b+c$的等式,也就是说存在$a==c$的情况,这显然和题意不符,所以不可能存在四阶幻方体. 20.首先,$10$和$5$一个颜色,$1,3,7,9$一个颜色,$2,4,6,8$一种颜色,可以得到可以由三种颜色构成,然后,$1,2,10$相互接壤,显然需要三种及以上颜色来涂,方案数为$3\ast 2\ast 1 = 6$. 21.(a) 二阶的显然不存在,书后面给了答案,还有一个比较简单的想法就是如果存在显然可以得到类似于$a==b$的结论,所以不存在. (b) 暴搜剪枝,emmmmm……如图]]></content>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IC(answer.chepter2)]]></title>
    <url>%2F2018%2F12%2F24%2FIC_chepter2%2F</url>
    <content type="text"><![CDATA[作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢 1.$\emptyset$ : $4^5 = 1024$.$\lbrace a\rbrace$ : $5\times 4\times 4\times 4 = 320$.$\lbrace b\rbrace$ : $5\times 5\times 5\times 2 = 250$.$\lbrace a,b\rbrace$ : $4\times 4\times 4\times 2 = 128$ 2.$(13!)^4 = 1503561738404723998944447273369600000000$. 3.$$\left( \begin{matrix} 52\\ 5 \end{matrix}\right)=2598960$$ 4.(a) $5\times 3\times 7\times 2 = 210$(b) $620 = 2^2+3^1+5^1+7^1$,$3\times 2\times 2\times 2 = 24$(c) $10^{10} = 2^{10} 5^{10}$,$11\times 11 = 121$ 5.因为$10 = 2\times 5$,所以我们只用统计$2,5$的数量就行了,然后我们可以发现,$2$的数量显然多于$5$的数量,所以我们只用统计$5$的个数就是答案.下面给出一个通用的代码 12345int cal(int a)&#123; int ret = 0; while(a) ret+=a/=5; return ret;&#125; 6.小数据暴力,大数据模拟]]></content>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 463 A weird recurrence relation]]></title>
    <url>%2F2018%2F12%2F23%2FPE463%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The function $f$ is defined for all positive integers as follows: $f(1)$ = $1$ $f(3)$ = $3$ $f(2n)$ = $f(n)$ $f(4n+1)$ = $2\cdot f(2n+1)-f(n)$ $f(4n+3)$ = $3\cdot f(2n+1)-2\cdot f(n)$ The function $S(n)$ is defined as $\sum_{i=1}^{n} f(i)$. $S(8)=22$ and $S(100)=3604$. Find $S(3^{37})$. Give the last $9$ digits of your answer. 题意就是给你一个序列,问你这个序列的前缀和是多少 分析显然是推公式嘛. 根据题意我们显然可以得到 $f(4n)+f(4n+1)+f(4n+2)+f(4n+3) = 6\cdot f(2n+1) - 2\cdot f(n)$ for $n\geq 1$ 然后我们每四项加一下就可以得到下面这个公式 \begin{eqnarray}S(4n+3) &amp;=&amp; \sum_{i=1}^{4i+3} f(i)\\ &amp;=&amp; 5 + \sum_{i=4}^{4i+3} f(i)\\ &amp;=&amp; 5 + \sum_{i=1}^{n} (6\cdot f(2i+1) - 2\cdot f(i))\\ &amp;=&amp; 5 + 6\sum_{i=1}^{n} (f(2i+1)+f(2i)) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; 5 + 6\sum_{i=2}^{2n+1} f(i) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; 5 - 6 + 6\sum{i=1}{2n+1} f(i) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; -1 + 6\sum{i=1}{2n+1} f(i) -8\sum_{i=1}^{n} f(i)\\\end{eqnarray} 然后瞎搞就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+10;const int mod = 1e9;inline int add(long long a,long long b)&#123;return (a+b)%mod;&#125;inline int mul(long long a,long long b)&#123;return a*b%mod;&#125;int num[maxm];int sum[maxm];long long f(long long a)&#123; if(a&lt;maxm&amp;&amp;num[a]) return num[a]; if(a==0) return 0; if(a==1) return 1; if(a==3) return 3; if((a&amp;1)^1) return f(a&gt;&gt;1); else if((a&amp;3)==3) return add(mul(3,f(a&gt;&gt;1)),mod-(f(a&gt;&gt;2)&lt;&lt;1)); else return add((f(a&gt;&gt;1|1)&lt;&lt;1),mod-f(a&gt;&gt;2));&#125;long long S(long long a)&#123; if(a&lt;maxm) return sum[a]; long long ret = 0; if(a%4==3)&#123; ret = add(ret,mul(6,S(a&gt;&gt;1))); ret = add(ret,mod-mul(8,S(a&gt;&gt;2))); ret = add(ret,mod-1); &#125;else&#123; while(a%4!=3) ret = add(ret,mod-f(++a)); ret = add(ret,S(a)); &#125; return ret;&#125;int main()&#123; for(int i = 1;i&lt;maxm;i++) num[i] = f(i),sum[i] = add(sum[i-1],num[i]); long long nouse = 1; for(int i = 1;i&lt;=37;i++)&#123; nouse = (nouse&lt;&lt;2)-nouse; &#125; cout&lt;&lt;S(nouse)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab]]></title>
    <url>%2F2018%2F12%2F23%2Fmatlab%2F</url>
    <content type="text"><![CDATA[系统级命令 命令名称 功能说明 clear 清楚内存中所有的或指定的变量和函数 cd 显示和改变当前工作目录 clc 擦除MATLAB工作窗口中所有显示的内容 clf 擦除MATLAB当前工作窗口中的图形 dir 列出当前或者指定目录下的子目录和文件清单 disp 在运行中显示变量或文字信息 echo 控制运行的文字命令是否显示 hold 控制当前的图形窗口对象是否被刷新 home 擦除命令窗口中的内容,并把光标移动到命令窗口 pack 收集内存碎片以扩大内存空间 quit 关闭并退出MATLAB type 显示所指定文件的全部内容 exit 退出MATLAB save 将工作区的变量存放到指定文件 load 回复保存过的变量 系统变量 变量 解释 ans 结果的缺省变量名 pi 圆周率 i,j 虚数单位 inf 无穷大 NaN not a number 矩阵函数 函数 解释 complex 将两个矩阵并成一个复矩阵 zeros(a,b) a*b全0阵 ones(a,b) a*b全1阵 eye(a,b) a*b单位矩阵 randi([a,b],m,n) m*n在a,b之间等概率随机整数矩阵 randn(a,b) 产生均值为0,方差为1的a*b的高斯分布随机阵 repmat(a,b,c) 将a矩阵铺放成bc的形式,总大小size(a)b*c size(a) 确定矩阵大小,返回[行数,列数] length(a) 确定向量元素的个数 numel(a) 确定矩阵中元素个数 find() 查找矩阵中满足条件的下标,或者行列 reshape(a,b,c) 将a变成b行c列(按列重拍) a’ 转置,复数则共轭转置 a(:) 变成一列 rot90 旋转 fliplr 左右翻转 flipud 上下翻转 diag 抽取主对角线 tril 抽取上三角 triu 抽取下三角 max 各列最大值 min 各列最小值 sort 各列递增排序 sum 各列求和 mean 各列平均值 std 各列标准差 var 各列方差 基本数学函数 函数 解释 abs(x) x中每个实数元素的绝对值,复数元素的模 sqrt(x) x中每个元素求平方根 exp(x) 指数运算 real(x) 求实部 imag(x) 求虚部 conj(x) 求共轭 angle(x) 求相位角 sin(x) 正弦 cos(x) 余弦 asin(x) 反正弦 acos(x) 反余弦 tan(x) 正切 atan(x) 反正切 log10(x) 常用对数lgx log(x) 自然对数lnx loga(b) 任意对数 mod(x,y) 求余函数 rem(x,y) 输出对应元素的余数 sign(x) 求矩阵中元素的正负号 lcm(x,y) 最小公倍数 gcd(x,y) 最大公约数 round(a) 四舍五入 fix(a) 按0的方向取整 floor(a) 向负无穷方向取整 ceil(a) 向正无穷方向取整 randperm(n) 产生一个长度为n的排列 绘图 函数 解释 plot(x,y,’option’) x横轴,y纵轴,逐点连折线绘制二维图形,参数见下表 plot(y) y为向量,以下标作为x轴,y为纵轴,绘制曲线 title(‘text’) 添加标题 xlabel(‘text’) x轴加标注 ylabel(‘text’) y轴加标记 legend(‘图例1’,’图例2’,…) 添加图例 text(x,y,’text’) 在指定位置添加文本字符串 gtext(‘text’) 用鼠标放置文本 axis([xmin xmax ymin ymax zmin zmax]) 调整坐标 hold 图形保持函数 subplot 子图分割命令 stem 离散序列 绘图参数表 符号 含义 符号 含义 y 黄 b 蓝 m 洋红 w 白 c 青 k 黑 r 红 g 绿 - 实线 – 虚线 : 点线 -. 点划线 . 点 o 圆 x 叉号 + 加号 ^ 向上的三角形 v 向下的三角形 &gt; 大于号 &lt; 小于号 s 正方形 d 菱形 p 五角星 h 六角星 * 星号 字符串函数 函数 解释 abs 字符串到ascii转换 str2mat 字符串转换成字符矩阵 setstr ascii转字符串 num2str 数值转字符串 str2num 字符串转换成数值 dec2bin 十进制数转二进制字符串 bin2dec 二进制串转十进制 int2str 将数值取整后转成字符串 upper 字符串转换成大写 lower 字符串转换成小写 sprintf 用格式控制,数字转字符串 sscanf 格式控制,字符串转数字 输入输出 函数 解释 input(‘text’) 键盘提示输入 fprintf() 格式输出]]></content>
      <tags>
        <tag>live</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 368 A Kempner-like series]]></title>
    <url>%2F2018%2F12%2F21%2FPE368%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The harmonic series $1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\dots$ is well known to be divergent. If we however omit from this series every term where the denominator has a $9$ in it, the series remarkably enough converges to approximately $22.9206766193$. This modified harmonic series is called the Kempner series. Let us now consider another modified harmonic series by omitting from the harmonic series every term where the denominator has $3$ or more equal consecutive digits. One can verify that out of the first $1200$ terms of the harmonic series, only $20$ terms will be omitted.These $20$ omitted terms are: $$\frac{1}{111},\frac{1}{222},\frac{1}{333},\frac{1}{444},\frac{1}{555},\frac{1}{666},\frac{1}{777},\frac{1}{888},\frac{1}{999},\frac{1}{1000},\frac{1}{1110}, \frac{1}{1111},\frac{1}{1112},\frac{1}{1113},\frac{1}{1114},\frac{1}{1115},\frac{1}{1116},\frac{1}{1117},\frac{1}{1118},\frac{1}{1119}$$ This series converges as well. Find the value the series converges to.Give your answer rounded to $10$ digits behind the decimal point. 题意就是,调和级数不是发散的嘛,然后让你删掉那些分母含有连续三个相同数字的,然后可以证明剩下的级数是收敛的,然后问你收敛于多少. 分析做法比较巧妙,下面一点点分析. 首先我们令$S_1(n,d)$表示一个包含所有这样的$n$位数的集合,集合中所有的$n$位数最后一位是$n$,并且倒数第二位不是$n$. $S_2(n,d)$表示一个包含所有这样的$n$位数的集合,集合中所有的$n$位数最后两位是$n$,并且倒数第三位不是$n$. 然后我们令 $f_1(n,d,j)$ = $\sum_{x\in S_1(n,d)} \frac{1}{x^j}$ $f_2(n,d,j)$ = $\sum_{x\in S_2(n,d)} \frac{1}{x^j}$ 然后答案显然就是 $\sum_{i=1}^{99} \frac{1}{i}+\sum_{n=3}^{\infty } \sum_{d=0}^{9} [f_1(n,d,1)+f_2(n,d,1)]$ 关键是我们怎么算$f_1(n,d,j)$和$f_2(n,d,j)$ 二者分析方法一样,这里给出$f_2(n,d,j)$怎么推出来的. 首先根据定义我们有 $f_2(n,d,j)$ = $\sum_{x\in S_2(n,d)} \frac{1}{x^j}$ 我们不妨枚举每一个$x$,然后累加就是答案,所以子问题就是如何快速计算$\frac{1}{x^j} where x \in S_2(n,d)$ 因为最后一位是$d$,所以我们不妨设$x$ = $y\ast 100+d\ast 10+d$ 然后可以得到 $$(\frac{1}{x\ast 100+d\ast 10+d})^j=\frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot (\frac{1}{1+\frac{d}{x\ast 100+d\ast 10}})^j$$ 然后我们将第三个分式化简. 考虑到 $(1+a)^{-b} = \sum_{i=0}^{\infty } C_{b+i-1}^i \cdot (-a)^b$ 所以上式可以化简为 \begin{eqnarray}(\frac{1}{x\ast 100+d\ast 10+d})^j&amp;=&amp; \frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot \sum_{i=0}^{\infty } C_{j+i-1}^{i}(\frac{-d}{x\ast 100+d\ast 10})^i\\&amp;=&amp; \frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot \sum_{i=0}^{\infty } C_{j+i-1}^{i}(\frac{-d}{10})^i\cdot(\frac{1}{x\ast 10+d})^i\\&amp;=&amp; \frac{1}{10^j} \sum_{i=0}^{\infty } C_{j+i-1}^{i} \cdot (\frac{-d}{10})^i \cdot (\frac{1}{x\ast 10+d})^{i+j}\\\end{eqnarray} 然后我们考虑累加所有的$x$也就是原来的$f_2(n,d,j)$ 可以得到 $$f_2(n,d,j) = \frac{1}{10^j} \sum_{i=0}^{\infty } (\frac{-d}{10})^i \cdot C_{j+i-1}^{i} \cdot f_1(n-1,d,i+j)$$ 同理可以推得 $f_1(n,d,j)$ 然后就是代码如下啦啦啦$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 40;double C[maxm*3][maxm*3];double f1[2][10][maxm+1];double f2[2][10][maxm+1];double ans = 0;void init()&#123;//预处理出组合数和前99项的答案 for(int i = 0;i&lt;maxm*3;i++) for(int j = 0;j&lt;=i;j++)&#123; if(j==0) C[i][j] = 1; else C[i][j] = C[i-1][j-1]+C[i-1][j]; &#125; for(int i = 1;i&lt;100;i++) ans+=1.0/i;&#125;int main()&#123; init(); for(int d = 0;d&lt;=9;d++)&#123;//预处理出n = 3的情况 for(int j = 1;j&lt;=maxm;j++)&#123; for(int pre = 10;pre&lt;100;pre++)&#123; int fir = pre/10; int sec = pre%10; if(fir==sec&amp;&amp;sec==d) continue; if(sec==d) f2[1][d][j]+=1.0/pow(pre*10+d,j); else f1[1][d][j]+=1.0/pow(pre*10+d,j); &#125; &#125; ans+=f1[1][d][1]+f2[1][d][1]; &#125; for(int nouse = 4;nouse&lt;=10000;nouse++)&#123;//滚动的算n&gt;=4的时候 int now = nouse&amp;1; int las = now^1; for(int d = 0;d&lt;=9;d++)&#123; for(int j = 1;j&lt;=maxm;j++)&#123; f1[now][d][j] = f2[now][d][j] = 0;//别忘了初始化 double pre = 1.0/pow(10.0,j); for(int i = 0;i&lt;=maxm;i++)&#123; if(i+j&lt;=maxm) f2[now][d][j]+=pre*C[j+i-1][i]*f1[las][d][i+j]; for(int x = 0;x&lt;10;x++)&#123; if(x==d) continue; if(i+j&lt;=maxm) f1[now][d][j]+=pre*C[j+i-1][i]*(f1[las][x][i+j]+f2[las][x][i+j]); &#125; pre*=-d/10.0; &#125; &#125; ans+=f1[now][d][1]+f2[now][d][1]; &#125; printf("%.10f\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 492 Exploding sequence]]></title>
    <url>%2F2018%2F12%2F12%2FPE492%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Define the sequence $a_1, a_2, a_3,\dots$ as: $a_1 $=$ 1$ $a_{n+1} = 6a_n^2 + 10a_n + 3$ for $n \geq 1$. Examples: $a_3 $=$ 2359$ $a_6 $=$ 269221280981320216750489044576319$ $a_6 mod 1000000007 $=$ 203064689$ $a_{100} mod 1000000007 $=$ 456482974$ Define $B(x,y,n)$ as $\sum (a_n mod $ $p)$ for every prime $p$ such that $x \leq p \leq x+y$. Examples: $B(10^9, 10^3, 10^3)$ = $23674718882$ $B(10^9, 10^3, 10^{15})$ = $20731563854$ Find $B(10^9, 10^7, 10^{15})$. 题意给你一个二次递推序列,问你这个数列的第$10^{15}$项膜上一堆质数之后求和是多少. 分析看了大佬的题解之后才做出来的,还是太菜了$\dots$ 下面是分析. 首先我们令$b_n = 6a_n+5$ 于是有 $b_1$ = $11$ $b_{n+1} $=$ b_n^2-2$ 然后我们令 $ x + \frac{1}{x}$ = $11$ 可以显然发现 $b_n$ = $x^{2^{n-1}} + \frac{1}{x^{2^{n-1}}}$ 于是不妨设 $x$ = $\frac{11+\sqrt{117}}{2}$ $\therefore b_n$ = $(\frac{11+\sqrt{117}}{2})^{2^{n-1}} + (\frac{11-\sqrt{117}}{2})^{2^{n-1}}$ 然后我们可以直接算就行了 我们搞出递推式，然后用矩阵乘法的做法来做 我们考虑一个更一般的问题， 令$f_n = (\frac{11+\sqrt{117}}{2})^n + (\frac{11-\sqrt{117}}{2})^n$ 然后我们考虑$f_n$如何求解 首先我们假设$f_n = x\ast f_{n-1}+y\ast f_{n-2}$ $$令 (\frac{11+\sqrt{117}}{2})^{n-2} = a$$ $$令 (\frac{11-\sqrt{117}}{2})^{n-2} = b$$ 则有\begin{cases}\begin{eqnarray}f_n &amp;=&amp; a\ast (\frac{11+\sqrt{117}}{2})^2+b\ast (\frac{11-\sqrt{117}}{2})^2\\&amp;=&amp; a\ast (\frac{238+22\sqrt{117}}{4})+b\ast (\frac{238-22\sqrt{117}}{4})\\f_{n-1}&amp;=&amp;a\ast (\frac{11+\sqrt{117}}{2})+b\ast (\frac{11-\sqrt{117}}{2})\\f_{n-2}&amp;=&amp;a+b \\\end{eqnarray}\end{cases} \begin{eqnarray}&amp;\therefore&amp; a\ast (\frac{238+22\sqrt{117}}{4})+b\ast (\frac{238-22\sqrt{117}}{4})\\&amp;=&amp; x\ast a\ast (\frac{11+\sqrt{117}}{2})+x\ast b\ast (\frac{11-\sqrt{117}}{2}) + y\ast (a+b)\\\end{eqnarray} 将非根号项提出来，可以得到 $\therefore a\ast \frac{119}{2}+b\ast \frac{119}{2}$=$xa\ast \frac{11}{2}+xb\ast \frac{11}{2}+y(a+b) $ 同理将根号项提出可以得到 $a\ast \frac{11}{2}+b\ast \frac{-11}{2}$=$xa\ast \frac{1}{2}+xb\ast \frac{-1}{2} $ 然后可以解得 \begin{cases}x = 11\\y = -1\end{cases} 也就是说$f_n$ = $11\ast f_{n-1} - f_{n-2}$ 好了，我们得到了$f_n$的递推式，然后考虑原问题，也就是说 $$\left( \begin{matrix} b_{n+1}\\ b_n \end{matrix}\right)=\left( \begin{matrix} 11 &amp; -1\\ 1 &amp; 0 \end{matrix}\right)^{2^{n-1}-1}\left( \begin{matrix} b_2\\ b_1 \end{matrix}\right)=\left( \begin{matrix} 11 &amp; -1\\ 1 &amp; 0 \end{matrix}\right)^{2^{n-1}-1}\left( \begin{matrix} 119\\ 11 \end{matrix}\right)$$ $\because n$ 很大($10^{15}$) $\therefore 2^{n-1}-1$很大,以至于我们不能方便的计算 然后我们考虑降低指数 具体分析看大佬的分析,可以得到循环节可以是$(p+1)(p-1)$ 这个值我们可以接受,然后直接裸的矩阵ksm就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const long long n = 1e15;const long long l = 1e9;const long long r = l+1e7;long long add(long long a,long long b,long long mod)&#123; return (a+b)%mod; &#125;long long mul(long long a,long long b,long long mod)&#123; a = add(a,mod,mod); b = add(b,mod,mod); long long ret = 0; while(b)&#123; if(b&amp;1) ret = add(ret,a,mod); a = add(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;long long qpow(long long a,long long b,long long mod)&#123; long long ret = 1; while(b)&#123; if(b&amp;1) ret = mul(ret,a,mod); a = mul(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;bool is_prime(int a)&#123; if(a&amp;1)&#123; for(int i = 3;i*i&lt;=a;i++) if(a%i==0) return false; return true; &#125; return false;&#125;struct p&#123; int mat[2][2]; void show()&#123; for(int i = 0;i&lt;2;i++)&#123; for(int j = 0;j&lt;2;j++) cout&lt;&lt;mat[i][j]&lt;&lt;' '; cout&lt;&lt;endl; &#125; &#125;&#125;;p mul(p a,p b,long long mod)&#123; p ret; memset(ret.mat,0,sizeof ret.mat); for(int i = 0;i&lt;2;i++)&#123; for(int j =0;j&lt;2;j++)&#123; for(int k = 0;k&lt;2;k++)&#123; ret.mat[i][j] = add(ret.mat[i][j],mul(a.mat[i][k],b.mat[k][j],mod),mod); &#125; &#125; &#125; return ret;&#125;p qpow(p a,long long b,long long mod)&#123; p ret; for(int i = 0;i&lt;2;i++) for(int j = 0;j&lt;2;j++) &#123; if(i==j) ret.mat[i][j]=1; else ret.mat[i][j]=0; &#125; while(b)&#123; if(b&amp;1) ret = mul(ret,a,mod); a = mul(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;long long solve(long long prime)&#123; const long long MOD = prime*prime-1; long long zhi = qpow(2,n-1,MOD); zhi = add(zhi,MOD-1,MOD); p base; base.mat[0][0]=11,base.mat[0][1]=-1; base.mat[1][0]=1 ,base.mat[1][1]=0; base = qpow(base,zhi,prime); long long ret1 = mul(base.mat[1][0],119,prime); long long ret2 = mul(base.mat[1][1],11,prime); return add(ret1,ret2,prime);&#125;long long inv(long long a,long long mod)&#123; if(a==1) return 1; return mul(mod-mod/a,inv(mod%a,mod),mod);&#125;int main()&#123; long long ans = 0; for(int i = l;i&lt;=r;i++)&#123; if(is_prime(i))&#123; long long bn = solve(i); long long now1 = add(bn,i-5,i); long long an = mul(now1,inv(6,i),i); ans+=an; &#125; if(i%100000==0) cout&lt;&lt;i&lt;&lt;endl; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 294 Sum of digits-experience]]></title>
    <url>%2F2018%2F12%2F09%2FPE294%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For a positive integer $k$, define $d(k)$ as the sum of the digits of $k$ in its usual decimal representation. Thus $d(42) = 4+2 = 6$. For a positive integer $n$, define $S(n)$ as the number of positive integers $k &lt; 10^n$ with the following properties : $k$ is divisible by $23$ and $d(k) = 23$. You are given that $S(9) = 263626$ and $S(42) = 6377168878570056$. Find $S(11^{12})$ and give your answer mod $10^9$. 题意你要找到一个所有满足一下三个条件的数字数量 假设这个数是$k$ $k$ $&lt;$ $10^{11^{12}}$ $k\%23$ = 0 $k$每个十进制位求和为$23$ 分析这个题目困扰了我两天,我一度以为自己读错题了,主要是数据范围太大了,大的人一点想法都没有$\dots$ 下面说正解 虽然数据范围很大,但是我们可以从小数据入手 先看第二个条件$k%23==0$,是否感觉出了一丝丝猫腻? 于是我大胆写了一下,比较好想的就是一定存在一个$n$使得$10^n%23==1$,也就是说存在膜数存在循环,而且显然有循环节是$O(23)$的 于是大胆暴力,找到了,循环节长度为$22$ 这也就是说,在十进制下,位数最多有$11^{12}$个,而且这些里面,可以拆分成$22$份,每一份里面,你不管把数字安排到哪里,都是同膜的 于是我们可以简单的把$11^{12}$近似的均分成了$22$份.而且每一份可以单独统计答案 然后问题就转化成了以下两个子问题: 找到$a_1,a_2\dots a_{22}$使得$a_1+a_2+\dots +a_{22} = 23$ 对于每一份就成了一个$a_i$个相同的球放入近似$11^{12}$个盒子里,每个盒子最多放$9$个球,问你方案数 对于第一个子问题,我们显然可以动态规划搞一搞 定义$dp(i,j,k)$表示$a_1+a_2+\dots +a_i == j$并且当前膜数为$k$的方案数 然后暴力转移就行了 关键是第二个子问题不好想,因为盒子数量太大了,必须要有一个$log$的做法 然后就枚举算法(毕竟会的算法不多) 然后就想到了分治,但是能不能分治呢,并不知道,写一发就知道了,然后跑的挺快的(然后就过了) 并不会算分治的玄学复杂度 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9;int add(int a,int b)&#123;return (a+b)%mod;&#125;int mul(int a,int b)&#123;return 1ll*a*b%mod;&#125;long long n,m;void init()&#123; m = 23; n = 1; for(int i = 1;i&lt;=12;i++) n*=11;&#125;map&lt;pair&lt;long long,int&gt;,int&gt;mp;int solve(long long a,int b)&#123;///b ball,a boxes if(a==1) return b&lt;=9; if(a==0) return b==0; pair&lt;long long,int&gt; now = make_pair(a,b); if(mp[now]) return mp[now]; int ret = 0; long long l = a/2,r = a-l; for(int i = 0;i&lt;=b;i++) ret = add(ret,mul(solve(l,i),solve(r,b-i))); return mp[now] = ret;&#125;long long dp[30][30][30];int main()&#123; init(); dp[0][0][0] = 1; int w = 1; for(int i = 0;i&lt;m;i++)&#123; long long has = n/(m-1) + (i&lt;n%22); for(int j = 0;j&lt;=m;j++)&#123; for(int k = 0;k&lt;m;k++)&#123; for(int t = 0;j+t&lt;=m;t++)&#123; dp[i+1][j+t][(k+w*t)%m] = add(dp[i+1][j+t][(k+w*t)%m],mul(dp[i][j][k],solve(has,t))); &#125; &#125; &#125; w = w*10%m; &#125; cout&lt;&lt;dp[m-1][m][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 288 An enormous factorial]]></title>
    <url>%2F2018%2F12%2F08%2FPE288%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For any prime $p$ the number $N(p,q)$ is defined by $N(p,q) = \sum_{n=0}^q T_n*p^n$with $T_n$ generated by the following random number generator: \begin{eqnarray}&amp;&amp;S_0 = 290797\\&amp;&amp;S_{n+1} = S_n^2 mod 50515093\\&amp;&amp;T_n = S_n mod p\\\end{eqnarray} Let $Nfac(p,q)$ be the factorial of $N(p,q)$.Let $NF(p,q)$ be the number of factors $p$ in $Nfac(p,q)$. You are given that $NF(3,10000) mod 3^{20}=624955285$. Find $NF(61,10^7)$ mod $61^{10}$ 题意题意说的有点麻烦，我简化一下 $T_i$是随机生成的数据，$N(p,q)=\sum_{n=0}^q T_n*p^n$ 问你$N(p,q)$的阶乘里面，质因数分解以后$p$的指数膜$p^{10}$答案是多少． 分析首先可以观察到的是，$T_i$很小，而且他是随机的，我们显然要把他存起来． 然后一个比较显然的结论是$$n!质因数分解后素因子p的数量为\lfloor \frac{n}{p} \rfloor + \lfloor \frac{n}{p^2} \rfloor + \cdots$$$$\because 最后的答案要膜 p^{10} \therefore 我们统计的时候，对于第一项，我们统计指数为 [1,10]的，第二项[2,11],然后枚举项统计答案即可$$ 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+1;const int pow_num = 10;long long T[maxm+100];const int p = 61;long long powp[1000];void init()&#123; powp[0] = 1; for(int i = 1;i&lt;=pow_num;i++) powp[i] = powp[i-1]*p; long long s0 = 290797; for(int i = 1;i&lt;maxm;i++) T[i] = (s0=s0*s0%50515093)%p;&#125;int main()&#123; init(); long long ans = 0; const long long mod = powp[pow_num]; for(int i = 1;i&lt;maxm;i++) for(int j = i;j&lt;=i+pow_num-1;j++) ans = (ans+(T[j]*powp[j-i]%mod))%mod; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 303 Multiples with small digits]]></title>
    <url>%2F2018%2F12%2F08%2FPE303%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For a positive integer $n$, define $f(n)$ as the least positive multiple of $n$ that, written in base $10$, uses only digits $≤ 2$. Thus $f(2)=2, f(3)=12, f(7)=21, f(42)=210, f(89)=1121222$. Also,$ \sum_{n=1}^{100} \frac{f(n)}{n} = 11363107 $ Find $ \sum_{n=1}^{10000} \frac{f(n)}{n}. $ 题意问你对于每个数字来说，找到他的一个最小整数倍，使得最小整数倍在十进制下每位都小于3 分析很显然，考的是搜索，如何高效搜索． 最简单的想法就是枚举倍数，然后逐个判断是否合法，然后你会发现所有$999$的倍数都Ｔ飞了 然后考虑剪枝，因为可以显然得到，有些倍数一定无效，比如： $5来说，5\ast 1 = 5,5\ast 11 = 55,5\ast 21 = 105 \dots$ 可以显然发现，对于$5$来说，以$1$结尾的倍数显然都不合理，因为他们的最后一位一定是$5$，可以直接判断掉． 然后你就就基本可以过掉大部分数据，但是还是有一个比较头疼，那就是$9999$. 因为他对应的答案贼大，暴力搜索基本都GG．然后我们换一个思路． 那就是我们直接暴力枚举所有的那些看起来长的像$3$进制的十进制数． 然后我们就直接存储所有的这样的数字，然后枚举？ 那么显然内存不够，那怎么办呢？ dfs? 还是Ｔ飞，所以我们还要在此基础上剪枝． 首先我们可以构造出一种做法就是，每次搜索的时候得到的都是之前没出现过的最小的这类数字． 然后我们维护一个mod数组，表示当前这个mod正确的情况下，最小的这类数字是多少 然后答案显然就是mod[0]啦……. 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define ll unsigned long longusing namespace std;ll vis[10000+100];ll cal(int a)&#123; queue&lt;ll&gt; que; que.push(1),que.push(2); memset(vis,0,sizeof vis); vis[1] = 1; vis[2] = 2; while(true)&#123; ll now = que.front(); que.pop(); if(now%a==0) return now/a; for(int i = 0;i&lt;3;i++)&#123; ll buf = now*10+i; ll buff = buf%a; if(vis[buff]) continue; vis[buff] = buf; que.push(buf); &#125; &#125;&#125;int main()&#123; ll ans = 0; for(int i = 1;i&lt;=10000;i++) ans+=cal(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>PE</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mathematical formula(Irregular updates)]]></title>
    <url>%2F2018%2F12%2F07%2FMathematical_Formula%2F</url>
    <content type="text"><![CDATA[二元运算符 符号 功能 代码 符号 功能 代码 符号 功能 代码 $+$ 加 + $-$ 减 - $\triangleleft$ \triangleleft $\pm$ 加减 \pm $\mp$ 减加 \mp $\triangleright$ \triangleright $\times$ 乘 \times $\setminus$ 差集 \setminus $\star$ ５星乘 \star $\cup$ 并 \cup $\cap$ 交 \cap $\ast$ ６星乘 \ast $\sqcup$ \sqcup $\sqcap$ \sqcap $\circ$ \circ $\vee$ 合取 \vee $\wedge$ 析取 \wedge $\bullet$ \bullet $\oplus$ 异或 \oplus $\ominus$ \ominus $\diamond$ \diamond $\odot$ \odot $\oslash$ \oslash $\uplus$ \uplus $\otimes$ \otimes $\bigcirc$ \bigcirc $\amalg$ \amalg $\bigtriangleup$ \bigtriangleup $\bigtriangledown$ \bigtriangledown $\dagger$ \dagger $\lhd$ \lhd $\rhd$ \rhd $\ddagger$ \ddagger $\unlhd$ \unlhd $\unrhd$ \unrhd $\wr$ \wr 二元关系符 符号 功能 代码 符号 功能 代码 符号 功能 代码 $&lt;$ 小于 &lt; $&gt;$ 大于 &gt; $=$ 等于 = $\leq$ 小于等于 \leq $\geq$ 大于等于 \geq $\equiv$ 同余 \equiv $\ll$ 远小于 \ll $\gg$ 远大于 \gg $\doteq$ 约等于 \doteq $\prec$ \prec $\succ$ \succ $\sim$ \sim $\preceq$ \preceq $\succeq$ \succeq $\simeq$ \simeq $\subset$ 子集 \subset $\supset$ 父集 \supset $\approx$ \approx $\subseteq$ \subseteq $\supseteq$ \supseteq $\cong$ \cong $\sqsubset$ \sqsubset $\sqsupset$ \sqsupset $\Join$ \Join $\sqsubseteq$ \sqsubseteq $\sqsupseteq$ \sqsupseteq $\bowtie$ \bowtie $\in$ 属于 \in $\ni$ 被属于 \ni $\propto$ \propto $\vdash$ 蕴涵 \vdash $\dashv$ 被蕴涵 \dashv $\models$ \models $\mid$ 整除 \mid $\parallel$ 平行 \parallel $\perp$ \perp $\smile$ \smile $\frown$ \frown $\asymp$ \asymp $:$ ： $\notin$ 不属于 \notin $\neq$ 不等于 \neq]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UPCOJ 9805 Network Reliability]]></title>
    <url>%2F2018%2F12%2F03%2FUPCOJ9805%2F</url>
    <content type="text"><![CDATA[题目描述An undirected graph is given. Each edge of the graph disappears with a constant probability. Calculate the probability with which the remained graph is connected. 输入The first line contains three integers N (1≤N≤14), M (0≤M≤100) and P (0≤P≤100), separated by a single space. N is the number of the vertices and M is the number of the edges. P is the probability represented by a percentage. The following M lines describe the edges. Each line contains two integers $ v_i $ and $ u_i $ (1≤$ u_i $ ,$ v_i $≤N). ($ u_i $ ,$ v_i $) indicates the edge that connects the two vertices $ u_i $ and$ v_i $. 输出Output a line containing the probability with which the remained graph is connected. Your program may output an arbitrary number of digits after the decimal point. However, the absolute error should be $10^{−9}$ or less. 样例输入3 3 50 1 2 2 3 3 1 样例输出0.500000000000 题意zuhiul 和不超过14 个妹子存在着不清不楚的关系，但是他发现，有些妹子们相互之间是闺蜜，所以这些是闺蜜的妹子们有 $P$ 的概率会发现对面和zuhiul有关系从而导致关系破裂，现在问你多大的概率下，大家相安无事(妹子们还是一个联通图)． 分析数据量这么小，显然状压呀． 所以我们定义 $DP[i] 表示 state==i 时，i 包含的点相互联通的概率$ 那么比较容易得到答案就是 $ DP[(1&lt;&lt;n)-1] $ 现在我们考虑转移： ​ 因为要保证state内任意两点可达，所以我们不妨枚举出所有不可达的情况，容斥一下就行了． ​ 所以每次对于一个state，我们可以枚举他的每个点的子集，然后对于其他点到这个集合都割掉就行了 ​ 你问我为什么不会重复和遗漏？ ​ 这就要用到神奇的构造了． ​ 首先我们保证每个正确的点的子集里面都包含某一个点，那么对于包含这个点的所有正确子集来说肯定各不相同，这个保证了不会重复 ​ 然后怎么证明没有遗漏呢？ ​ 因为对于任何一个点来说，他都属于某一个联通块，我们实际上是在枚举每一个联通块，所以不会遗漏呀． ​ 恩，大概就是这样，详情请看代码． ​ 最后说一下复杂度． ​ 应该是 $O(\sum_{i = 1}^{n} C_n^i * 2^i) = O(3^n)$ 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;double p;double pow_p[100];int pow_2[100];int mat[100][100];void init()&#123; scanf("%d%d%lf",&amp;n,&amp;m,&amp;p); p/=100; pow_2[0] = 1; pow_p[0] = 1; for(int i = 1;i&lt;100;i++) pow_p[i] = pow_p[i-1]*p,pow_2[i] = pow_2[i-1]&lt;&lt;1; for(int i = 1,from,to;i&lt;=m;i++) &#123; scanf("%d%d",&amp;from,&amp;to); mat[--from][--to]++; mat[to][from]++; &#125;&#125;const int maxm = 1&lt;&lt;15;double dp[maxm];int has[100];int sub[100];void get(int state)&#123; dp[state] = 1; has[0] = 0; for(int i = 0;i&lt;n;i++) if(state&amp;(1&lt;&lt;i)) has[++has[0]] = i; if(has[0]==1) return ; for(int now = state&amp;(state-1);now;now = (now-1)&amp;state)&#123; if((now&amp;(1&lt;&lt;has[1]))==0) continue; sub[0] = 0; for(int i = 1;i&lt;=has[0];i++) if(now&amp;(1&lt;&lt;has[i])) sub[++sub[0]] = has[i]; int cnt = 0; for(int i = 1;i&lt;=has[0];i++) for(int j = 1;j&lt;=sub[0];j++)&#123; if(now&amp;(1&lt;&lt;has[i])) continue; cnt+=mat[has[i]][sub[j]]; &#125; dp[state]-=dp[now]*pow_p[cnt]; &#125;&#125;int main()&#123; init(); const int nouse = pow_2[n]; for(int i = 1;i&lt;nouse;i++)&#123; get(i); &#125; printf("%.10f\n",dp[nouse-1]); return 0;&#125;]]></content>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UPCOJ 9999 Cube]]></title>
    <url>%2F2018%2F12%2F03%2FUPCOJ9999%2F</url>
    <content type="text"><![CDATA[题目描述给你一个 $ n\ast m $ 的棋盘，有一个 $ 1\ast 1\ast 2 $ 的长方体竖直放在 (1,1)上，你可以将其在棋盘上滚动，你的目标是让其竖直放在 ( n , m ) 上，问至少需要多少次操作。(放倒、竖直、翻滚) 输入一行，两个整数n，m (n&lt;=m) 输出需要最少时间能从(1,1)到达(n,m)，如果无解输出 $ impossible $ . 样例输入1 1 样例输出0 提示 分析这个题目我的做法其实比较暴力，因为和队友赌能不能1Y ，我甚至怂到写暴力对拍了．．．． 闲话少说，下面看分析． 其实还是比较好想的． 首先我们考虑哪种情况是 impossible ．比较好观察的是，当ｎ和ｍ足够大的时候就一定可达 所以我们只用找到一个ｎ和ｍ可达的下界就行了 然后就可以发现只有当ｎ和ｍ都小于３的时候会有impossible的情况(因为转不动．．．． 接下来分析其他情况，首先比较好分析的是，如果n%3==1&amp;&amp;m%3==1的话，答案可以显然得到是 (n/3+m/3)\ast 2 剩下的同理搞搞就行了，大体情况见下表． 比较显然的是，加的那一项和n,m％3为2的数量一致，然后就是代码啦．．． 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std; int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; if(n&lt;=2)&#123; if(m%3==1) cout&lt;&lt;m/3*2+n-1&lt;&lt;endl; else cout&lt;&lt;"impossible"&lt;&lt;endl; &#125;else if(n==3&amp;&amp;m==3) cout&lt;&lt;8&lt;&lt;endl; else if(n==3)&#123; if(m%3==0) cout&lt;&lt;m/3*2+4&lt;&lt;endl; else if(m%3==1) cout&lt;&lt;(m+2)/3*2&lt;&lt;endl; else cout&lt;&lt;m/3*2+5&lt;&lt;endl; &#125;else &#123; int ans = (n/3+m/3)*2; ans+=(m%3==2)+(n%3==2); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3829 FarmCraft]]></title>
    <url>%2F2018%2F12%2F02%2FBZOJ3829%2F</url>
    <content type="text"><![CDATA[题目描述In a village called Byteville, there are houses connected with N-1 roads. For each pair of houses, there is a unique way to get from one to another. The houses are numbered from 1 to . The house no. 1 belongs to the village administrator Byteasar. As part of enabling modern technologies for rural areas framework, computers have been delivered to Byteasar’s house. Every house is to be supplied with a computer, and it is Byteasar’s task to distribute them. The citizens of Byteville have already agreed to play the most recent version of FarmCraft (the game) as soon as they have their computers. Byteasar has loaded all the computers on his pickup truck and is about to set out to deliver the goods. He has just the right amount of gasoline to drive each road twice. In each house, Byteasar leaves one computer, and immediately continues on his route. In each house, as soon as house dwellers get their computer, they turn it on and install FarmCraft. The time it takes to install and set up the game very much depends on one’s tech savviness, which is fortunately known for each household. After he delivers all the computers, Byteasar will come back to his house and install the game on his computer. The travel time along each road linking two houses is exactly 1 minute, and (due to citizens’ eagerness to play) the time to unload a computer is negligible. Help Byteasar in determining a delivery order that allows all Byteville’s citizens (including Byteasar) to start playing together as soon as possible. In other words, find an order that minimizes the time when everyone has FarmCraft installed. 输入The first line of the standard input contains a single integer N(2&lt;=N&lt;=5 00 000) that gives the number of houses in Byteville. The second line contains N integers C1,C2…Cn(1&lt;=Ci&lt;=10^9), separated by single spaces; Ci is the installation time (in minutes) for the dwellers of house no. i. The next N-1 lines specify the roads linking the houses. Each such line contains two positive integers a and b(1&lt;=a&lt;b&lt;=N) , separated by a single space. These indicate that there is a direct road between the houses no. a and b. 输出The first and only line of the standard output should contain a single integer: the (minimum) number of minutes after which all citizens will be able to play FarmCraft together. 样例输入6 1 8 9 6 3 2 1 3 2 3 3 4 4 5 4 6 样例输出11 HitsExplanation: Byteasar should deliver the computers to the houses in the following order: 3, 2, 4, 5, 6, and 1. The game will be installed after 11, 10, 10, 10, 8, and 9 minutes respectively, in the house number order. Thus everyone can play after 11 minutes. If Byteasar delivered the game in the following order: 3, 4, 5, 6, 2, and 1, then the game would be installed after: 11, 16, 10, 8, 6, and 7 minutes respectively. Hence, everyone could play only after 16 minutes. 题意zuhiul是镇长，住在1号房子，镇里的房子构成了一颗树，现在zuhiul要给镇里其他房子里的小姐姐送电脑，每经过一条路径，zuhiul都要花掉一分钟(才不是为了看小姐姐)。但是zuhiul只负责送不负责装，每个小姐姐的脑子都比较奇怪，有些装的快，有些装的慢，最后zuhiul会返回自己的家给自己装电脑，然后他就可以和小姐姐视频了，但是必须要等所有的小姐姐都装好了才行，现在问你zuhiul最早什么时候可以和所有的小姐姐视频。 分析显然是树上DP，我们考虑定义DP状态，则有 f[i]表示以 i 为根的子树里，花费总时间的最大值是多少 我们定义son_num表示这个节点对应子树的节点数量 然后我们考虑转移，我们首先考虑怎么搞两个子节点的时候，然后进行推广。 不妨假设这两个字节点分别是a和b，然后可以得到先遍历a再遍历b的最大时长为 max(f[a]+1,f[b]+son_num[a]*2+1) 同理，先遍历b的最大时常为max(f[b]+1,f[a]+son_num[b]*2+1) 所以如果有max(f[a]+1,f[b]+son_num[a]2+1)&lt;max(f[b]+1,f[a]+son_num[b]2+1) 因为f[a]+son_num[b]2+1&gt;f[a]+1并且f[b]+son_num[a]2+1&gt;f[b]+1 所以只需要得到 f[b]+son_num[a]2&lt;f[a]+son_num[b]2 也即 f[b]-son_num[b]2&lt;f[a]-son_num[a]2 同样，对于多个节点来说，我们同样只要对每个子节点按照 f[son]-son_num[son]*2降序排序，然后从前往后贪心选就行了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 7e5+10;struct p&#123; long long t,son_num;&#125; peo[maxm];long long len;vector&lt;int&gt;mat[maxm];long long f[maxm];int ind[maxm];bool cmp(int a,int b)&#123; return f[a]-peo[a].son_num*2&gt;f[b]-peo[b].son_num*2;&#125;void dfs(int a,int pre)&#123; peo[a].son_num = 1; if(a!=1) f[a] = peo[a].t; for(int i:mat[a])&#123; if(i==pre) continue; dfs(i,a); &#125; ind[0] = 0; for(int i:mat[a])&#123; if(i==pre) continue; ind[++ind[0]] = i; peo[a].son_num+=peo[i].son_num; &#125; sort(ind+1,ind+ind[0]+1,cmp); long long now = 0; for(int i = 1;i&amp;lt;=ind[0];i++)&#123; f[a] = max(f[a],f[ind[i]]+now+1); now+=peo[ind[i]].son_num*2; &#125;&#125;void solve()&#123; printf("%lld\n",max(f[1],len*2-2+peo[1].t));&#125;int main()&#123; scanf("%lld",&amp;len); for(int i = 1;i&amp;lt;=len;i++) scanf("%lld",&amp;peo[i].t); for(int i = 1,a,b;i&amp;lt;len;i++) &#123; scanf("%d%d",&amp;a,&amp;b); mat[a].push_back(b); mat[b].push_back(a); &#125; dfs(1,0); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
</search>
