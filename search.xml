<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[就怕我感动了自己，却没有感动你]]></title>
    <url>%2F2019%2F12%2F23%2Fstory%2F</url>
    <content type="text"><![CDATA[我爱你，像蚁溃洪堤，一泻千里。 2019052019050120190501 09:00 AM update今天开始我想记录下和她的所有故事。 20190501 06:15 PM update今天终于见到了心仪的小姐姐了，然后在天津逛了一大圈，刚下高铁，吃了个饭，然后逛了会街，然后就去听相声，然后逛了逛他们学校，在图书馆坐了一会就这样，哈哈哈哈哈哈哈，巨开心 20190501 11:52 PM update下午的时候和她一起去吃了个饭。然后我回宾馆把东西放下后就拉着她各种溜达，但是感觉她兴致不高。可能是她要考研的缘故。确实，感觉拉着一个想考研的人也挺罪恶的。但是我是真的很开心，哇，真的是只要想到和她一起，真的是压马路都巨开心^_^ 2019050220190502 00:31 AM update君子爱玉如将帅熬鹰，我不急，对你我有无限的耐心。 20190502 09:56 AM update看来你昨天是真的累了，以至于你现在才醒，我倒是挺担心的，7点半就醒了，然后给你发消息没回，就知道你是累着了。哎，心疼。准备去找你的，被你拒绝了。非说你来找我，也行吧。 有时候我还挺惶恐的，万一就是南柯一梦就尴尬了，不过我现在是真的开心呀呀呀呀呀呀。 20190502 11:26 PM update晚上约你吃晚饭，然后顺其自然的表白了？说实话是准备留到明天说的，但是一不小心漏嘴了，天真以为会挺顺利的。自认为还是不错的？但是好像有点出乎意料？巨难受？ 2019050320190503 00:42 AM update还是没想明白到底是哪个环节出问题了？而且我都明说了不逼你？我可以等234天啊啊啊啊啊啊啊啊啊啊，难受！ 20190503 10:04 AM update混进了你们学校，然后又混进了你们图书馆，哈哈哈哈，当时门卫看了我一眼我都有一种做贼的感觉，真刺激。坐在图书馆写下这一段文字，还是略难受？反正还没缓过来？其实吧，你之前拒绝我的时候我都安慰自己，我还不够优秀啊，我要更优秀一点，所以我之前一直很怂啊，这段时间才敢和你说话，但是好像啊，你还是这样啊，说明啊，我还得努力啊，冲鸭。 20190503 10:26 AM update还记得昨天去失恋博物展，记得当时我两感受都相同，别人的故事始终是别人的故事，打动不了自己，现在想来就是这种感受，一直都是我的一厢情愿，还奢望你的回应，说到底还是自己感动了自己，却没有感动你。 20190503 06:52 PM update你去上厕所去了，我偷偷码一点。 每每想到你连一点妄想都不给我就巨难受，看着你画了一下午的画，你认真画画的样子真的很美。但是我还是不知道你到底是啥意思，还是单纯的难过。 20190503 09:08 PM update09:05开的高铁，我们8:55还没看到车站，我估计是赶不上了，当时我们两一起在大马路上跑，我真的有一种私奔的感觉。当时过安检的时候，我真的好难受，感觉自己像失去了你一样，但是都没有得到过何谈失去呢？ 我当时就想啊，如果我还能赶上车，那就是老天真的不帮我了，如果赶不上我就赖上你了，但是好死不活晚点了？真的是气哭了。看来还是我心急了，贼老天都不帮我了，所以爱情这东西啊，还得时间沉淀，所以啊，我不急啊，所以啊，我可以等啊，所以啊，我唯一怕的就是你不见了啊。 就这样吧，再见了。 2019050420190504 00:54 AM update估计你睡了，写好的东西最后还是发给你了，也不管你看不看了，反正肺腑之言，不吐不快。 果然你没睡着，和你说了两句，看你没兴趣我就溜了。 20190504 1:37 AM update看了你是真的了，今天就不等了，毕竟我又不是你的谁，劳累你三天了，本来就挺过意不去的，就这样也好，是你说的，好歹还能保存美好的回忆不是？ 让你填志愿和考完研和我说一声，不知道你会不会说，232天，会有多少变数呢？谁都不知道，我现在唯一能做的就是更努力吧。 20190504 01:00 PM update队友看我实在是太难受了，拉着我去打球了，打了一个小时，我实在是不想动了。就拉着他回公司了，码下这一段了，你猜我想开需要多久？估计你不敢和我打赌了？ 20190504 05:44 PM update我现在突然挺后悔当时没有定三晚上酒店，那样的话，我们至少还能多待一起一天不是吗？虽然可能没那么开心，但是至少还能看到你不是吗？我现在真的是啥都不想干了。 20190504 10:45 PM update我现在挺想和你打个赌的，你猜232天能否冲淡我对你的想法呢？我赌不会。如果真的淡了，我也不知道该说好还是不好，ok，我现在就数日子等我赢，刚刚给你发了日报，没有别的意思，只是希望你每天能整理整理，希望你好，（可能也有不甘心作祟？），不知道啦，我也很茫然的好伐。 2019050520190505 10:24 AM update劝自己暂时放下，安心搬砖，好好学习。唯一能让我安慰的就是我们组另外一个人表白也被拒绝了，但是我还是很难受，我果然是个loser，连同组的人都和我一样惨，哭了。 20190505 12:13 AM updateemmmm,前几天，天天中午吃饭很早，以至于我现在饿了，但是还有半个小时才吃饭，饿得不行。哇，我还想和你一起吃饭。231天，我要是约饭，你不来，打你呦。 20190505 12:57 AM update刚刚和老大他们聊了一下，他们的意思都是劝我放弃，说我还年轻，不值得，同样的人还会遇到很多，但是我目前还不这样想，有时间确实需要好好整理一下，并不知道自己到底想要的是什么，这不像我，我一直以为自己想要的东西很明确，但是这件事上，确实还有疑惑的地方。让我想到了以前看到的一句话： “无论是朋友，工作还是恋爱，如果你感到与对方特别契合，沟通愉悦甚至时时让你灵光乍现，你知道这说明什么吗？99%的可能是你遇到了阅历智商情商都在你之上的人，而且对方因为什么目的在向下兼容而已，只要TA愿意，TA可以和每个跟你一样级别的人，打到这种心有灵犀，剩下的1%就是你遇到了SOULMATE。” 我并不知道我遇到的到底是什么，按照你前几天的意思是：我对你了解太多了，所以你的意思是我是你的99%？可能吧，可能只有我觉得我们是那1%，我一直以为我们不需要言语的交流是默契，现在看来可能不是？可能只是大家见的多了，就明白了，懂得察言观色？我并不知道，但是我很习惯这种感觉。 他们都说，人这个东西啊，很奇怪，可能你现在看到的人，喜欢的人，愿意放弃一切为了的人，可能过几年再看就不过如此了。我不知道，但是我现在确实很放不下。我一直觉得，这种人，可能十年都遇不到一个，放弃太难了。我想过几次，到底是为啥，你会拒绝，我暂时的理解是，我还不够优秀，所以我还要努力。他们说，等你变的优秀了，你就会明白，什么才是你想要的人。说真的，我不懂，不知道谁说的是对的。所以我选择让时间筛选，没有什么是时间搞不定的。231天后，一切都会有答案，如果你真的讨厌我，我就离开了，就当做是一场年少无知的梦。 20190505 04:47 PM update他们说让我忙起来，忙起来就不会想你了，但是我现在好闲啊，也不想忙起来，今天有比赛，但是已经没心情打了，怪只怪自己太年轻了，以前居然会觉得比赛比你有意思。老大说，错过了就是错过了，有些时候不能强求，我不知道，不知道该怎么做，不敢强求。 20190505 09:36 PM update开发的东西很快就做完了，所以今天一直很闲，然后复习的事也就随便搞了搞，反正也不怎么想搞学习了，然后和队友商量了一下考研的事，他们建议不要冲动读医，说是时间可能耽误不起，不太清楚，感觉涉及到他们的利益问题了，所以谁都说不清楚。然后下午到现在都在杂七杂八的看，配了配博客，看了看latex，看了看vim，学了学haskell，反而是感觉啥都没干，其实我还挺怕这种感觉的，挺怕时间真的将我们冲淡了，很奇怪的是，我今天很平静，异常平静，没有难受也没有开心，我不知道这是不是变淡的原因，反正时间真的在一点点冲淡吧，然后后天有考试，索性把明天的假也给请了，明天好好休息一下，有些东西也确实需要理一理。 emmmm，但是说自己对医学感兴趣是骗你的，是因为我对你感兴趣罢了，但是我确实是真的耐着性子读了一半的卫生统计学，无论是简单还是难，我都耐着性子读了。在你拒绝我两次之后，那本书就放在角落接灰了。确实提不起兴趣读下去。偶尔想想自己目的性其实也很强的，emmmm，可能是功利性很强，没有用的事情就不做了。暂时还不清楚，可能等着这三周考完试之后会重新捡起来接着读？然后整理整理笔记？然后假装很早之前整理的，然后发给你？然后试图感动你？呵呵，渣男！反正现在暂时是这么想的吧。妈呀，从来没想过为了哄一个女孩子开心，我居然这么有心机，太恐怖了。 哎，反正这两天想的挺多的，暂时也不知道自己在想啥，很多时候都是没想明白搞得错，反正以后三思而行吧，也不敢太打扰你了，日报今天还是决定接着发，发21天就溜了，能对你造成多少好的坏的影响我也不知道，我也不敢说这一套在你这是否是对的，只求心安罢了。 2019050620190506 10:44 AM update今天虽然请假了，还是来公司玩了会，刚喝了口水，现在开始码这段文字。 这几天睡眠质量特别不好，应该是从5.1晚上开始的，可能是担心你身体状态，我应该和你说过，当时第二天我六点就行了，怎么也睡不着，也不敢给你发消息，怕你还在休息，我以为只是这个原因，现在看来不是，已经三天没见你了，但是还是基本六点多就醒了，然后也不怎么睡得着，因为队友还在睡觉也不敢起床，偶尔躺在床上会背背单词，偶尔也会想想你，偶尔也不知道自己在干啥。 五点钟的票回学校，暂时还没定下来啥时候走，我应该和你说过，我不想赶路，所以一般会有预留，地铁大概是一个小时，所以我打算提前两个小时走，就算走错了，好歹还有挽回的余地。 哎，其实一个人赶路还挺无聊的，还是两个人在一起比较好玩，旅途寂寞鸭。昨天给你发日报了，你还是没回我，可能是把我拉黑了？不知道，没有别的意思，只是想让你养成一个（我也不知道是好是坏的）习惯罢了。别太敏感啊。 20190506 03:53 PM update现在闲下来了，就等高铁了，然后就想了想之前几天发生的事，其实我还是觉得挺玄学的，首先就是失恋博物展的那个球，说好都是脱单呢，怎么就咱两是单身了，不过说的也对，12.23才考完研，今年是不指望脱单了。 还有就是单车那个事，都10点四十了，还有四十分钟的路程，显然是赶不回去的啊，怎们回事啊，居然还能遇到各种单车，还有就是我为啥骑车那么慢，你真的不知道？怎么可能是因为累了，还不是不像你回学校吗。这样好歹有一晚上的时间，哪怕是纯聊聊天也行啊，你咋回事啊，看不出来？哇，就两三分钟就进不去了，你可真的赶啊，话说我还真不知道你是不懂还是装不懂，可能二者兼有，不清楚啊。但是我宁愿是前者吧。 230天，我离你又进了一步，但是你退后了多少呢？ 20190506 10:05 PM update马上就要到学校了，想到了当时去你们学校的时候，当时在你们图书馆歇息的时候，你应该是真的困了，都怪我当时不知道关心，让你受累了。现在想想当时怎么着也得让你休息休息啊。真的是迂腐之极。哇，不行了，想起的细节越多，越觉得自己是真的蠢。 今天一天都在赶路，所以整个人的状态不是很好。而且也不太喜欢这种放松的感觉，但是还是不想学习。话说现在心态真的是变了好多了，今天我队友还在劝我放弃，我不知道，可能还是当局者迷的缘故，但是还是没和你说，今天还是照旧把日报发给你了，今天是第三天，还剩18天，然后就应该不会给你发消息了，让你安心考研了，考完研有的是时间不是吗？ 2019050720190507 10:35 AM update229天了，今天突然有一种报复心理，我一定要让你后悔。 突然想到当时和你一起听相声的时候那个哥说了一句“我对于这种人，没有羡慕没有嫉妒，只有恨”，哈哈哈，说实话，这就是传说中的由爱生恨吗？反正我现在挺难受的，突然也想让你难受一下，哈哈哈，开个玩笑。 最后悔莫过于因为年少无能而放下。我拼命成长不过是为了你回眸一笑。他们说等你以后长大了会遇到不一样的人，不一样的景，而我只想记住每一个不一样的你。 2019050820190508 10:38 AM update228天。 昨天晚上的时候，你终于是回复我了，说是怕我考试有影响，这件事怎么说呢，你要是早点回复我的话，我可能还会开心一点。但是还是挺开心的，好歹回复我了。 昨天晚上聊了一下，应该再不会打扰你了，然后以后真有啥想说的，就更新到这里了，确实不该打扰你的，扰菇凉良久，菇凉莫怪啊。 昨天你和我说，哎，算了不评价，怎么说呢，大家都在慢慢成长吧。 不过有句话你说的还是挺对的，等待会让东西变质，或许应该换句话说：时间会让东西变质。没有什么可以敌得过时间。我深知我也不行，但是我觉得200+天还是不难的吧。 还有就是你说的对，拒绝就应该拒绝到底，你做的很好，但是我还是很难过，毕竟当一个人真正拒绝你的帮助的时候就是真的想和你断了吧。至少没有钓着你的心思，或许我应该开心？ 后来仔细思考了这段时间的经历，感觉确实有些自作多情了，很多时候都是自己一厢情愿罢了。 emmmm，大概就是这样了，可能真的是告一段落了，也不会找你聊天了，大家都松口气，如果真的是有缘，再见吧。 当我码下这段文字，无悲无喜，甚至有一种完成任务的感觉，轻松？算不上吧。只是觉得暂时放下了一些东西，可以安心前行了。 可能也和我老大说的对，他说我纯粹是大学时候没干什么，然后大学快结束了想干点什么，我不知道，当然也可能是自己飘了，觉得世界尽在掌握中，所以开始有恃无恐了。还好，你让我明白，自己还有很多的努力方向，还是不够优秀啊。所以继续努力吧。 现在也不敢随便立flag了，但是还是想说一下，如果你真的准备二战的话，我就准备考研了，和你一起，哪怕你不理我，我也要强求一把。当然如果你真的考上了的话，我也要准备跳槽了，反正能近一点就近一点吧。真的是怕了。 20190508 12:55 PM update刚刚吃饭聊了一下，反正我感觉我还好啊，没有你说的那种腼腆的感觉，可能很多时候在想事情所以没怎么说话，或者说是很多话不太好意思说，或者是感觉说出来不好，可能你觉得我在欲言又止？或者说是“腼腆”。不太清楚，哇，第一天我可是嗓子都说哑了，你居然会觉得我腼腆。不过说真的，刚见到你的一瞬间真的是有好多话想说但是真的是，虽有千万肺腑之言，却又无语凌噎。emmmm，刚见到你的时候是在瓷房子门口，当时还挺想抱你一下的，但是当时咱们前面有一个围栏，不知道你注意了没有，然后就放弃了。哎，还是太怂了。 昨天你给我发消息之后真的是好晚才睡着，本来12点钟就放下手机啦，硬是拉着舍友聊天，聊我和你，硬拉这聊到了一点半。哎，回想这几天发生的事，还是有些地方没有做好。还是有很多事挺后悔的，用我队友的话来说就是我太怂了。很多时候都过于胆怯。 我脑子里突然蹦出一个词来——自卑，其实仔细回想一下，很多时候我大概都是自卑心作祟。你也说了，你觉得我很优秀，其实我一直不这么觉得，反正每次觉得自己还行的时候总能遇到一些吊人，然后看看他们的经历，然后就觉得自己还有很多地方需要努力。 还有就是你觉得我把你美化了，这个不好评价，自古有云：情人眼里出西施。我不知道是不是因为某些奇奇怪怪的原因导致的。所以暂不做评价。但是真的是觉得你是个挺好的菇凉啊，一直觉得你值得世间上最美好的东西。有时候，看着你皱眉头真的是还略有难受？反正感觉你要是真能无忧无虑的生活还是挺好的。这段时间你应该是为我烦了，我也就暂时不打扰你了，等你安心考完研吧。反正这个事不急，咱们还年轻，有大把时间可以挥霍。哈哈哈哈哈。 还有就是这段时间准备开始锻炼了，主要是当时第一天我们都走累了，我想了一下，要不要公主抱你，后来估计了一下自己的身体状态，还是觉得太虚了，所以这段时间准备好好锻炼一下。还有就是学习的事，这段时间我考试实在是太多了，工作时间也压得很紧，所以暂时不考虑接着读卫统了，先把考试糊弄过去再说，之前看过的一半也没有整理笔记，题目也是杂七杂八做了，没有系统的整理，还是准备从头开始读，然后顺便整理整理笔记，题目也暂时不做了。先读完再说。感觉东西不是很难，所以希望你不要着急，慢慢复习就行。现在时间虽说不多了，但是也不用太着急，估计你这几天都没有在12点之前睡过觉，还是要早些歇息为好。 对了，你画的那幅画，我暂时还没有挂起来，因为房间里的那幅画是竖的，你画的是横的，不太好弄，所以准备抽时间去买个钉子，重新钉一下，然后再挂起来，不过你也别担心会弄坏了，我保存的老好了。偶尔学习累了会看看那幅画，你画的真好看，当然，你也好看。 还有就是那天我真的没有占你便宜啊，我说的都是心里话，你不是也没反驳吗？我就当你默许了。反正等你考完研我就非要缠着你，和你一起准备复试。至于我考研？暂时还没定，等省赛结束之后再说吧。看省赛情况，其实吧，我还挺想省赛打的不太好的，这样就能安心学习了。感觉比赛真的已经没有了当年的激情了。 还有就是舍友昨天晚上和我聊了关于感情会随着时间的延长而降低。他说如果你真是我对象，可能两个月我就没有了现在的感觉了。我不知道，但是你看你，就做的很好啊，直接拒绝了我，让我有时间去思考和解释这件事，等我想的差不多了，咱们就在一起了？ 说到底还是得抽时间想一想这件事，下周就省赛了，省赛结束应该会有时间思考这个问题，就这样。 20190508 06:22 PM update今天活干完了，现在算是比较闲了，不知道干啥了。 所以就过来bb两句。这两天的状态不是很好，一部分是舟车劳顿的缘故，另外一部分原因就是突然有了迷茫的感觉：突然不知道了自己真正想要的是什么。是工作？是考研？是恋爱？我不知道，一直以来都很讨厌这种感觉，不知道自己想要什么可能是一种病态的迷茫，也很容易变成空洞的人。其实我还挺羡慕你的目的性的，能知道自己想要什么真的是一种很好的状态。它会至少让你有个目标，然后剩下要做的就很简单了，细化目标，完成目标。 好像说这些在这里不合适，说一点和你有关的。 你说我很多时候能一眼看穿你，emmm，这件事怎么说呢，我的解释是，咱两有天然的默契，这种默契与生俱来，不用培养，不用磨合。我最爱的就是这种状态。我一直以为这种情况是天作之合，很少有人能这样默契吧？这辈子能遇到一个真的很不容易，或许没了这份默契就不那么喜欢你了？我不知道，但是我是真的喜欢这种默契，你也知道，我情商很低，说明咱两都没耍心眼，所以这种与生俱来的默契难道不值得被珍惜吗？反正我是不打算就这么错过了。他们说这种默契，一个人一辈子会遇到很多，我不信，真的不信。反正这一次，我一定要抓住。 20190508 7:24 PM update他们说的其实挺对的，人啊一旦忙起来什么都忘了，所以当时他们劝我忙起来就好了，这几天确实渐渐忙起来了。但是偶尔还是做事做到一半被打断，然后就神游太虚了。。。当然也可能是还不够忙。就是偶尔闲下来连个聊天的人都没有，还是挺难受的，之前还能和你聊聊天，现在都不敢给你发消息了。就这样吧。真有啥想说的，我就写这里了。 其实我一直都没想好 自己到底为啥要写这个东西，或者说写这个东西的目的是什么，虽然不怎么花时间，一天大概也就半小时，但是确实不明白写这个的目的是啥，写给50年后的自己看？那也太矫情了。还是写给228天后的你看？那也太无耻了。暂时没想好，只是单纯的觉得，能遇见你还是一件挺幸运的事，挺值得怀恋和回忆的事，所以就这样记录下来了，就算以后真的不能在一起了，想到以前喜欢过这么可爱一个菇凉，也是一件随时回忆起来都能让人开心的事吧？ 20190508 11:30 PM update还好当时没有公主抱你，突然感觉自己好虚啊，不行了，接下来一段时间准备好好锻炼一下了，等下一次见面给你一个惊喜，到时候抱你没跑。 2019050920190509 09:19 AM update今天早起了，背了会单词，然后就来公司学习了，复习时间就剩下今天和明天了。 早上的时候看到公交车让了一个老人过马路，不禁想起了我从天津回来的时候，当时晚上11点多了，我其实还挺累的，当时我后面是一对夫妻，带着两个孩子，两个孩子都睡着了，当时因为你拒绝我，我真的挺难受的，犹豫了一段时间还是让他们排在我前面，当时我想了好长时间，我都这么惨了，为啥还要对世界抱有善意？再后来，也就是上周考完试了，我回北京的时候，当时我身上还有一点现金，北京地铁现在好像还不让用微信？反正一个人在那干着急，想了想还是帮助了一下。我真的不清楚，为啥自己还要对陌生人抱有善意，真的是，自己过的就已经够惨了。后来想想还是为自己积福吧。所以我就想啊，我都以德报怨了，你总不能拒绝一个商量的小男孩吧。 今天北京天气很好，早上八点钟就已经有了太阳，真的很想出去逛逛，后来想想一个人还是挺无聊的。突然想到了当时给你打伞的日子，哈哈，我记得当时有一段时间，当时人流拥挤，你头都不回就往前冲，哇，当时还是太怂了，当时就应该拉住你，让你等等我的，后来好像因为打伞不及时被你吐槽了？哈哈，感觉你当时委屈的抱怨的时候的样子真的很可爱。哎，当时太直男了。 20190509 07:22 PM update今天和一个考研的神仙聊了一下，他说我不该五一的时候去找你玩的，他说这个时候大家都开始准备考研了，我这样做，非但没有帮你解决问题，反而是抛给你一个问题，让你困惑更多，尤其是我那些若有若无的帮助更是显得愚蠢至极。我其实觉得他说的挺有道理的，我并不知道考研原来压力那么大，我其实一直觉得考研和期末考试没啥区别，看来是我年轻了，很多时候都把事情想简单了，尤其是想得到你的回应这件事上，真的是蠢了。 仔细想了想确实不该这个时候去打扰你的，我还天真以为这对你不会有啥影响，今天才明白过来确实是副作用更大一下。但是我还是希望你压力不要那么大，还是要放轻松一些的，这段时间感觉你睡觉都挺晚的，一点钟还没睡觉，感觉这样还是对身体不太好，建议你每天早睡一点，毕竟晚睡了早上精神会不好，你们又都是需要背书的课，晚睡学习不如早起学习。 其实每天都有好多有意思的事情分享给你，但是实在是不忍心打扰你，很多东西又不太好记在这里，所以很多都写成了日记，等你有机会了，到时候咱两可以一起读读？ 还有就是，我其实不怎么想告诉别人咱两之间的事，没有别的意思，一是咱两毕竟还没成不是，还有就是很多人问起来给我一种听故事的感觉，不像是帮我分析问题的样子，让我有一种”我有这种经历，我是不是很厉害“的炫耀的感觉，这种感觉让我很反感，不知道为啥，这种感觉会让我觉得，这份感情变得不那么纯粹了，就像一个小孩在炫耀自己的经历一样，幼稚而无趣。 20190509 07:57 PM update刚刚吃完饭，突然想到一件事，突然就难过起来了。 就是五一期间的时候我们吃饭都特别早，所以刚回北京的时候我六点钟就饿了，但是这才六天过去了，我的作息又和公司一样了，可能这就是人们常说的时间会磨平一切？慢慢的，你给我造成的影响会渐渐的淡化？真的还是挺难受的，就像你留给我的东西，被别人抢走了一样。偏偏我还不知道能做什么才能留下你留给我的东西。真的很怕，有一天再听到你的名字，没有了现在这种心慌或者说是心动，反倒是无悲也无喜。 2019051020190510 08:45 AM update今天还是这个点起床了，昨天锻炼有点过猛了，现在浑身酸痛。。。。早上六点多醒了一次，一度怀疑自己手断了。现在就像被人揍了一顿一样。。。。 早上刚醒的时候仔细思考了一下，目前知道的人有：我两个现任队友，一个前队友，父母。果然是每个人注意点都是自己的利益问题，现队友给的意见是，别浪费时间，不值得。前队友给的意见比较中肯，让我想好，想好了就别放弃了。父母啥都没说，他们也没说啥，就是怕我想不开。同样的道理，我也听取了对自己有利的方向而忽视了现队友的意见。 还记得我和你说的吗？一旦有些东西涉及到了利益问题，就会少很多人情味，尤其是工作以后，感觉大家看待问题的方向都很不一样了。昨天前队友和我聊了一下，他的意思是，他从来没有为自己而活过，都是按照别人的想法来做事。然后我就发现，我还是挺幸福的，我一直以来都是啥开心做啥，暂时还没人约束过我。以前觉得读书有意思就好好读书，不怎么玩。大学觉得比赛有意思就不怎么学习，学习很差。真的想不到，自己有一天会需要顾及方方面面而变得畏畏缩缩的时候，该是何种可怕模样。 20190510 05:31 PM update突然发现，说我变腼腆了，好像不止你说过，虽然我很不想承认这一点，但是好像很多之前的同学都这么说，让我不得不思考这个问题，可能这几年过的过于漫长了，让我已经不记得我高中时候的样子了。或者说我高中的时候很膨胀？记不清了，可能是自己的感受，自己的成长，自己的变化反而自己不太了解吧。话说我高中的时候确实很膨胀，感觉一切都在自己手中。可能是大学时候认识了太多神仙了，就已经不敢过于高调了，很多时候反而是低调再低调。感觉自己还有很多不会的东西，所以一直在努力学习吧。 还有就是我把你画的画拍成了照片挂在公司内部聊天软件的头像上，他们都说挺好看的，那是，不看是谁画的。。。。其实准备换成qq或者微信头像的，想想还是算了，你能看到，不想影响你的心绪了。给你时间吧。 还有关于你说我说话风格很像山东人，这件事怎么说呢，感觉与其说是山东对我的影响很大，不如说是山东学长对我的影响很大，因为很多时候都是待在实验室，待在实验室的时间应该不少于在宿舍的时间，这还是算上睡觉的时间的情况下，所以我说话的风格应该是更偏向于实验室学长的风格。至于这点滴的潜移默化的变化，我还真感觉不出来。反正感觉自己一直都是这样。 20190510 10:02 PM update明天就溜了，要回学校打省赛了，希望好运吧，还记得去年的时候省赛冠军，当时老膨胀了，总感觉世界在我手上，没有我搞不定的事，后来就慢慢放弃了这个无知的想法。突然想到了我之前和老大说的一句话，有异曲同工之妙–”世间上任何问题都可以转化成数学问题”。直到你拒绝了我好多次，我才渐渐明白过来，很多东西并不是那么简单的问题，不是我能掌控的，也不能转换成数学问题，他没有固定的公式，更没有通用的解法。因人而定，因事而转。 嘿，说真的，我一直以为，我会悲伤好长时间，但是不知道为啥，我就这么快想开了，突然就不难过了？反正这几天还是挺开心的，偶尔搞搞问题，偶尔和组里人开开玩笑，但是偶尔沉寂下来的时候才会感到悲伤。这可能就是我喜欢晚上而非闹市的原因？“黑夜给了所有人黑色的眼睛，他们用来寻找光明，而我用来寻找你的美”。现在唯一感到遗憾的就是当时你画画的时候没有偷拍你。让我只能在回忆里寻找你。 226天，此去经年，应是良辰好景虚设。 2019051220190512 11:14 PM update今天是母亲节，刚打完省赛，刚到学校，估计老妈已经睡了，不敢打扰，就偷偷来更新一点。 今年省赛，果然还是没有打冠军，最后第五了，不行了，老了老了，精力不敌当年了。说到底还是缺少一点锐气，很多时候还是考虑太多，或者说是顾虑太多了。不过也从侧面说明了一件事，世界不是掌握在我手中，很多东西暂时还是不能掌控的。然后认真考虑了一下关于考研的事，这件事听的意见有点多了，反而自己没有搞清楚，然后你说想上中山大学医学院，然后了解了一下，感觉中山大学计算机学院还是挺强的，现在唯一的难点就是初试了，感觉只要初试过了，复试不是问题。大多数时候还是感觉自己很菜，但是好像是在一个不怎么激烈的范围里面，好像有点安逸了。温水煮青蛙，最坏莫过如此。说到底还是很多东西没有勇气舍弃罢了，工作也好，比赛也好，搞钱也好，很多东西让我迷醉了，尤其是在一个自我感觉良好的氛围里，感觉好多时候甚至不想努力了。还是很危险的。 感觉还是要安心下来正儿八经搞件事，这学期算是废了，肯定是要搞到正式offer的。然后就差不多到了暑假了，然后看情况暑假是回学校比赛还是安心准备考研了。主要是还没想清楚，自己读研到底是为了学知识，还是为了接近你？感觉这个事情还是需要想明白，不然很多时候感觉可能会努力错了方向。反正学习这种事来说，感觉还是欠缺很多，很多东西都没有系统的学好，现在想捡起来又感觉时间不太够，感觉还是自制力不够，是像我说你的一样：执行力不足。当时我和你说的是真的，没有人的执行力很强，执行力强的人都遇不到，说到底人还是一个很懒的动物。毕竟懒是第一生产力嘛。 224天，一念起，万水千山。 2019051320190513 07:54 PM update今天早晨起床，差点没反应过来，恍如隔世的感觉，真的有那种黄粱一梦的感觉，感觉一切都是假的，去北京市假的，去找你也是假的，只是做了一个很真实又很虚妄的梦。 其实大多数时候应该是，觉得自己实力还行，但是没有得到预期的结果的一种心有不甘吧。尤其是大家都是优秀的人，都觉得自己是掌控世界的一群人，如果真的违背预期的话，总会有点失落或者不甘心的感觉吧。只是这种期望长时间得不到满足的话，往往只有两种结果？对心爱之人的刻意美化或者恶意丑化？哇，不行了，感觉可以抽时间拜读一下弗洛伊德的巨作了，总感觉会受到启发。 总感觉这几天心太浮躁了，对事也好，对你也好。总感觉不够冷静和理智，容易冲动。不太清楚是不是这两周堆的事情太多的缘故。其实仔细想想，自己还挺自私的，很多事情自己都没有想清楚，然后就说了，总感觉是不吐不快，但是很多时候都是自己爽完了，然后就不管了，总感觉自己能收拾好自己处理的烂摊子，但是想想到现在都还是总用事情很多这种破借口，没有时间理清这件事。不知道是怕想清楚之后拿到了自己不想要的结果的不甘心，因此一直在逃避结果，还是自己真的很忙，所以找不到时间。可能前者居多？ 溜了溜了，这两天身心俱疲，不想多说了。就这样，希望远方的你遇事不急，早睡早起。 223天，世间有两苦，一是得不到之苦，二是钟情之苦。 2019051520190515 00:20 AM update已经是第二天了，晚上11点多的时候才陪舍友吃完饭。 昨天这个时候和我妈妈聊了一下，我妈妈对你还是挺满意的，我就和她说，你对别人菇凉满意没用啊，别人菇凉不中意你儿子啊。不过说真的，我妈妈好像真对你挺感兴趣的，你要不考虑一下今年过年和我一起回家？ 然后今天晚上准备给你电话的，然后尝试给你发了个消息，大不了你再拒绝我，我明天就以喝多了为借口呗。但是你好像直接没鸟我了。。。emmmmm，想说的话就被憋回去了。其实也没有啥大不了的事，就是这段时间很多问题没有想清楚，所以想问问你的意见，但是你好像不怎么给面子啊。不知道，估计以你的个性，明天可能也不会回我？其实有时候感觉你还是挺好的，至少没有掉着我啊。 然后我妈妈好像还是挺激动的，反正一直催我去撩你，说什么，有时间就关心关心人家，给人家尽可能的帮助啥的，反正给我的感觉就是，你要是来了，你就真是她闺女了，但是我是不是真儿子，那可不一定。然后我爸爸的话，不用考虑，我们家里人都挺好说话的，再说了，有我罩着你呢。不对，按照我妈妈这个态度，应该是你罩着我才对，哈哈哈哈哈。 突然想到我的耳机到了，但是明天才能用到，然后今天去网易云音乐上去看了一下，《空空如也》这首歌，不知不觉已经听了500多遍了，还是略恐怖的。人生寂寞如雪啊。 对了，今天不想学习主要是有一个比较奇怪的原因。从我读大学到现在，我一共有三件事让我可以奋不顾身，宁愿抛弃一切都要做，第一就是我想做一个特效爆炸的游戏，不好玩也无所谓。这个想法是大二的时候，真的是让我魂牵梦绕，让我想了好长时间，第二就是想去见你，那是来了北京之后的想法，让我很多时候都不能集中精力搞正事，直到五一，我和你说的都是真的，我是真的觉得一切都值得。无论是你想做什么，我都愿意陪着你。然后今天突然有了第三件事，我想来一次说走就走的旅行，今天看了一天地图，一直在想去哪去哪，但是具体的旅行地点还没定下来，不过抱歉的事是：这个计划没有你，本来想完之后说要不要计划加上你，后来想想太矫情了。这个计划没有你，我只想一个人看最美的景，当然如果那个时候你能在我身边的话，我会更开心。计划还没计划好，估计应该是12月份左右开始执行，应该是11月之前会规划好，到时候做两份计划吧，看你愿不愿意。 20190515 07:53 PM update上午就是纯赶路了。大概中午到宿舍，洗了个澡就去公司了。今天一整天都不是很舒服。 昨天晚上的时候，我和你说过了，我陪舍友吃饭了，当时喝了点酒，当然没醉，尝试着给你发了个消息，但是你没回复我，今天早上你说你是睡着了。其实吧，昨天没有啥别的意思，就是想问你点事，让你给个意见而已，但是你好像兴趣不高，所以就没打扰你了。其实就是想问问你，觉得我到底是考研好，还是找工作好，还是打比赛好，自己现在没什么主见，问了问老妈，好像也没改出啥建设性意见，所以准备问问你，但是你好像是睡了。就算了。估计你八成是想我读研，所以想问问你读研的话啥时候开始准备比较好，因为目前一段时间还是比较忙，暂时是没时间开始准备，舍友的意见是不急，暑假开始准备就行了，反正他们对我的信心比他们对自己的信心都足，不知道是为啥。 还有就是今天发工资了，准备换个手机了，但是还有点舍不得，微信暂时没有不同设备登录，聊天记录同步的功能（还是说我没找到？），所以换了手机之后可能聊天记录都没了？所以我今天翻完了我们所有的聊天记录，然后截图了，看今天晚上拷贝一下，感觉还是一个挺美好的回忆的。然后觉得比较过分的就是为啥聊天记录都是我一个人在发言呢？反正基本都是一片绿，然后见着一点白。哇，难受。可能是我手速比较快的缘故，感觉不见得，你好像挺不想和我分享每天发生了啥一样。我这个人就这样，闲不下来，反正只要是有趣的事都喜欢分享给你，但是你很多时候好像是不感兴趣，所以没怎么回复我，假装你是忙吧。也只能这样安慰自己了。 221天，万物皆有其时，耐心等待。 2019051620190516 10:00 PM update今天头疼了一天，应该还是没有休息好的缘故。 昨天开始渐渐开始给你发消息了，不然我是真的怕有一天把你忘了。说心里话，我不知道我到底是需要一个倾诉的对象还是对象。可能是前者居多？因为我很少主动开启一个话题，所以不怎么喜欢找人聊天，所以很多时候有些事都不知道找谁说，所以个人觉得还是更缺少一个倾诉的对象？不过我觉得现在的状态挺好的，每天和你分享一点或开心或难过的事，也不算太打扰你？但是还是和以前一样吧，都是我输出较多，你还是很少回我，但是我还是很开心啊啊啊啊啊，真的很怕你不理我了。 今天看了一下，如果你决定读研读中山的话，我就准备考虑华南理工了，感觉考上不是很难，而且看了一下知乎，都说华南理工的就业氛围很好，所以可以考虑读一下，然后我们组的一个人说，读中山啊，中山妹子多，可以给你压力，哈哈哈哈哈，不知道啊，问了一下舍友，他们说这两个学校的考试难度几乎相当，所以暂时还没决定，应该是今年暑假就开始准备了，暑假感觉可以回一波家，感觉还是更倾向于考研吧，暂时还是不知道队友之间的态度，感觉大概率会玩完，所以更倾向于读研。今天和组里人聊了一下搞钱的事，他们都说读研好，搞钱不急，而且前几年基本是搞不了多少钱，就算搞到钱了也存不下来，所以暂时不考虑这个，但是如果能转正的话，不是不可以考虑一波，但是看老大对我的态度，大概率不会成功，所以暂时更倾向于考研，但是还没定下来，这周六感觉可以考虑一下具体的想法。或者这周二考完试，下午的时候好好想想。 这周开始就继续锻炼了，对了，看了一下前两天你的体测报告，感觉很厉害啊，不行了，我也要好好锻炼了，话说5.1那段时间去玩的时候我脚上磨了一个泡，前两天才消下去，太虚了。还是缺乏锻炼了，还是因为怎么吃都不胖的缘故，这段时间就疯狂的偷懒，感觉最近越来越虚了。反正现在要好好锻炼了，怎么说也得公主抱吧，不能太虚了。下学期应该是回学校了，有时间锻炼，但是我健身教练的舍友好像要全身心考研了，感觉不会带我，到时候看情况是拉队友过去，还是自己锻炼，其实我觉得吧，做事这种东西，一个人做永远是最无聊的，虽然多个人效率不一定高，但是一定是不容易累的，老话怎么说来着？男女搭配，干活不累。说真的，五一那几天我是真的不累，3号的时候其实就是想故意气气你，我生气了，哈哈哈哈哈。你都看出来了还不哄哄我，难受，居然还让我去买水？居然想支开我，你也太坏了。 还有就是那天晚饭的时候，我一直叫你“小老弟”，你好像挺反感的，没有别的意思，只是觉得这个称呼很有意思而已，而且那个时候感觉叫你啥都不好啊。总不能继续叫你“小姐姐”吧？ 220天，既然不好意思说晚安，那就祝你晚不安，最好今夜有梦，梦里有我。 2019051720190517 10:30 AM update刚刚去水了一发日记，感觉还是挺惭愧的，日记是真的一天不落全都有，但是这个故事还断了几天，看了一下，大概是省赛少了，还有就是那天准备复习和陪舍友喝酒少了。现在日记被彻底拆成了三部分：工作日报，这个故事，生活琐事。等离职之后可能工作日报和生活琐事并一下，但是这个故事还是单独成为一个故事吧，以为觉得这个是真正值得回忆的事，而不是记流水账。 其实这两天仔细考虑了一下，你其实应该不是没有看懂暗示，而是假装没看懂暗示。更多的时候你应该是不想看懂，假装看不懂，然后就可以搪塞我?还是说你觉得我脸皮不够厚，不敢瞎说话？可能让你失算了，我最后还是捅开了，但是好像努力错了方向，最后搞得大家都不怎么愉快了。emmmm，其实我觉得这样还挺好的，至少比你看破不说破好一点，这样大家长痛不如短痛啊。我也没有一下乱七八糟的小心思，你也可以安心考研了。就这样独自安好了。 20190517 07:52 PM update不行了，今天晚上实在忍不住了，想和你商量一下关于明年的安排。emmm，用自己不知道未来的想法去寻求你的帮助应该不算过分吧。感觉还是不甘心在作祟。还是想挣扎一下？因为这两天实在是太忙了，所以今天想早点走了，因为明天就放假了。所以现在开始动心思准备出去玩了。明天看情况出去逛逛。 这段时间渐渐忙起来了，主要是因为现在考试也告一段落，剩下的时间比较多，以前的时候有时间就摸鱼，现在不怎么想摸鱼了，一来是感谢老大的栽培，二来是想让自己忙一点，别天天去想一些乱七八糟的东西。你看，现在随着时间的推移，我对你忘得越来越多了不是？很多东西都想不起来了。还是说不想想起来？ 话说第一天的时候，当时逛瓷房子的时候我还是挺不开心的，这种时候难道不是应该两个人找一个幽静的咖啡厅，然后一起老朋友叙叙旧吗？说真的，当时逛的时候直接把我准备好的好多话憋回去了。。。。本来想找个地方聊会天的。。。。然后以为中午有机会，结果你也知道了，中午的时候不止两个人，说真的吃饭那个地方环境还挺好的，多适合说心里话啊。不过我当时想啊，我有的是时间不是吗？所以不急。结果不急不急就真的没机会急了。 219天，愿你贪吃不胖，愿你懒惰不丑。愿我的深情不被辜负，愿我的余生都有你陪。 2019051820190518 04:49 PM update昨天晚上给你打了个电话，咨询了一下关于下半年到底是考研，工作还是打比赛的问题。但是你好像兴致不高，其实吧，你要是明确给出一个意见，我一定会去做吧。我是真的不知道到底怎么选，不是故意找个由头和你打电话的。你最后好像也只是帮我干掉了一个选择：就是不要去工作。然后你好像是更倾向于比赛，其实你这样说我反而是更倾向于考研了。如果你中山大学定下来的话，我就可以着手准备考西南理工大学。然后就问了你一下中山定下来了没有，但是你好像还是在动摇，所以这件事就暂一搁浅了。 我还是那句话，感觉很多事情还是早早定下来比较好，我这段时间就因为思考各种利弊关系搞得我很焦虑，很多时候甚至不能安心思考了。但是我现在应该没有资格去给你出主意了，毕竟我自己都没有想好到底选什么，甚至去你那里问想法了。 今天又刷了一遍大鱼海棠，我以为我会有啥感同身受的感觉呢，结果还是那样，别人的故事毕竟是别人的故事吧。不过有句话还是挺打动我的： “生命是一场旅程。我们等了多少个轮回，才有机会去享受这一次旅程。短短的一生，我们最终都会失去，你不妨大胆一些，爱一个人，攀一座山，追一个梦。” 这种事怎么说呢，其实大多数人是没机会追寻自己的梦的，很多时候还是不得不屈服于现实不是吗？更多的时候是人力不可抗的因素，就像你现在不喜欢我一样，可能越努力越反感了？或许现在唯一能做的就是偶尔找你聊聊天，听听你最近一段时间的吐槽，给你出一两个狗头军师的意见。但是你好像不怎么有兴趣找我聊天，一般都是我主动的多。可能还是对我戒心比较大？ 218天，命里有时终须有，命里无时莫强求。 2019051920190519 09:33 PM update今天和你聊了一下关于晚睡的问题，其实一直以来都想说，你好像睡觉一直挺不规律的，我是真的觉得作息不规律对身体很不好，虽然我也没有每天早睡，但是基本都是12点之前睡觉了，太晚睡真的是对身体不好，不仅是休息不好的缘故，反正整个人的精力都不好了，一天都会没有精神。还有就是这个年龄段，尤其是在学校的日子，没有什么事是值得你为之熬夜的。至少我目前还没发现什么事是非要我晚上之前搞定的，第二天干就会出问题了？ 还有就是你说你在学校发现了一个地方写有你的名字，我居然没有吃醋鸭，只是觉得挺有趣的，因为有一个人暗恋着你，还不敢偷偷告诉你，还居然是舍友先发现的，这就太尴尬了，当然不排除有个男生写了告诉你舍友了。然后试探试探你的态度，但是我是真的觉得很有意思，反而没有吃醋的感觉，可能是对自己有足够的自信？当然还是挺羡慕你的，其实有一个人在背后默默祝福你的感觉真的挺好的。 然后你就开玩笑说下次去青岛给我写满，我是真的当真了，就像我说的，虽然下一次不知道是什么时候，但是只要有下一次，多久都值得不是吗？到时候你可别赖账啊，不写满不准你离开我了。 217天，我们都足够成熟，也足够理智，没有人愿意用自己的感情和青春去赌个不确定的未来。但因为那个人是你，所以我愿意。 2019052020190520 10:40 AM update今天出门的时候，阳光正好，微风不热，一切正如刚见你时候的样子，真的很美。我刚去的时候，我是真的有说不完的话想和你说，但是啊，你真的是没有怎么回应我，导致我阻塞了。所以啊，想念这种东西，还真不能是单向的，不然啊，就像负重前行，总该是会累的吧。 20190520 11:05 PM update明天考试，我还没开始复习，但是我还是更想和你说话，不想复习。 今天是520鸭，真的很想和你说话啊，但是又怕你戒心太重了，就没怎么和你说话，就是吐槽了一下今天网易云给我推荐了一堆情歌，评论全是别人的甜美爱情故事。你好像只是单纯的同情我，哇，这个时候不应该是咱们偷偷做一天情侣吗？你要是真的这样说，我说不定真的会把票退了不考试了，直接去找你玩，算了，还是自己想想就好了，别想多了。这段时间咋回事啊，天天做白日梦啊。不过真的想和你谈恋爱啊啊啊，哪怕一天也好啊。你想做什么都行，我都可以陪着你，想到只要可以静静看着你，就很开心了。 还有就是那天画画的时候，我不是觉得无聊了，而是我困了，那天睡的挺晚的，没睡好，但是又不好意思睡觉，早上又很早就醒了，然后睡不着，一直在想前一天晚饭的事，所以下午的时候很困了，真的不是无聊了。哇，我当时累的不行了，就想休息一下，但是还是想和你说话，结果你居然让我去买水。当时真的是被你蠢哭了。但是莫名觉得你还挺可爱的？这段时间没见你了，也没有理由找你要照片，所以更多的时间就去看那幅画，不管怎么说，也是你几个小时的战果啊。最后我还是没给他挂起来，我怕弄坏了，万一不小心刮花了我心都会碎的。 216天，深深的话要浅浅的说，长长的路要挥霍的走，大大的世界要率真的感受。 2019052220190522 10:48 AM update昨天和前天都找你聊了会天还挺满足的？今天好像是我妈生日？感觉今天该打个电话回去了。 214天，网易云里面的评论有999+，我也不敢打出你的名字。 2019052320190523 12:30 PM update今天突然听到了《好久不见》，感觉真的好久不见了，甚是想念，现在学校的事情算是终于搞定了，现在可以安心搞其他的事了。这段时间算是真正忙起来了，每天都是干不完的活。 对了，关于上次你说高考考完数学后我对你说了什么话，我是真的忘了，你说的对，只有自己会记得自己说过什么，我去问了李思慧一下，她也不记得了，看来这彻底成了你一个人的秘密了。我这几天都在努力的回忆，如果有这件事的话，我大概想起来了一部分，当时我们是在一中考试的？而非孟宗，然后我们都是从小学那个门口出来的，然后你是在那个上坡的时候哭了？然后我无非就是可能说了两种话：要么是嘲讽你了，要么是安慰你了，以我高中的尿性，应该是带了嘲讽的安慰，多半是会说：没事我考的比你还差，我都没哭，你怕啥啊？类似的话。因为我记得我语文考的更差，所以可能说了一句我作文都跑题了，你怂啥啊。应该就是类似的话吧。反正感觉顶多是用让你很不爽的话怼你了，让你暂时忘却了考的不好的悲痛？其实回头来看，你都比我考的好多了。 而且你看，当初我们拼命挣扎，痛的撕心裂肺的事现在看来还不是淡然了吗？你现在回忆起来还是有意思居多吧？反正我觉得吧，考试这种东西，努力了就好啊，别太心急。 然后就是这段时间考研的事了。我舍友这段时间又吵架了，反正我不在就闹腾起来了。其实在我看来九成九是因为考研的事，我才渐渐知道，考研的人压力是真的大，所以这段时间我都只敢和你分享有意思的事，看出你有心情不好的时候就安慰你一下。 还有就是关于你刷微博的事，你说你是喜欢做一个倾听者，实际上我觉得是因为你已经是个消费者，而懒得去做生产者，以至于很多时候你甚至不能好好的表达自己，但是没时间去改正，所以你现在都是喜欢听别人的故事。所以啊，我得配合你啊，我就老老实实给你说我发生了啥啊，至少这样我们两个人之间没那么无聊啊。 213天，这一生，我会遇到一切比你都好的，但我已经没有精力，不顾一切去再爱一次了。 2019052420190524 10:19 AM update今天早上奇哥和我说他失恋了，这次是真的，这让我不得不开始思考一个问题，我是不是恋爱绝缘体啊。为啥我周围的人都失恋了呢？巨难受。其实我想的更多的是他失恋的原因：他对象想要结婚了，但是他现在处于上升期，至少是两年之内不可能结婚的。说到底就是我给不了你想要的，所以不如就此别过了。当他说完这个事实的时候，我也跟着挺难受的，让我想起了我初恋，当时是同样的情况，我给不了她想要的，所以大家就此别过了。现在回头来看，只能说是挺可惜的。 其实，当时犹豫了很久才去见你是同样的问题，就是怕自己没有放弃一些东西的勇气，所以一直不敢见你，当我下定决心了之后，还是被你拒绝了，其实，无论是比赛还是考研还是找工作，我都拿得起，为你我也确信自己放得下，但是你都没有给我机会去证明这一点，还是有点难受的。他们说：这辈子最后悔的一件事就是，在错的时间遇上了对的人，但是却没有能力或者说没有勇气去抓住。我们应该就是这种情况，说到底我其实还是没有准备好吧。自认为自己掌控着一切，可以随便牺牲，在哪个方向都能做到很出色，但是实际上却不是这样，很多时候还是太怂了，很多东西不是说放下就能放下的。 我后来才渐渐明白，我身上承载的不仅有我的梦，还有很多人的期许。虽然说我做不到背叛全世界，但是我真的愿意去争取听从你的意见，所以大多数时候我还是挺想听听你的意见的，但是从上次就可以看出来，你不怎么想给我意见。其实我还挺倾向于考研的，但是队友失恋了，很可能就能安心打比赛了，所以又陷入了一个个不确定中。就这样了，上次说过了，这种问题得不到答案的时候，反复思索只会陷入焦虑。今天和队友聊一下，倒时候再决定吧。 20190524 04:51 PM update刚刚和你聊了一下，关于谈恋爱和结婚的事，我们好像持有一部分不同的观点，可能是我经历稍多一点的缘故吧。 不过让我真正感兴趣的事是你发给我的表情包，哇，真的想不到，你会用这种表情包，简直人设崩塌啊，是真的，哇，你可是小仙女啊，怎么能用哪种表情包呢？然后就奶了你一句，然后就赶紧跑了，哇，说真的，现在突然有了一种恋爱的感觉，彻底不想干活了，翻来覆去看了两三遍记录才平静下来。啧啧啧，不得了不得了。]]></content>
      <tags>
        <tag>story</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haskell 学习笔记]]></title>
    <url>%2F2019%2F05%2F18%2Fhaskell%2F</url>
    <content type="text"><![CDATA[开启传送门 开始 预备，准备，开始！ 好，让我们开始！如果你因为某些奇奇怪怪的原因没有阅读介绍，还是建议你阅读以下介绍中的最后一节，因为它介绍了为什么你要阅读这个教程，以及为什么我们要写这个教程。首先我们要做的就是云心$ghc$的互动窗口，运行一些函数，以便对$haskell$有一个比较基础的认识。打开你的终端，然后输入 ghci 并回车，你会看到类似于下面的东西： 123GHCi, version 6.8.2: http://www.haskell.org/ghc/ :? for help Loading package base ... linking ... done. Prelude&gt; 恭喜你，进入到了GHCI！这里的引导是 Prelude&gt; ，但是当你输入一些东西的时候它会显得很长，所以我们打算用 ghci&gt; 。如果你也有同样的诉求，可以尝试输入 set prompt “ghci&gt; “ 这里有一些简单的数学算式的例子： 123456789ghci&gt; 2 + 15 17 ghci&gt; 49 * 100 4900 ghci&gt; 1892 - 1472 420 ghci&gt; 5 / 2 2.5 ghci&gt; 这是不言自明的。我们同样可以在一行中进行多个操作，并且这些运算遵循现实中的运算优先级。可以用括号来明确运算优先级或者改变运算优先级。例如： 123456ghci&gt; (50 * 100) - 4999 1 ghci&gt; 50 * 100 - 4999 1 ghci&gt; 50 * (100 - 4999) -244950 相当酷，不是吗？是的，我知道这很一般，但是还是容忍我啰嗦两句。要小心负数。如果我们想使用一个负数，最好给他加上括号。例如，如果在$GHCI$中输入表达式 $5 * -3$ 将会得到报错，但是输入 $5 * (-3)$ 将运行的很好。 bool代数同样是很直接明了的。正如你以前知道的一样， &amp;&amp; 表示bool代数 与， || 表示bool代数 或, not 会翻转bool表达式。例如： 12345678910ghci&gt; True &amp;&amp; False False ghci&gt; True &amp;&amp; True True ghci&gt; False || True True ghci&gt; not False True ghci&gt; not (True &amp;&amp; True) False 对“等于”的判断测试如下 12345678910ghci&gt; 5 == 5True ghci&gt; 1 == 0 False ghci&gt; 5 /= 5 False ghci&gt; 5 /= 4 True ghci&gt; &quot;hello&quot; == &quot;hello&quot; True 如果我们输入 5 + “llama” 或者 5 == True 会发生什么呢？如果我们尝试了第一个式子，我们将会得到一个大大的错误！ 12345No instance for (Num [Char]) arising from a use of `+&apos; at &lt;interactive&gt;:1:0-9 Possible fix: add an instance declaration for (Num [Char]) In the expression: 5 + &quot;llama&quot; In the definition of `it&apos;: it = 5 + &quot;llama&quot; $GHCI$告诉我们， “llama” 不是一个数字，所以它不知道如何把这两个东西加起来。或者说，就算把 “llama” 换成 “four” 或者 “4” ，$haskell$同样不会认为这是一个数字。 + 运算符期望它的左边和右边都是数字。同理，如果我们尝试输入 True==5 ，$GHCI$会告诉我们他们两个的类型不匹配。+ 作用于两个数字， == 作用于两个同类型可比较的事物。你不能把苹果和橘子进行比较。我们将会在后文中更直观的感受类型的区别。注意：你可以写出 5 + 4.0 这样的式子，这是因为 5 很特别，它可以是一个整数也可以是一个浮点数。 4.0不能表示为整数，所以 5 就被解释为浮点数。 你可能没有注意到，但是我们确实是一直在使用函数。更确切的说，* 是一个将两个数乘起来的函数。正如你所见到的那样，我们把它放在两个数中间以使用它。我们将这种调用方式称为 “中缀函数”。大多数函数都是 “前缀函数”。让我们看看。 函数通常是前缀的，所以从现在开始我们不会明确的说明一个函数式前缀形式，我们假定这是对的。在大多数命令式语言中，通过编写函数名称然后将参数写在括号中来调用函数，参数表通常用逗号分隔。在 $Haskell$ 中，函数的调用方式是直接写函数名称，一个空格然后是参数表，参数之间用空格分隔。为了有个直观认识，我们尝试去调用 $Haskell$ 中一个贼无聊的函数。 12ghci&gt; succ 8 9 $succ$函数介绍任何定义过的参数，并且返回它的老大。正如你看到的，我们直接把函数名和参数用一个空格分开。调用一个多参数的函数同样很简单。例如，函数 min 和 max 接受两个可以排序的东西（例如数字！）。 min 函数返回二者中的较小的， max返回二者较大的。你可以自己看看： 123456ghci&gt; min 9 10 9 ghci&gt; min 3.4 3.2 3.2 ghci&gt; max 100 101 101 函数的调用（通过加一个空格和添加参数来调用函数）有最高优先级。也就是说下面两种表达方式是等价的： 1234ghci&gt; succ 9 + max 5 4 + 1 16 ghci&gt; (succ 9) + (max 5 4) + 1 16 但是，如果我们想得到 $9$ 和 $10$ 乘积的老大，我们不能写成 succ 9 * 10，这是因为这样写，会得到 $9$ 的老大，然后乘以 $10$，也就是说我们会得到 $100$。我们必须写成 succ (9 * 10) 才能得到 $91$。 如果一个函数接受两个参数，我们同样用中缀方式调用它。例如， div 函数接受两个参数，然后把两个参数相除。调用 div 92 10 将会得到 $9$。但是我们这样调用的时候总给人一种奇怪的感觉——不能很清晰的知道哪个是被除数，哪个是除数。所以我们可以用一种中缀的方式调用它—— 92 `div` 10 ，这样就清晰多了。 很多来自命令式语言的人更倾向于用括号表示功能应用。例如，在 $C$ 中，你能用括号来调用像 foo(),bar(1),baz(3, \”haha\”) 这样的函数。就像我们之前提到的，在$Haskell$中用空格来区分参数以调用函数。所以上述函数在$Haskell$中可能写成 foo,bar 1,baz 3 \”haha\”。所以当你看到像 bar (bar 3) 这样的调用，它不意味着 bar 以 bar 和 3 为参数。它意味着我们先以$3$为参数调用了 bar 并以返回结果再次调用了 bar 。在 $C$ 中，你可能写成 bar(bar(3))这样。 天才第一步在前一节中，我们对函数调用有了一个基本的认识。现在让我们尝试写自己的函数！打开你最喜爱的编辑器，写下这个接受一个参数并返回它的两倍的函数。 1doubleMe x = x + x 函数的定义和他们被调用的方式大致相同。函数名后面接参数表，并用空格分隔。但是我们在定义函数的时候，这里有一个 = ，并且函数的功能会写在后面。保存这个并命名为 baby.hs 或者其他。然后跳到这个文件所在的目录，然后在该目录下运行 ghci 。进入之后运行 :l baby 。现在我们的文件就加载进去了，然后我们可以调用我们之前定义的函数。 1234567ghci&gt; :l baby [1 of 1] Compiling Main ( baby.hs, interpreted ) Ok, modules loaded: Main. ghci&gt; doubleMe 9 18 ghci&gt; doubleMe 8.3 16.6 因为 + 无论是作用于整数还是浮点数（理论上任何是数字的东西都可以）都可以得到正确的结果，所以我们的函数可以正常工作于任何数字。让我们写一个函数，它有两个参数，并返回他们的两倍的和。 1doubleUs x y = x*2 + y*2 简单。我们同样可以定义成 doubleUs x y = x + x + y + y 。测试一下我们的函数是否能返回正确的结果（记得把这个函数加到 baby.hs 中，保存，然后在 $GHCI$ 中运行 :l baby ）。 123456ghci&gt; doubleUs 4 9 26 ghci&gt; doubleUs 2.3 34.2 73.0 ghci&gt; doubleUs 28 88 + doubleMe 123 478 正如我们期待的一样，你能调用你自己之前的函数。知道这个之后，我们可以重新定义 doubleUs 像下面这样： 1doubleUs x y = doubleMe x + doubleMe y 这是一个特别简单的例子，这种模式会贯穿整个 $Haskell$.写一些基础的，一定正确的函数，然后组合他们来得到更加复杂的函数。利用这种方式你可以很轻松的避开反复的造轮子。如果某一天数学家们突然指出 $2$ 实际上是 $3$ ，你就只能去改你的代码吗？或许你可以直接重新定义 doubleMe 为 x + x + x，这样当 doubleUs 调用 doubleMe 的时候，它自动变成了适应这个把 $2$ 看成 $3$ 的奇怪世界。 $Haskell$中的函数不用按照顺序定义，也就是说如果你先定义了 doubleMe 然后定义了 doubleUs 或者其他顺序，这都没有关系。 现在我们准备写一个函数，它接受一个参数，如果这个参数小于或等于 $100$，会返回这个数的两倍，否则就会返回这个数本身，因为大于 $100$ 的书本身就够大了。 123doubleSmallNumber x = if x &gt; 100 then x else x*2 上面我们介绍了 $Haskell$ 中的 if 语句。你或许已经习惯了其他语言中的 if 语句。和其他语言不同的是， $Haskell$ 中必须要有 $else$ 。其他语言中你可以不使用 $else$ 当 $if$ 条件不成立的时候，但是在 $Haskell$ 中，任何表达式和函数必须有返回值。我们可以把 $if$ 语句写在一行里面，并且这样可读性更强。还有就是 $Haskell$ 中的 $if$ 语句是一个 表达式 。一个表达式是一段基础的代码，它返回一个值。 $5$ 是一个表达式，因为它返回 $5$ 。 $4 + 8$ 是一个表达式，$x + y$是一个表达式，因为它返回 $x$ 和 $y$ 的和。因为 $else$ 语句是必须的，所以 $if$ 语句将总是返回一些东西，这也就是我们为什么说它是一个表达式的原因。如果我们想把之前定义的函数加一，我们可以写成下面这样 1doubleSmallNumber&apos; x = (if x &gt; 100 then x else x*2) + 1 如果我们省略了括号，他仅仅在 $x$ 不大于 $100$ 时才会将结果加一。注意到在函数名末尾的 ‘ 。这个符号在 $Haskell$ 中并没有什么特殊含义。他是函数名称中的一种合法字符。我们通常用它来表示函数的严格版本（不是懒惰版本）。或者函数或者变量的轻微修改版本。因为这个符号是合法的，我们可以创建下面这样的函数。 1conanO&apos;Brien = &quot;It&apos;s a-me, Conan O&apos;Brien!&quot; 这里有两件值得注意的事。第一就是，我们没有利用 $Conan$ 来命名函数。这是因为函数不能用小写字母开头。我们将在后面明白为什么是这样。第二就是这个函数没有任何参数。当一个函数没有参数的时候，我们通常称为这是一个 声明 （或者 命名）。因为一旦我们定义了之后，我们不能修改名称和函数，所以 conanO’Brien 和字符串 “It’s a-me， Conan O’Brien!” 可以互换使用。 对list的介绍 在 $Haskell$ 中列表很有用，就像现实世界中的购物清单一样。它是最常使用的数据结构并且能被多种不同的方式建模，并解决一系列问题。列表是如此的优雅。在这一节我们将学习list的基础应用，字符串（实际上也是列表）和列表的推导。 在 $Haskell$ 中，list中的元素必须是同一种元素。它存放多个同种类型的元素。这意味着我们可以存放一堆整数或者是一堆字符。但是我们不能定义一个存放一部分整数和一部分字符的list。 提示 ： 我们在 GHCI 中能用 let 关键字来命名，在 GHCI中执行 let a = 1 等价于在一个文件里面写 a = 1 然后加载它。 123ghci&gt; let lostNumbers = [4,8,15,16,23,42] ghci&gt; lostNumbers [4,8,15,16,23,42] 正如你见到的这样， `]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 63]]></title>
    <url>%2F2019%2F04%2F28%2FEducational%20Codeforces%20Round%2063%2F</url>
    <content type="text"><![CDATA[F. Delivery Oligopoly开启传送门 题目描述The whole delivery market of Berland is controlled by two rival companies: BerEx and BerPS. They both provide fast and reliable delivery services across all the cities of Berland. The map of Berland can be represented as an undirected graph. The cities are vertices and the roads are edges between them. Each pair of cities has no more than one road between them. Each road connects different cities. BerEx and BerPS are so competitive that for each pair of cities $(v,u)$ they have set up their paths from $v$ to $u$ in such a way that these two paths don’t share a single road. It is guaranteed that it was possible. Now Berland government decided to cut down the road maintenance cost by abandoning some roads. Obviously, they want to maintain as little roads as possible. However, they don’t want to break the entire delivery system. So BerEx and BerPS should still be able to have their paths between every pair of cities non-intersecting. What is the minimal number of roads Berland government can maintain? More formally, given a 2-edge connected undirected graph, what is the minimum number of edges that can be left in it so that the resulting graph is also 2-edge connected? InputThe first line contains two integers $n$ and $m$ ($3\leq n\leq14$, $n\leq m\leq \frac{n(n-1)}{2}$) — the number of cities and the number of roads between them. Each of the next 𝑚 lines contains two integers $v$ and $u$ ($1\leq v,u\leq n,v\neq u$) — the cities connected by the next road. It is guaranteed that each pair of cities has no more than one road between them. It is guaranteed that each pair of cities have at least two paths between them that don’t share a single road. OutputThe first line should contain a single integer $k$ — the minimum number of roads Berland government can maintain so that BerEx and BerPS are still able to have their paths between every pair of cities non-intersecting. The next $k$ lines should contain the list of roads which are being maintained. Each line of form “$v\ u$”, where $v$ and $u$ are cities connected by the next road. If there are multiple lists of minimum size, print any of them. The order of roads in the list doesn’t matter. Examplesinput13 31 22 33 1 output131 33 21 2 input24 51 21 42 34 31 3 output241 44 33 21 2 input36 101 22 33 13 44 55 64 62 51 63 5 output361 66 55 44 33 21 2 NoteHere are graphs from the examples, red edges are the maintained ones. 题意给你一个不超过14个节点的无向图，让你找到满足一下条件的一个子图： 包含所有点 包含尽可能少的边 子图中任意两个点存在两条完全不交的路径 让你输出一个任意符合题意的子图。 分析当时没做出来，看题解才做出来的。建议先看原题解。如下： Let’s use dynamic programming to solve this problem. We will start with a single biconnected component consisting of vertex $0$, and connect other vertices to it. So, the state of our dynamic programming will be a $mask$ of vertices that are in the same biconnected component with $0$. How can we extend a biconnected component in such a way that some other vertices are added into it, but it is still biconnected? We will add a path (possibly cyclic) that starts in some vertex $x$ belonging to the $mask$, goes through some vertices not belonging to the $mask$, and ends in some vertex $y$ belonging to the $mask$ (possibly $x=y$). If for every triple ($x,y,addmask$) we precalculate some path that starts in $x$, goes through vertices from $addmask$ and ends in $y$ (and $addmask$ does not contain neither $x$ nor $y$), then we can solve the problem in $O(3^nn^2)$: there will be $2^n$ states, for every state we will iterate on two vertices $x$ and $y$ belonging to the $mask$, and the number of possible pairs of non-intersecting masks $mask$ and $addmask$ is $O(3^n)$. The only thing that’s left is precalculating the paths for triples ($x,y,addmask$). That can be done with auxiliary dynamic programming $dp2[x][y][addmask]$ which will denote whether such a path exists. For every edge ($u,v$) of the original graph, $dp2[u][v][0]$ is true, and we can go from $dp2[x][y][addmask]$ to some state $dp2[x][z][addmask^{‘}]$, where $addmask^{‘}$ will contain all vertices from $addmask$ and vertex $y$ (and we should ensure that there is an edge ($y,z$) in the graph and the $addmask$ didn’t contain vertex $y$ earlier). We should also somehow be able to restore the paths from this dp, and we also should be careful not to choose the same edge twice (for example, if we start a path by edge ($x,y$), we should not use the same edge to return to $x$) — both these things can be done, for example, by storing next-to-last vertex in the path. 我基本是看完题解才有想法的，和题解写的一模一样，（其实不一样，我写的比标程丑）。 大体思路还是很清晰的。 首先，我们可以很轻松的发现，答案一定是很多环交在了一起构成了答案对应的子图，然后对于任何一个存在很多环相交的图来说，我们可以拆成一个环和很多很多边构成的，如下图： 同样的我们可以很轻松的得到，任何一个环都可以作为拆分后唯一的环。剩下的问题就是我们怎么找到所有的边了。也即怎么找到我们需要的所有路径。我们做以下定义。 我们找到一条从$a$到$b$的路径，并且其中包括$mask$对应的其他点，我们假设$dp2[a][b][mask]$表示是否存在一条从$a$到$b$的路径，并且还包含了$mask$点，例如： $dp2[1][3][1] = 1$表示存在一条$1-0-3$的路径 $dp2[3][5][3] = 1$表示存在一条从$3$到$5$的路径，其中包含$0$号点和$1$号点，路径可能是$3-0-1-5$，也可能是$3-1-0-5$。 对于他的转移显然比较好想，直接枚举下一个点是谁就行了。 然后我们取出任意一个节点表示当前符合答案的子图的子图。因为一个点的时候显然符合答案（因为一对都没有）。然后我们在这个子图的子图中不断的添加边构成环，最后判断得到的全图是否满足答案就行了。。。。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 14;const int maxm = 1&lt;&lt;maxn;int n,m,upper;int dp[maxm|10];//记录答案是否存在，也即当前子图是否满足条件（子图中任意两个点存在两条完全不交的路径）bool dp2[maxn][maxn][maxm];//表示是否存在一条从i到j，包含mask对应点的路径int last[maxn][maxn][maxm];//用来记录i到j中上一个点是谁，用来输出路径vector&lt;int&gt; bit[maxm|10];//表示mask中对应的点的编号vector&lt;int&gt; mat[maxm|10];//存输入的图pair&lt;int,int&gt; con[maxm|10];//表示mask对应的两个外部点，也就是路径的起点终点int addmask[maxm|10];//mask对应的外部边对应的maskvoid show_bit(int a)&#123; if(a) show_bit(a&gt;&gt;1); else return ; if(a&amp;1) cout&lt;&lt;1; else cout&lt;&lt;0;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; upper = 1&lt;&lt;n; for(int i = 0,a,b;i&lt;m;i++)&#123; cin&gt;&gt;a&gt;&gt;b; a--,b--; mat[a].push_back(b); mat[b].push_back(a); &#125; memset(dp,0x3f,sizeof dp); memset(dp2,false,sizeof dp2); for(int i = 0;i&lt;n;i++) for(auto j: mat[i])&#123; dp2[i][j][0] = 1; last[i][j][0] = i; &#125; for(int mask = 0;mask&lt;upper;mask++) for(int j = 0;j&lt;n;j++) if(mask&amp;(1&lt;&lt;j)) bit[mask].push_back(j); for(int mask = 0;mask&lt;upper;mask++)&#123; for(int i = 0;i&lt;n;i++)&#123; if(mask&amp;(1&lt;&lt;i)) continue; for(int j = 0;j&lt;n;j++)&#123; if(mask&amp;(1&lt;&lt;j)) continue; if(i==j||dp2[i][j][mask]==false) continue; for(auto z:mat[j])&#123; if(mask&amp;(1&lt;&lt;z)) continue; if(z==last[i][j][mask]) continue; if(dp2[i][z][mask|(1&lt;&lt;j)]==false)&#123; last[i][z][mask|(1&lt;&lt;j)] = j; dp2[i][z][mask|(1&lt;&lt;j)] = true; &#125; &#125; &#125; &#125; &#125; dp[1] = 0; for(int mask = 0;mask &lt; upper;mask++) &#123; for(int add = mask;add;add = (add-1)&amp;mask)&#123; int pre = add^mask; int cnt = __builtin_popcount(add)+1; if(dp[pre]+cnt&gt;=dp[mask]) continue; bool flag = false; for(auto x:bit[pre])&#123; for(auto y: bit[pre])&#123; if(dp2[x][y][add])&#123; dp[mask] = dp[pre]+cnt; con[mask] = make_pair(x,y); addmask[mask] = add; &#125; &#125; &#125; &#125; &#125; if(dp[(1&lt;&lt;n)-1]==inf) cout&lt;&lt;-1&lt;&lt;endl; else &#123; cout&lt;&lt;dp[(1&lt;&lt;n)-1]&lt;&lt;endl; int cur = (1&lt;&lt;n) - 1; while(cur!=1)&#123; int add = addmask[cur]; int x = con[cur].first; int y = con[cur].second; cur^=add; while(add)&#123; int ny = last[x][y][add]; cout&lt;&lt;y+1&lt;&lt;' '&lt;&lt;ny+1&lt;&lt;endl; y = ny; add^=(1&lt;&lt;ny); &#125; cout&lt;&lt;x+1&lt;&lt;' '&lt;&lt;y+1&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 553]]></title>
    <url>%2F2019%2F04%2F19%2FCodeforces_Round_553%2F</url>
    <content type="text"><![CDATA[F. Sonya and Informatics开启传送门 题目描述A girl named Sonya is studying in the scientific lyceum of the Kingdom of Kremland. The teacher of computer science (Sonya’s favorite subject!) invented a task for her. Given an array $a$ of length $n$, consisting only of the numbers $0$ and $1$, and the number $k$. Exactly $k$ times the following happens: Two numbers $i$ and $j$ are chosen equiprobable such that ($1\leq i&lt;j\leq n$). The numbers in the $i$ and $j$ positions are swapped. Sonya’s task is to find the probability that after all the operations are completed, the $a$ array will be sorted in non-decreasing order. She turned to you for help. Help Sonya solve this problem. It can be shown that the desired probability is either $0$ or it can be represented as $\frac{P}{Q}$, where $P$ and $Q$ are coprime integers and $Q\not\equiv0(mod\ 10^9+7)\textscA$. InputThe first line contains two integers $n$ and $k$ ($2\leq n\leq 100,1\leq k\leq 10^9$) — the length of the array $a$ and the number of operations. The second line contains $n$ integers $a_1,a_2,\dots,a_n$ ($0\leq a_i\leq 1$) — the description of the array $a$. OutputIf the desired probability is $0$, print $0$, otherwise print the value $P\cdot Q^{-1}$ ($mod\ 10^9+7$), where $P$ and $Q$ are defined above. Examplesinpus13 2 0 1 0 output1333333336 input25 1 1 1 1 0 0 output20 input36 4 1 0 0 1 1 0 output3968493834 NoteIn the first example, all possible variants of the final array $a$, after applying exactly two operations: $(0,1,0)$, $(0,0,1)$, $(1,0,0)$, $(1,0,0)$, $(0,1,0)$, $(0,0,1)$, $(0,0,1)$, $(1,0,0)$, $(0,1,0)$. Therefore, the answer is $\frac{3}{9}=\frac{1}{3}$. In the second example, the array will not be sorted in non-decreasing order after one operation, therefore the answer is 0. 题意给你一个长度为n的01序列，每次随机从中选择两个出来，交换一下，一共这样操作k次，问你经过k次交换之后，序列变成不降($00\dots 0011\dots 11$)的概率是？ 分析首先序列里面的$0$和$1$的数量是固定的，不妨设分别有$len_a$和$len_b$个。 也就是说在交换$k$次之后要保证前$len_a$个为$0$，后$len_b$个为$1$,如下$$\underbrace{00\dots 00}_{len_a} \underbrace{11\dots 11}_{len_b}$$ 然后我们分别统计前半段后半段$0$和$1$的数量，分别定义为$a_0,a_1,b_0,b_1$。例如$$\underbrace{\underbrace{\overbrace{01010000101110100}^{a_1=7}}_{a_0=10}}_{len_a=17}\underbrace{\underbrace{\overbrace{000101111101010}^{b_1=8}}_{b_0=7}}_{len_b=15}\tag{3}$$ 然后考虑一次交换产生的效果： $b_1$增加：$a_1$和$b_0$交换，使得后半段多了一个1，例如$$\underbrace{\underbrace{\overbrace{01010000101110000}^{a_1=6}}_{a_0=11}}_{len_a=17}\underbrace{\underbrace{\overbrace{010101111101010}^{b_1=9}}_{b_0=6}}_{len_b=15}\tag{2}$$ $b_1$减少：$a_0$和$b_1$交换，使得后半段少了一个1，例如$$\underbrace{\underbrace{\overbrace{01010000101110101}^{a_1=8}}_{a_0=9}}_{len_a=17}\underbrace{\underbrace{\overbrace{000101111101000}^{b_1=7}}_{b_0=8}}_{len_b=15}\tag{1}$$ 其他情况不影响$0$和$1$的数量。 然后多次操作和一次操作怎么联系起来呢？ 看到这个数据量$n = 100$，一次变多次，一个自然的想法就是快速幂啊啊啊啊啊啊啊啊啊啊。 然后就用上面的式子构造转移矩阵，然后快速幂，就能得到有解的方案数，然后除掉总方案数就行了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9+7;long long add(long long a,long long b)&#123;return (a+b)%mod;&#125;long long mul(long long a,long long b)&#123;return a*b%mod;&#125;long long qpow(long long a,long long b = mod-2)&#123;/*&#123;&#123;&#123;*/ long long ret = 1; while(b)&#123; if(b&amp;1) ret = mul(ret,a); a = mul(a,a); b&gt;&gt;=1; &#125; return ret;&#125;/*&#125;&#125;&#125;*/const int maxm = 105,inv_2 = qpow(2);long long C(long long a)&#123; return mul(inv_2,mul(a,add(a,mod-1)));&#125;int n,k,len_a,len_b;int num[maxm];struct matrix&#123; long long num[maxm][maxm];&#125;;matrix mul(matrix a,matrix b)&#123;/*&#123;&#123;&#123;*/ matrix c; memset(c.num,0,sizeof(c.num)); for(int i = 0;i&lt;=len_b;i++) for(int j = 0;j&lt;=len_b;j++) if(a.num[i][j]) for(int k = 0;k&lt;=len_b;k++) c.num[i][k] = add(c.num[i][k],mul(a.num[i][j],b.num[j][k])); return c;&#125;/*&#125;&#125;&#125;*/matrix qpow(matrix a,long long b)&#123; matrix e; for(int i = 0;i&lt;=len_b;i++) for(int j = 0;j&lt;=len_b;j++) e.num[i][j]=(i==j); while(b)&#123; if(b&amp;1) e = mul(e,a); a = mul(a,a); b&gt;&gt;=1; &#125; return e;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); int all = C(n); for(int i = 0;i&lt;n;i++)&#123;/*&#123;&#123;&#123;*/ scanf("%d",num+i); if(num[i]) len_b++; else len_a++; &#125;/*&#125;&#125;&#125;*/ matrix base; for(int i = 0;i&lt;=len_b;i++)&#123; for(int j = max(0,i-1);j&lt;=min(len_b,i+1);j++)&#123; int b1 = j,b0 = len_b - j,a0 = len_a - b0,a1 = len_a - a0; if(i==j-1) base.num[i][j] = a0*b1; else if(i==j+1) base.num[i][j] = a1*b0; else base.num[i][j] = add(all,add(mod - a0*b1,mod - a1*b0)); &#125; &#125; int cnt = 0; for(int i = len_a;i&lt;n;i++) if(num[i]) cnt++; matrix ano; memset(ano.num,0,sizeof(ano.num)); ano.num[cnt][0] = 1; base = mul(qpow(base,k),ano); long long ans = base.num[len_b][0]; ans = mul(ans,qpow(qpow(C(n),k))); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 552]]></title>
    <url>%2F2019%2F04%2F17%2FCodeforces_Round_552%2F</url>
    <content type="text"><![CDATA[F. Shovels Shop开启传送门 题目描述There are $n$ shovels in the nearby shop. The $i$-th shovel costs $a_i$ bourles. Misha has to buy exactly $k$ shovels. Each shovel can be bought no more than once. Misha can buy shovels by several purchases. During one purchase he can choose any subset of remaining (non-bought) shovels and buy this subset. There are also $m$ special offers in the shop. The $j$-th of them is given as a pair $(x_j,y_j)$, and it means that if Misha buys exactly $x_j$ shovels during one purchase then $y_j$ most cheapest of them are for free (i.e. he will not pay for $y_j$ most cheapest shovels during the current purchase). Misha can use any offer any (possibly, zero) number of times, but he cannot use more than one offer during one purchase (but he can buy shovels without using any offers). Your task is to calculate the minimum cost of buying $k$ shovels, if Misha buys them optimally. InputThe first line of the input contains three integers $n,m$ and $k$ ($1\leq n,m\leq 2\cdot 10^5,1\leq k\leq min(n,2000)$) - the number of shovels in the shop, the number of special offers and the number of shovels Misha has to buy, correspondingly. The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_1\leq 2\cdot 10^5$), where $a_i$ is the cost of the $i$-th shovel. The next $m$ lines contain special offers. The $j$-th of them is given as a pair of integers ($x_i,y_i$) ($1\leq y_i\leq x_i\leq n$) and means that if Misha buys exactly $x_i$ shovels during some purchase, then he can take $y_i$ most cheapest of them for free. OutputPrint one integer $-$ the minimum cost of buying $k$ shovels if Misha buys them optimally. Examplesinpus17 4 5 2 5 4 2 6 3 1 2 1 6 5 2 1 3 1 output17 input29 4 8 6 8 5 1 8 1 1 2 1 9 2 8 4 5 3 9 7 output217 input35 1 4 2 5 7 4 6 5 4 output317 NoteIn the first example Misha can buy shovels on positions 1 and 4 (both with costs 2) during the first purchase and get one of them for free using the first or the third special offer. And then he can buy shovels on positions 3 and 6 (with costs 4 and 3) during the second purchase and get the second one for free using the first or the third special offer. Then he can buy the shovel on a position 7 with cost 1. So the total cost is 4+2+1=7. In the second example Misha can buy shovels on positions 1, 2, 3, 4 and 8 (costs are 6, 8, 5, 1 and 2) and get three cheapest (with costs 5, 1 and 2) for free. And then he can buy shovels on positions 6, 7 and 9 (all with costs 1) without using any special offers. So the total cost is 6+8+1+1+1=17. In the third example Misha can buy four cheapest shovels without using any special offers and get the total cost 17. 题意zuhiul 都20了，还没有对象，然后家里人给安排了n个菇凉和他相亲，他需要挑出k个来相亲。相亲当然是男方请客，和每个妹子相亲的成本是不一样的，每个妹子都有一个固定成本，为了促进zuhiul相亲，家里人说，如果一次邀约了$x_i$个菇凉，家里就给报销这次相亲的所有菇凉中，成本最低的$y_i$个菇凉的花费，现在zuhiul想花最少的钱相完所有的亲，他最少要花多少钱呢？ 分析首先可以确定的是，我们一定找n个中最便宜的k个来相亲，因为如果不是这k个，我们一定可以合理的交换，得到一个不劣的解。 然后排序，干掉贵的那一部分。 那么如果不考虑报销的话，成本是固定的，所以剩下的问题就是怎么得到尽可能多的报销。 然后，显然是一个$n^2$的dp了。 我们可以预处理出，如果一次约j个女孩的话，可以省掉多少个女孩的费用，设为sub[j] 假设每个女孩的费用为values[i] 考虑转移，设dp[i]表示邀约前n个妹子的最小花费，那么可以得到$$dp[i] = \min_{j=1}^{i} (dp[i-j] + \sum_{k=i-j+sub[j]+1}^{i} values[k])$$ 然后对于后面的求和，可以搞一个前缀和来维护，复杂度$O(n^2)$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int maxk = 2005;const int maxm = 2e5+10;int sub[maxk];int n,m,k;int values[maxm];long long sum[maxm];int ans[maxk];long long cost[maxk];int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i = 1;i&lt;=n;i++) scanf("%d",values+i); sort(values+1,values+n+1); for(int i = 1;i&lt;=n;i++) sum[i] = sum[i-1]+values[i]; while(m--) &#123;/*&#123;&#123;&#123;*/ int a,b; scanf("%d%d",&amp;a,&amp;b); if(a&gt;k) continue; sub[a] = max(sub[a],b); &#125;/*&#125;&#125;&#125;*/ for(int i = 1;i&lt;=k;i++) sub[i] = max(sub[i],sub[i-1]); memset(cost,0x3f,sizeof(cost)); cost[0] = 0; for(int i = 1;i&lt;=k;i++)&#123; cost[i] = sum[i]; for(int j = 1;j&lt;=i;j++)&#123; cost[i] = min(cost[i],cost[i-j]+sum[i]-sum[i-j+sub[j]]); &#125; &#125; printf("%lld\n",cost[k]); return 0;&#125; G. Minimum Possible LCM开启传送门 题目描述You are given an array $a$ consisting of $n$ integers $a_1,a_2,\dots,a_n$. Your problem is to find such pair of indices $i,j (1\leq i&lt;j\leq n)$ that $lcm(a_i,a_j)$ is minimum possible. $lcm(x,y)$ is the least common multiple of $x$ and $y$ (minimum positive number such that both $x$ and $y$ are divisors of this number). ###Input The first line of the input contains one integer $n$ ($2\leq n\leq10^6$) — the number of elements in $a$. The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_i\leq 10^7$), where $a_i$ is the $i$-th element of $a$. OutputPrint two integers $i$ and $j$ ($1\leq i&lt;j\leq n$) such that the value of $lcm(a_i,a_j)$ is minimum among all valid pairs $i,j$. If there are multiple answers, you can print any. Examplesinpus15 2 4 8 3 6 output11 2 input25 5 2 11 3 7 output22 4 input36 2 5 10 1 10 2 output31 4 题意zuhiul有很多妹子，今天他想找两个妹子出去吃饭，每个妹子都有一个权值，他今天要花的钱等于这两个妹子权值的lcm，他想花尽可能少的钱，他该约哪两个妹子呢？ 分析我们考虑一下那种情况可以构成解。 首先对于重复的数据，我们可以干掉，因为相同值的lcm等于本身，所以我们可以把相同的权值干掉，然后剩下的数据都是不同的。 然后我们考虑权值都不相同的时候怎么构成解。 首先，这两个数肯定有一个gcd，哪怕gcd = 1，然后我们考虑一下，这$n*(n-1)&gt;&gt;1$这么多对数中，哪些对可以构成解，一个显而易见的想法就是，我们可以枚举gcd。 然后我们枚举这个gcd的所有倍数，这样能不重不漏的枚举出所有对数，然后我们考虑怎么减少枚举量。假设当前的$gcd=x$,因为前一步保证了没有相同的数据，所以我们只要找到最小的$i,j$使得$i\%x==0\&amp;\&amp;j\%x==0$，然后就用这两个数更新一下答案就行了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+10;int n;int app[maxm];struct p&#123; long long ans; int ind1,ind2; bool operator&lt;(const p a) const &#123; return ans&lt;a.ans; &#125;&#125;;int main()&#123; scanf("%d",&amp;n); p ans = &#123;1000000000000000000ll,-1,-1&#125;; for(int i = 1,buf;i&lt;=n;i++)&#123; scanf("%d",&amp;buf); if(app[buf]) ans = min(ans,&#123;buf,app[buf],i&#125;); app[buf] = i; &#125; for(int i = 1;i&lt;maxm;i++)&#123; int buf[3] = &#123;0&#125;; for(int j = i;j&lt;maxm;j+=i)&#123; if(app[j])&#123; buf[++buf[0]] = j; if(buf[0]==2)&#123; ans = min(ans,&#123;1ll*buf[1]*buf[2]/i,app[buf[1]],app[buf[2]]&#125;); break; &#125; &#125; &#125; &#125; if(ans.ind1&gt;ans.ind2) swap(ans.ind1,ans.ind2); printf("%d %d\n",ans.ind1,ans.ind2); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 551]]></title>
    <url>%2F2019%2F04%2F14%2FCodeforces_Round_551%2F</url>
    <content type="text"><![CDATA[A. Serval and Bus开启传送门 题目描述It is raining heavily. But this is the first day for Serval, who just became 3 years old, to go to the kindergarten. Unfortunately, he lives far from kindergarten, and his father is too busy to drive him there. The only choice for this poor little boy is to wait for a bus on this rainy day. Under such circumstances, the poor boy will use the first bus he sees no matter where it goes. If several buses come at the same time, he will choose one randomly. Serval will go to the bus station at time $t$, and there are $n$ bus routes which stop at this station. For the $i$-th bus route, the first bus arrives at time $s_i$ minutes, and each bus of this route comes $d_i$ minutes later than the previous one. As Serval’s best friend, you wonder which bus route will he get on. If several buses arrive at the same time, you can print any of them. InputThe first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station. Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route. OutputPrint one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them. Examplesinput12 2 6 4 9 5 output11 input25 5 3 3 2 5 5 6 4 9 6 1 output23 input33 7 2 2 2 3 2 4 output31 题意zuhiul很忙，他要约妹子，他一共有$n$个妹子要约，但是他$t$天后才有空，妹子们也不是每天都有时间，但是妹子都是周期性有时间，比如，第$i$个妹子，$s_i$天之后才有时间，而且每$d_i$天就会再次出线，现在问你，zuhiul最早会和哪个妹子约会，如果会和多个妹子约会，只需要输出任意一个妹子就行了。 分析只需要枚举每个妹子，然后看一下这个妹子什么时候最早可以邀约，然后算一下min就可以了 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 105;int s[maxm],d[maxm];int main()&#123; int n,t; cin&gt;&gt;n&gt;&gt;t; int ind,sum = 1e8; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;s[i]&gt;&gt;d[i]; if(s[i]&gt;=t)&#123; if(sum&gt;s[i])&#123; sum = s[i]; ind = i; &#125; &#125;else &#123; int nee = t-s[i]; if(nee%d[i]!=0) nee = (nee/d[i]+1)*d[i]; nee+=s[i]; if(nee&lt;sum)&#123; sum = nee; ind = i; &#125; &#125; &#125; cout&lt;&lt;ind&lt;&lt;endl; return 0;&#125; B. Serval and Toy Bricks开启传送门 题目描述Luckily, Serval got onto the right bus, and he came to the kindergarten on time. After coming to kindergarten, he found the toy bricks very funny. He has a special interest to create difficult problems for others to solve. This time, with many $1\times 1\times 1$ toy bricks, he builds up a 3-dimensional object. We can describe this object with a $n\times m$ matrix, such that in each cell $(i,j)$ , there are $h_{i,j}$ bricks standing on the top of each other. However, Serval doesn’t give you any $h_{i,j}$, and just give you the front view, left view, and the top view of this object, and he is now asking you to restore the object. Note that in the front view, there are $m$ columns, and in the $i$-th of them, the height is the maximum of $h_{1,i},h_{2,i},\dots,h_{n,i}$. It is similar for the left view, where there are $n$ columns. And in the top view, there is an 𝑛×𝑚 matrix $t_{i,j}$, where $t_{i,j}$ is 0 or 1. If $t_{i,j}$ equals 1, that means $h_{i,j}$&gt;0, otherwise, $h_{i,j}$=0. However, Serval is very lonely because others are bored about his unsolvable problems before, and refused to solve this one, although this time he promises there will be at least one object satisfying all the views. As his best friend, can you have a try? InputThe first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station. Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route. OutputPrint one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them. Examplesinput13 7 3 2 3 0 0 2 0 1 2 1 3 1 0 0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 output11 0 0 0 2 0 0 0 0 0 0 0 0 1 2 3 0 0 0 0 0 input24 5 5 3 5 2 0 4 4 2 5 4 0 0 0 0 1 1 0 1 0 0 0 1 0 0 0 1 1 1 0 0 output20 0 0 0 4 1 0 2 0 0 0 5 0 0 0 3 4 1 0 0 Note The graph above illustrates the object in the first example. The first graph illustrates the object in the example output for the second example, and the second graph shows the three-view drawing of it. 题意zuhiul和妹子玩游戏，妹子搭了一个积木，然后zuhiul猜积木长啥样，zuhiul必然不会，于是小姐姐放过了他，告诉了他现在的主视图，侧视图和俯视图，然后让zuhiul猜，zuhiul还是不会，但是为了脸面不能说不会，然后来问你了。你需要输出一种可能的解满足这个三视图。 分析告诉了主视图和左视图，相当于限制了最大值，告诉俯视图相当于告诉哪里可能有方块。然后枚举俯视图的每个位置，输出答案即可。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxm = 105;int hang[maxm],lie[maxm],nouse;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;nouse; for(int i = 0;i&lt;m;i++) cin&gt;&gt;hang[i]; for(int i = 0;i&lt;n;i++) cin&gt;&gt;lie[i]; for(int i = 0;i&lt;n;i++)&#123; for(int j = 0,a;j&lt;m;j++)&#123; cin&gt;&gt;a; if(a) cout&lt;&lt;min(lie[i],hang[j])&lt;&lt;' '; else cout&lt;&lt;0&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; C. Serval and Parenthesis Sequence开启传送门 题目描述Serval soon said goodbye to Japari kindergarten, and began his life in Japari Primary School. In his favorite math class, the teacher taught him the following interesting definitions. A parenthesis sequence is a string, containing only characters “(“ and “)”. A correct parenthesis sequence is a parenthesis sequence that can be transformed into a correct arithmetic expression by inserting characters “1” and “+” between the original characters of the sequence. For example, parenthesis sequences “()()”, “(())” are correct (the resulting expressions are: “(1+1)+(1+1)”, “((1+1)+1)”), while “)(“ and “)” are not. Note that the empty string is a correct parenthesis sequence by definition. We define that $|s|$ as the length of string $s$. A strict prefix $s[1\dots l]$ (1 ≤ $l$ &lt; $|s|$) of a string $s=s_{1}s_{2}\dots s_{|s|}$ is string $s_{1}s_{2}\dots s_{l}$. Note that the empty string and the whole string are not strict prefixes of any string by the definition. Having learned these definitions, he comes up with a new problem. He writes down a string $s$ containing only characters “(“, “)” and “?”. And what he is going to do, is to replace each of the “?” in $s$ independently by one of “(“ and “)” to make all strict prefixes of the new sequence not a correct parenthesis sequence, while the new sequence should be a correct parenthesis sequence. After all, he is just a primary school student so this problem is too hard for him to solve. As his best friend, can you help him to replace the question marks? If there are many solutions, any of them is acceptable. InputThe first line contains a single integer $|s|$ (1≤$|s|$≤$3\cdot 10^5$), the length of the string. The second line contains a string $s$, containing only “(“, “)” and “?”. OutputA single line contains a string representing the answer. If there are many solutions, any of them is acceptable. If there is no answer, print a single line containing “:(“ (without the quotes). Examplesinput16(????? output1(()()) input210(???(???(? output2:( NoteIt can be proved that there is no solution for the second sample, so print “:(“. 题意给你一堆左括号右括号和问号，问你能否把问号变成左括号或者右括号，使得这个变成一个括号匹配的序列，并且序列的任何前缀不是一个括号匹配序列。 分析显然对于后一个条件，我们只需要让最左边的左括号和最右边的右括号匹配就行了，然后中间是一个括号匹配序列就行了。然后填充的时候贪心的让左边填充左括号,右边填充右括号,然后check一下就行了. 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int len;const int maxm = 3e5+10;char que[maxm];void NO()&#123; cout&lt;&lt;":("&lt;&lt;endl; exit(0);&#125;int main()&#123; cin&gt;&gt;len&gt;&gt;que; if(len&amp;1) NO(); if(que[0]=='?') que[0] = '('; if(que[len-1]=='?') que[len-1] = ')'; if(que[0]!='(') NO(); if(que[len-1]!=')') NO(); if(len==2) &#123; puts("()"); return 0; &#125; int l = 0,r = 0,has = 0; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='(') l++; else if(que[i]==')') r++; else has++; &#125; if(abs(l-r)&gt;has) NO(); l = (len-2)/2 - l; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='?') &#123; if(l)&#123; que[i] = '('; l--; &#125;else que[i] = ')'; &#125; &#125; has = 0; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='(') has++; else has--; if(has&lt;0) NO(); &#125; puts(que); return 0;&#125; D. Serval and Rooted Tree开启传送门 题目描述Now Serval is a junior high school student in Japari Middle School, and he is still thrilled on math as before. As a talented boy in mathematics, he likes to play with numbers. This time, he wants to play with numbers on a rooted tree. A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a node $v$ is the last different from $v$ vertex on the path from the root to the vertex $v$. Children of vertex $v$ are all nodes for which $v$ is the parent. A vertex is a leaf if it has no children. The rooted tree Serval owns has $n$ nodes, node 1 is the root. Serval will write some numbers into all nodes of the tree. However, there are some restrictions. Each of the nodes except leaves has an operation max or min written in it, indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons, respectively. Assume that there are $k$ leaves in the tree. Serval wants to put integers $1,2,\dots,k$ to the $k$ leaves (each number should be used exactly once). He loves large numbers, so he wants to maximize the number in the root. As his best friend, can you help him? InputThe first line contains an integer $n$ (2≤$n$≤$3\cdot 10^5$), the size of the tree. The second line contains $n$ integers, the $i$-th of them represents the operation in the node $i$. 0 represents min and 1 represents max. If the node is a leaf, there is still a number of 0 or 1, but you can ignore it. The third line contains $n-1$ integers $f_2,f_3,\dots,f_n$ (1≤$f_i≤$i-1$), where $f_i$ represents the parent of the node $i$. OutputOutput one integer $-$ the maximum possible number in the root of the tree. Examplesinput16 1 0 1 1 0 1 1 2 2 2 2 output11 input25 1 0 1 0 1 1 1 1 1 output24 input38 1 0 0 1 0 1 1 0 1 1 2 2 3 3 3 output34 input49 1 1 0 0 1 0 1 0 1 1 1 2 2 3 3 4 4 output45 NotePictures below explain the examples. The numbers written in the middle of the nodes are their indices, and the numbers written on the top are the numbers written in the nodes. In the first example, no matter how you arrange the numbers, the answer is $1$. In the second example, no matter how you arrange the numbers, the answer is $4$. In the third example, one of the best solution to achieve $4$ is to arrange $4$ and $5$ to nodes $4$ and $5$. In the fourth example, the best solution is to arrange $5$ to node $5$. 题意给你一颗有根树，每个非叶节点上有一个函数，可能为min或者max，你需要在k个叶节点上填上$1,2,\dots,k$,使得经过非叶节点的操作之后，根节点的值最大。 分析显然是要分析函数的作用。 如果是取max，说明所有的子节点中，我们可以把某一个子节点的值取到最大，然后其他的节点全塞垃圾值。 如果是取min，说明所有子节点都起作用，说明我们对于每个子节点都要尽可能的大。 然后就可以得到，max的策略是，找到孙子节点最少的子节点，填充大值，min的策略是，对所有子节点求和。 然后这样得到的就是所有对答案有贡献的节点数，然后用总结点数减去贡献节点数就是答案。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 3e5+10;int n,cnt;int maxn[maxm];vector&lt;int&gt; son[maxm];int dfs(int a)&#123; if(son[a].size()==0)&#123; cnt++; return 1; &#125; if(maxn[a])&#123; int minm = 1e8; for(int i:son[a]) minm = min(minm,dfs(i)); return minm; &#125; int sum = 0; for(int i:son[a]) sum+=dfs(i); return sum;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++) cin&gt;&gt;maxn[i]; for(int i = 2,pre;i&lt;=n;i++)&#123; cin&gt;&gt;pre; son[pre].push_back(i); &#125; int nouse = dfs(1); cout&lt;&lt;cnt - nouse+1&lt;&lt;endl; return 0;&#125; E. Serval and Snake开启传送门 题目描述This is an interactive problem. Now Serval is a senior high school student in Japari Middle School. However, on the way to the school, he must go across a pond, in which there is a dangerous snake. The pond can be represented as a $n\times n$ grid. The snake has a head and a tail in different cells, and its body is a series of adjacent cells connecting the head and the tail without self-intersecting. If Serval hits its head or tail, the snake will bite him and he will die. Luckily, he has a special device which can answer the following question: you can pick a rectangle, it will tell you the number of times one needs to cross the border of the rectangle walking cell by cell along the snake from the head to the tail. The pictures below show a possible snake and a possible query to it, which will get an answer of $4$. Today Serval got up too late and only have time to make 2019 queries. As his best friend, can you help him find the positions of the head and the tail? Note that two cells are adjacent if and only if they have a common edge in the grid, and a snake can have a body of length 0, that means it only has adjacent head and tail. Also note that the snake is sleeping, so it won’t move while Serval using his device. And what’s obvious is that the snake position does not depend on your queries. InputThe first line contains a single integer $n$ (2≤$n$≤1000) $-$ the size of the grid. OutputWhen you are ready to answer, you should print ! x1 y1 x2 y2, where $(x_1,y_1)$ represents the position of the head and $(x_2,y_2)$ represents the position of the tail. You can print head and tail in any order. InteractionTo make a query, you should print ? x1 y1 x2 y2 (1≤$x_1$≤$x_2$≤𝑛, 1≤$y_1$≤$y_2$≤$n$), representing a rectangle consisting of all cells $(x,y)$ such that $x_1$≤$x$≤$x_2$ and $y_1$≤$y$≤$y_2$. You will get a single integer as the answer. After printing a query, do not forget to output the end of line and flush the output, otherwise you will get Idleness limit exceeded. To do this, use: fflush(stdout) or cout.flush() in C++; System.out.flush() in Java; flush(output) in Pascal; stdout.flush() in Python;see documentation for other languages. Answer $-1$ instead of a valid answer means that you made an invalid query or exceeded the maximum number of queries. Exit immediately after receiving $-1$ and you will see Wrong answer verdict. Otherwise you can get an arbitrary verdict because your solution will continue to read from a closed stream. If your program cannot find out the head and tail of the snake correctly, you will also get a Wrong Answer verdict. HacksTo make a hack, print a single integer $n$ (2≤$n$≤1000) in the first line, indicating the size of the grid. Then print an integer $k$ (2≤$k$≤𝑛2) in the second line, indicating the length of the snake. In the next $k$ lines, print $k$ pairs of integers $x_i,y_i$ (1≤$x_i,y_i$≤𝑛), each pair in a single line, indicating the $i$-th cell of snake, such that the adjacent pairs are adjacent, and all $k$ pairs are distinct. Examplesinput12 1 0 0 output1? 1 1 1 1 ? 1 2 1 2 ? 2 2 2 2 ! 1 1 2 1 input23 2 0 output2? 2 2 2 2 ? 2 1 2 3 ! 2 1 2 3 Note The pictures above show our queries and the answers in the first example. We first made a query for (1,1) and got an answer 1, then found that it must be connected to exactly one other cell. Then we made a query for (1,2) and got an answer of 0, then knew that the snake never entered it. So the cell connected to (1,1) must be (2,1). Then we made a query for (2,2) and got an answer 0, then knew that it never entered (2,2) as well. So the snake cannot leave (2,1), which implies that the answer is (1,1) and (2,1). The pictures above show our queries and the answers in the second example. By making query to (2,2) and receiving 2, we found that the snake occupies (2,2). And by making query to rectangle from (2,1) to (2,3) and receiving answer 0, we knew that it never goes out of the rectangle from (2,1) to (2,3). Since the first answer is 2, both (2,1) and (2,3) must be occupied but none of others, so the answer is (2,1) and (2,3). 题意现在有一条蛇在一个方格图中，你可以给出不超过2019次询问，每次询问一个矩形，回答是，你用这个矩形去切蛇，可以得到这个蛇被切了多少刀，现在问你蛇头和蛇尾的位置。 分析首先我们可以观察到，当一个矩形切下去之后发现切了奇数刀，那么可以有必然存在一个头或者尾在矩形中。 然后我们可以用$(n-1)&lt;&lt;1$次询问得到所有的行和列对应的切的次数。 然后可以证明的是，所有的数据中必然存在奇数。反证法易得。 然后可以证明奇数对应的行或者列左右必然存在头或者尾。 所以可以得到一个很直观的$O(6n)$的做法，$2n$用来寻找，剩下的$4n$来搜索答案。但是这必然会超过2019. 考虑哪些步骤可以优化？ $2n$不可优化，必然就只能优化搜索过程。 需要注意的是，可能存在行或者列不存在奇数的情况，稍微分析可以得到这种情况的特点了，头和尾在同一行或者同一列中。 我们考虑到，我们只用考虑奇偶的情况，而不用考虑具体值。 因为奇偶的加减特性，我们可以二分这个答案。 除此之外，如果行和列都有奇数值，那么可以得到行和列对应的四个点中，两个点是答案，枚举任何一个就可以得到答案。 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1005;int n;vector&lt;int&gt; r,c;int que(int u,int d,int l,int r)&#123; printf("? %d %d %d %d\n",u,l,d,r); fflush(stdout); int nouse; scanf("%d",&amp;nouse); return nouse&amp;1;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1;i&lt;=n;i++) if(que(i,i,1,n)) r.push_back(i); for(int i = 1;i&lt;=n;i++) if(que(1,n,i,i)) c.push_back(i); assert(r.size()+c.size()&gt;=2); if(c.empty()||r.empty())&#123; bool change = false; if(c.empty()) &#123; swap(r,c); change = true; &#125; int l = 1,r = n; while(l&lt;r)&#123; int mid = l+r&gt;&gt;1; int upper = l,down = mid,left = c[0],right = c[0]; if(change) swap(left,upper),swap(down,right); if(que(upper,down,left,right)) r = mid; else l = mid+1; &#125; if(!change) printf("! %d %d %d %d\n",l,c[1],l,c[0]); else printf("! %d %d %d %d\n",c[0],l,c[1],l); fflush(stdout); return 0; &#125; if(que(r[0],r[0],c[0],c[0])) printf("! %d %d %d %d\n",r[0],c[0],r[1],c[1]); else printf("! %d %d %d %d\n",r[0],c[1],r[1],c[0]); fflush(stdout); return 0;&#125; F. Serval and Bonus Problem开启传送门 题目描述Getting closer and closer to a mathematician, Serval becomes a university student on math major in Japari University. On the Calculus class, his teacher taught him how to calculate the expected length of a random subsegment of a given segment. Then he left a bonus problem as homework, with the award of a garage kit from IOI. The bonus is to extend this problem to the general case as follows. You are given a segment with length $l$. We randomly choose $n$ segments by choosing two points (maybe with non-integer coordinates) from the given segment equiprobably and the interval between the two points forms a segment. You are given the number of random segments $n$, and another integer $k$. The $2n$ endpoints of the chosen segments split the segment into ($2n+1$) intervals. Your task is to calculate the expected total length of those intervals that are covered by at least $k$ segments of the $n$ random segments. You should find the answer modulo $998244353$. InputFirst line contains three space-separated positive integers 𝑛, 𝑘 and 𝑙 ($1\leq k\leq n\leq 2000,1\leq l\leq 10^9$). OutputOutput one integer — the expected total length of all the intervals covered by at least $k$ segments of the $n$ random segments modulo $998244353$. Formally, let $M=998244353$. It can be shown that the answer can be expressed as an irreducible fraction $\frac{p}{q}$, where $p$ and $q$ are integers and $q\not\equiv0(modM)$. Output the integer equal to $p\cdot q^{-1}mod\ M$. In other words, output such an integer $x$ that $0\leq x&lt;M$ and $x\cdot q\equiv p(mod\ M)$. Examplesinpus11 1 1 output1332748118 input26 2 1 output2760234711 input37 5 3 output3223383352 input497 31 9984524 output4267137618 NoteIn the first example, the expected total length is $\int_0^1 \int_0^1 |x-y|\ dx\ dy = \frac{1}{3} $, and $\frac{1}{3}$ modulo $998244353$ is $332748118$. 题意长度为l的线段，随机选取n个线段，线段中至少被n个线段中k个线段覆盖的长度期望。 分析说实话我当时没做出来，看了题解才知道怎么做的，所以强烈建议看官方的题解。我这里也贴出来，感兴趣的可以看一下。 Without loss of generality, assume that $l$=1. For a segment covering, the total length of the legal intervals is the probability that we choose another point $P$ on this segment randomly such that it is in the legal intervals. Since all $2n+1$ points ($P$ and the endpoints of each segment) are chosen randomly and independently, we only need to find the probability that point $P$ is in the legal intervals. Note that only the order of these $2n+1$ points make sense. Because the points are chosen in the segment, the probability that some of them coincide is $0$, so we can assume that all points do not coincide. Now the problem is, how to calculate the number of arrangements that $P$ is between at least $k$ pairs of endpoints. It can be solved by dynamic programming in time complexity of $O(n^2)$. We define $f(i,j,x)$ as the number of arrangements for the first $i$ positions, with $j$ points haven’t been matched, and $P$ appeared $x$ times (obviously $x=0$ or $1$). So we can get three different types of transition for the $i$-th position below: Place $P$ at $i$-th position (if $j\geq k$): $f(i-1,j,0)\rightarrow f(i,j,1)$ Start a new segment (if $i+j+x&lt;2n$): $f(i-1,j-1,x)\rightarrow f(i,j,x)$ Match a started segment, note that we have 𝑗 choices of segments:$f(i-1,j+1,x)\times(j+1)\rightarrow f(i,j,x)$ Then $f(2n+1,0,1)$ is the number of legal arrangements. Obviously, the total number of arrangements is $(2n+1)!$. However, there are 𝑛 pairs of endpoints whose indices can be swapped, and the indices 𝑛 segments can be rearranged. So the final answer is $\frac{f(2n+1,0,1)\times n!\times 2^n}{(2n+1)!}$. 可能是受了题解的影响，后来也没想出来其他解法。 这里讲一下题解怎么做的。 首先我们可以发现，长度和答案成正比，也就是说如果长度为1的时候答案是a，那么长度为2的时候答案就是2a%mod. 然后我们不妨设长度为1，最后答案乘上l就行了。 然后因为我们要找到至少被线段覆盖k次的所有点，所以我们不如加上一个虚拟点，这样就一共有了$(n&lt;&lt;1|1)$个点，然后需要判断这个虚拟点被多少条线段覆盖了，如果覆盖次数超过k次，就说明可以统计进答案。然后就可以发现，所有点是随机取的，所以我们假设所有点不会重合，那么所有点就可以离散成一个序列。然后就可以统计k的覆盖次数。 接下来就是dp，我们设$dp[i][j][flag]$表示序列中前i个点，其中到目前为止有j条线段左节点出线了，但是右节点没有出现，也就是说当前这个点被覆盖了j次，flag表示虚拟点是否出现了。然后考虑转移： 当前节点是虚拟节点 如果这个需要统计进入答案，也就是说明当前节点需要被覆盖k次及以上，所以 $j\geq k$ $dp[i][j][1]+=dp[i-1][j][0]$ 当前节点是一个线段的左端点 也就是说左节点数量增加，被覆盖次数增加，但是不会影响虚拟节点的状态 $dp[i][j+1][flag]+=dp[i-1][j][flag]$ 当前节点是一个线段的右端点 也就是说右节点数量增加，被覆盖次数减少，但是不会影响虚拟节点的状态,注意右端点可能会有j个可能 $dp[i][j-1][flag]+=dp[i-1][j][flag]*j$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const long long mod = 998244353;const int maxm = 2345;inline long long add(long long a,long long b)&#123;return (a+b)%mod;&#125;inline long long mul(long long a,long long b)&#123;return a*b%mod;&#125;inline long long fac(long long a) &#123;return a==1?1:mul(a,fac(a-1));&#125;inline long long qpow(long long a,long long b = mod-2)&#123;/*&#123;&#123;&#123;*/ long long ret = 1; while(b)&#123; if(b&amp;1) ret = mul(ret,a); a = mul(a,a); b&gt;&gt;=1; &#125; return ret;&#125;/*&#125;&#125;&#125;*/long long n,k,l;long long dp[maxm&lt;&lt;1][maxm][2];int main()&#123; scanf("%lld%lld%lld",&amp;n,&amp;k,&amp;l); dp[0][0][0] = 1; for(int i = 1;i&lt;=(n&lt;&lt;1|1);i++) for(int j = 0;j&lt;=n;j++)&#123; if(j&gt;=k) dp[i][j][1] = add(dp[i][j][1],dp[i-1][j][0]); for(int flag = 0;flag&lt;2;flag++) if(dp[i-1][j][flag])&#123; if(j) dp[i][j-1][flag] = add(dp[i][j-1][flag],mul(dp[i-1][j][flag],j)); if(i+(j+1)-(1-flag)&lt;=(n&lt;&lt;1|1)) dp[i][j+1][flag] = add(dp[i][j+1][flag],dp[i-1][j][flag]); &#125; &#125; int ans = mul(dp[n&lt;&lt;1|1][0][1],qpow(2,n)); ans = mul(mul(ans,l),mul(fac(n),qpow(fac(n&lt;&lt;1|1)))); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[factorio]]></title>
    <url>%2F2019%2F03%2F31%2Ffactorio%2F</url>
    <content type="text"><![CDATA[level 1]]></content>
      <tags>
        <tag>factorio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试]]></title>
    <url>%2F2019%2F02%2F21%2Fgluten%2F</url>
    <content type="text"><![CDATA[头条面试回忆录废话这两天参加了头条的面试,总体来说,感觉不错,公司效率很高… 一面当天上午投的简历,下午让我第二天面试,时间很紧,很多东西都没来得及准备…. 1.自我介绍一下(balabalabala) 2.学过操作系统和计算机网络吗?(网络学了,操作系统下学期开,其实我很想说操作系统自学了,您可以问……) 3.说一下tcp和udp的区别(balabalabala) 2.1那个快?为什么?(udp快,因为三次握手四次挥手会占用cpu时间?) 2.2去掉三次握手四次挥手那个快?(不知道) 4.写两个题吧 3.1 给你一个数字矩阵,每行每列都是增序,问你某个值是否存在(剑指offer原题,我100%做过,但是我忘了怎么做的,只知道从角上枚举,然后先说了一下从右下角枚举,说不对,然后换成右上角,没啥问题….) 3.2 给一个矩阵,四联通,找到一个最长上升子序列(简单dp,写完就过了) 3.2.1 能把路径输出一下吗?(记录前驱….) 3.2.2 能把前驱数组去掉吗?(可以,瞎搞一下就行了…..) 4.闲聊(emmmmm) 二面二面感觉更严格,感觉答的不好….. 1.自我介绍(balabalabala) 2.有什么数据结构可以做到查询和插入都是o(1)的?(第一反映,显然不可能啊,这不是不可调和的矛盾吗?面试官说:知道hash吗?哇,感觉被鄙视了,确实傻了) 3.给你n个有序链表(从大到小),怎么找到这n个链表的前K大,(先取出每个链表的最大,然后建最大堆,然后每次取出堆顶,然后取出对应链表的后续元素,加入堆,然后一次操作,直到有k个元素) 3.1 复杂度多少?(o(n+klogn)) 3.2 n是怎么来的?(建堆时间) 3.3 能证明一下吗?(假设堆是用类树状数组的结构维护,先把数据随机放进来,然后每次从大到小枚举一个下标ind,比较当前位置ind和(ind&gt;&gt;1),然后根据大小关系交换一下,可以证明每次都是两个数比较,并且最多有n次比较,所以o(n)) 4.写两个题吧 2.1 给你一个字典,给你一个询问串,问你能否用字典中的某些单词(每个单词只能用一次),构成询问串.(想复杂了,一直在想怎么优化,后来才知道直接暴力就行,我当时还傻乎乎的用了lower_bound企图缩小范围,结果返回结果还死活不对,搞了30分钟才搞定,感觉要凉) 2.2 可能是看我太菜,没问第二道题,感觉好像对我不感兴趣就溜了??? 三面不知道自己怎么活过二面的……. 1.聊天,纯聊天,可能是怕我太紧张,感觉面试官很好 2.提出自我介绍被拒绝……. 3.简单说一下项目,(也不用详细说,因为项目就是很简单……) 4.有啥很厉害的技术要说明的吗?(没有……) 5.我们写两个题吧 5.1 给你一个无根树,让你转化成有根树,使得树的深度最小(一眼直径的中点,写了一下,好像有点问题,我问他我是调一下还是?他说不用调了,想法没啥大问题) 5.2 初始位置0,速度1,两个操作 1.position+=spead,spead*=2 2.spead&gt;0,spead = -1;else spead = 1 问你最少操作几次,使得,从0到x 我第一想法二进制拆分,然后瞎搞,写了一下,没啥大问题 复杂度?(32^2?) 怎么证明,我说每次考虑最高位的1,然后瞎搞一下balabalabala 说正解是dp,比我复杂,emmmmm…….. 6.浏览器输入baidu.com会发生啥?(balabalabala,昨天看过,不知道说的对不对) 7.你有啥觉得自己的技术亮点要说吗?(感觉瞎bb都能加分,但是我怂,老老实实说自己没啥技能点……) 8.你想过一些大的厂商,背后的技术部门都是怎么运行的吗?(不知道……..) 9.面试官可能觉得没啥聊的了,就放我走了…… 总结总的来说,面试官还是很和蔼的,有些问题还会引导你向正确的方向思考,问题都不难,好好准备应该好过,就这样吧…….]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 276 Primitive Triangles]]></title>
    <url>%2F2019%2F01%2F17%2FPE276%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Consider the triangles with integer sides $a, b$ and $c$ with $a \leq b \leq c$.An integer sided triangle $(a,b,c)$ is called primitive if $gcd(a,b,c)=1$.How many primitive integer sided triangles exist with a perimeter not exceeding $10,000,000$? 题意问你存在多少个边长是整数的三角形,并且满足三边长的gcd为1,周长不超过$1e7$. 分析有一个比较奇奇怪怪的结论 我直接把结论搬过来$\dots$ \begin{eqnarray} F(n) = \begin{cases} \lfloor\frac{(n+3)^2+24}{48}\rfloor\ \ \ \ &amp;n\ \ is\ \ odd\\ \lfloor\frac{n^2+24}{48}\rfloor\ \ \ \ &amp;n\ \ is\ \ even\ \end{cases}\end{eqnarray} 这个结论说的是,周长为$n$的边长都是整数的三角形的数量.然后我们可以预处理出所有的周长为$n$的数量出来,然后我们怎么保证gcd呢,比较好想的就是容斥,我们容斥掉所有gcd不是1的就行了,也就是说我们用周长为$2\cdot n,3\cdot n,\dots$的减去周长为$n$的就行啦啦啦 给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+1;long long num[maxm];long long get(long long a)&#123; if(a&amp;1) return ((a+3)*(a+3)+24)/48; return (a*a+24)/48;&#125;void init()&#123;//预处理出每个周长对应的三角形数量,容斥得到正确的数量 for(int i = 1;i&lt;maxm;i++) num[i] = get(i); for(int i = 1;i&lt;maxm;i++) for(int j = i&lt;&lt;1;j&lt;maxm;j+=i) num[j]-=num[i];&#125;int main()&#123; init(); long long ans = 0; for(int i = 1;i&lt;maxm;i++) ans+=num[i]; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 643 2-Friendly]]></title>
    <url>%2F2019%2F01%2F09%2FPE643%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Two positive integers $a$ and $b$ are 2-friendly when $gcd(a,b)=2^t,t&gt;0$. For example, $24$ and $40$ are 2-friendly because $gcd(24,40)=8=2^3$ while $24$ and $36$ are not because $gcd(24,36)=12=2^2\cdot 3$ not a power of $2$. Let $f(n)$ be the number of pairs, $(p,q)$, of positive integers with $1\leq p&lt;q\leq n$ such that $p$ and $q$ are 2-friendly. You are given $f(10^2)=1031$ and $f(10^6)=321418433$ modulo $1000000007$ . Find $f(10^{11})$ modulo $1000000007$. 题意问你所有满足$1\leq p&lt;q\leq 1e11$,并且$gcd(p,q)==2^t$的对数 分析显然可以对于每个$2^t$单独考虑,不妨设$2^t = x$,可以得到 $$ans = \sum_{i=1}^{upper/x} \varphi(i)$$ 然后显然是各种筛法搞一下,我这里用的杜教筛,然后稍微推一推就可以得到 $$s(m) = \frac{m\ast (m+1)}{2} - \sum_{d=2}^{m} s(\lfloor \frac{m}{d} \rfloor)$$ 然后分块一下,递归搞下去就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const long long upper = 1e11;const int maxm = 2e7+10;const int mod = 1e9+7;int add(int a,int b)&#123;return (a+b)%mod;&#125;int mul(long long a,long long b)&#123;return (a%mod)*(b%mod)%mod;&#125;int inv(long long a)&#123; return a==1?1:mul(mod-mod/a,inv(mod%a)); &#125;int inv2 = inv(2);bool p[maxm];int pri[maxm];//质数int phi[maxm];//欧拉函数前缀和void init()&#123; phi[1] = 1; for(int i =2;i&lt;maxm;i++)&#123; if(!p[i])&#123; pri[++pri[0]] = i; phi[i] = i-1; &#125; for(int j = 1;j&lt;=pri[0]&amp;&amp;i*pri[j]&lt;maxm;j++)&#123; p[i*pri[j]] = true; if(i%pri[j]) phi[i*pri[j]] = phi[i]*(pri[j]-1); else&#123; phi[i*pri[j]] = phi[i]*pri[j]; break; &#125; &#125; &#125; for(int i = 2;i&lt;maxm;i++) phi[i] = add(phi[i],phi[i-1]);//因为只会用到前缀和,所以我们直接预处理成前缀和&#125;map&lt;long long,int&gt; mp;int solve(long long m)&#123; if(m&lt;maxm) return phi[m];//查表 if(mp[m]) return mp[m];//记忆化 int ret = mul(m,mul(m+1,inv2)); for(long long l = 2,r;l&lt;=m;l = r+1) &#123;//分块 r = m/(m/l); ret = add(ret,mod-mul(solve(m/l),r-l+1)); &#125; return mp[m] = ret;&#125;int main()&#123; init(); int ans = 0; for(long long x = 2;x&lt;=upper;x&lt;&lt;=1) &#123;//单独统计每一个2的幂 cout&lt;&lt;x&lt;&lt;endl; ans = add(ans,solve(upper/x)); ans = add(ans,mod-1); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 222 Sphere Packing]]></title>
    <url>%2F2019%2F01%2F04%2FPE222%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 What is the length of the shortest pipe, of internal radius $50$mm, that can fully contain $21$ balls of radii $30$mm, $31$mm, …, $50$mm? Give your answer in micrometres ($10^{-6}$ m) rounded to the nearest integer. 题意让你在一个内径$50$的圆管里塞$21$个内径分别为$31-50$的小球,问你圆管最短是多少 分析比较显然是dp 考虑dp状态:dp[i][j]表示选择小球对应的集合为j,并且用第i个小球结尾,然后我们转移的时候就直接添加一个小球,对于剩余的小球枚举一个结尾,取最优解就行了 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 21;double ans[maxm][1&lt;&lt;maxm];int num[maxm+10];double cal(int a,int b)&#123;//得到两个小球的距离 int t = a+b+60; return 10*sqrt(t*2-100);&#125;int main()&#123; for(int i = 0;i&lt;maxm;i++) for(int j = 0;j&lt;(1&lt;&lt;maxm);j++) ans[i][j] = 1e8; for(int s = 0;s&lt;(1&lt;&lt;maxm);s++) for(int i = 0;i&lt;maxm;i++)&#123; if(s==0)&#123;//初值条件 ans[i][1&lt;&lt;i] = i+30; continue; &#125; if((s &gt;&gt; i &amp; 1)==1) continue; int t = s|(1&lt;&lt;i);//用S来扩展t for(int j = 0;j&lt;maxm;j++) if(s&gt;&gt;j&amp;1) ans[i][t] = min(ans[i][t],ans[j][s]+cal(i,j)); &#125; double rans = 1e8; for(int i = 0;i&lt;maxm;i++) rans = min(rans,ans[i][(1&lt;&lt;maxm)-1]+i+30); printf("%.0f\n",rans*1000); return 0;&#125;]]></content>
      <tags>
        <tag>PE</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 122 Efficient exponentiation]]></title>
    <url>%2F2019%2F01%2F02%2FPE122%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The most naive way of computing $n^{15}$ requires fourteen multiplications: $n \times n \times \dots \times n = n^{15}$ But using a “binary” method you can compute it in six multiplications: \begin{eqnarray}n \times n &amp;= n^2\\n^2 \times n^2 &amp;= n^4\\n^4 \times n^4 &amp;= n^8\\n^8 \times n^4 &amp;= n^{12}\\n^{12} \times n^2 &amp;= n^{14}\\n^{14} \times n &amp;= n^{15}\\\end{eqnarray} However it is yet possible to compute it in only five multiplications: \begin{eqnarray}n \times n &amp;= n^2\\n^2 \times n &amp;= n^3\\n^3 \times n^3 &amp;= n^6\\n^6 \times n^6 &amp;= n^{12}\\n^{12} \times n^3 &amp;= n^{15}\\\end{eqnarray} We shall define $m(k)$ to be the minimum number of multiplications to compute $n^k$; for example $m(15) = 5$. For $1 \leq k \leq 200$, find $\sum m(k)$. 题意我们知道快速计算一个数的幂次有各种不同的方法,快速幂只是其中一种而且不是最快的,然后问你对于1~200的幂次来说,最少需要几次乘法操作. 分析有一个wiki讲的就是这个问题,可以看一看…. 我们可以发现,对于所有幂次来说,我们按照最后一步操作的数来构成他的前驱,然后我们会发现他是一棵树,然后我们直接构造出这颗树出来,就是最优答案….. 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s[222];void cal(int a)&#123; int now = 1e8,ind = 0; for(int i = 1;i&lt;=a;i++)&#123;//枚举每一个比他小的数,看是否可以作为他的前驱 if(s[i].size()+1&gt;=now) continue;//如果不能优化解就不继续搜索 for(int x:s[i])//枚举每一个前驱的子元素 if(s[i].find(a-x)!=s[i].end())&#123;//如果能构成a now = s[i].size()+1;//更新解 ind = i; break; &#125; &#125; for(int i:s[ind]) s[a].insert(i);//保存路径 s[a].insert(a);&#125;int main()&#123; s[1].insert(1); for(int i = 2;i&lt;=200;i++) cal(i); int ans = 0; for(int i = 1;i&lt;=200;i++) ans+=s[i].size()-1;//要把里面的1剪掉,因为合成1不要代价 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 143 Investigating the Torricelli point of a triangle]]></title>
    <url>%2F2018%2F12%2F28%2FPE143%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Let ABC be a triangle with all interior angles being less than $120$ degrees. Let $X$ be any point inside the triangle and let $XA = p, XC = q$, and $XB = r$. Fermat challenged Torricelli to find the position of X such that $p + q + r$ was minimised. Torricelli was able to prove that if equilateral triangles AOB, BNC and AMC are constructed on each side of triangle ABC, the circumscribed circles of AOB, BNC, and AMC will intersect at a single point, T, inside the triangle. Moreover he proved that T, called the Torricelli/Fermat point, minimises $p + q + r$. Even more remarkable, it can be shown that when the sum is minimised, $AN = BM = CO = p + q + r$ and that AN, BM and CO also intersect at T. If the sum is minimised and a, b, c, p, q and r are all positive integers we shall call triangle ABC a Torricelli triangle. For example, $a = 399, b = 455, c = 511$ is an example of a Torricelli triangle, with $p + q + r = 784$. Find the sum of all distinct values of $p + q + r ≤ 120000$ for Torricelli triangles. 题意就是三个角都小于120度的三角形存在费马点,然后让你找到所有这样的三角形,使得图上对应的六条边都是整数,其中$T$就是费马点.然后你要找到所有$p+q+r$不同的所有三角形,然后把$p+q+r$求和. 分析对于每一个圆来说,因为里面的三角形是对边三角形,然后因为$T$在园上,于是有$T$对应的角大小一定是$180-60 = 120$度,然后同理可得,三个角都是$120$度,然后我们运用余弦定理可以得到$p^2+q^2+pq=b^2$,因为我们只要$p+q+r$不同的解,所以我们不妨设$p&gt;=q&gt;=r$,因为三个角都是$120$度,所以余弦定理都成立,所以我们可以得到 \begin{eqnarray}q^2+r^2+qr &amp;= a^2\\p^2+q^2+pq &amp;= b^2\\p^2+r^2+pr &amp;= c^2\\p&gt;=q&gt;=r\\\end{eqnarray} 然后我们对于每对关系,可以显然发现都应该是类似的,然后我们可以存下来每个关系,然后暴搜就行了,emmmmmm$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int upper = 1.2e5;set&lt;int&gt; to[upper+10];bool ans[upper&lt;&lt;2];int main()&#123; for(long long i = 1;i&lt;=upper;i++)&#123; for(long long j = min(upper-i,i);j&gt;=1;j--)&#123; long long x = i*i+j*j+i*j; long long y = sqrt(x); if(y*y==x) to[i].insert(j); &#125; if(i%10==0) cout&lt;&lt;i&lt;&lt;'\n'; &#125; for(int i = 1;i&lt;=upper;i++)&#123; for(int j:to[i])&#123; for(int k:to[j])&#123; if(i+j+k&gt;upper) continue; if(to[i].count(k))&#123; ans[i+j+k] = true; &#125; &#125; &#125; &#125; int rans = 0; for(int i = 1;i&lt;=upper;i++) if(ans[i]) rans+=i; cout&lt;&lt;rans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcd and fibonacii]]></title>
    <url>%2F2018%2F12%2F28%2Fgcd_fibonacci%2F</url>
    <content type="text"><![CDATA[前两天看到一个比较奇怪的公式,然后队友让证明一下,公式如下 $$gcd(f_i,f_j) = f_{gcd(i,j)}$$ 下面给出证明 $gcd(f_i,f_{i-1}) = 1$\begin{eqnarray}gcd(f_i,f_{i-1}) &amp;=&amp; gcd(f_{i-1}+f_{i-2},f_{i-1})\\&amp;=&amp; gcd(f_{i-2},f_{i-1})\\&amp;=&amp; gcd(f_{i-3},f_{i-2})\\&amp;=&amp; \dots\\&amp;=&amp; gcd(f_1,f_2)\\&amp;=&amp; 1\\\end{eqnarray} $f_{i+j} = f_{i-1}\cdot f_j + f_i\cdot f_{j+1}$首先,$j = 1$时有 $f_{i+1} = f_{i-1}+f_i$ 显然成立, 当$j = 2$时有 \begin{eqnarray}f_{i+2} &amp;=&amp; f_{i+1} + f_{i}\\&amp;=&amp; (f_{i}+f_{i-1}) + f_{i}\\&amp;=&amp; f_{i-1} \cdot 1 + f_{i} \cdot 2\\&amp;=&amp; f_{i-1} \cdot f_j + f_i \cdot f_{j+1}\\\end{eqnarray} 然后我们证明,当$j = k-1$和$j = k-2$成立时,$j = k$也成立 也就是说已知 $$\begin{cases}f_{i+k-1} &amp;=&amp; f_{i-1}\cdot f_{k-1} + f_{i}\cdot f_k\\f_{i+k-2} &amp;=&amp; f_{i-1}\cdot f_{k-2} + f_{i}\cdot f_{k-1}\\\end{cases}$$ 然后我们累加上面两式,可以得到 $$f_{i+k-1}+f_{i+k-2} = f{i-1}\cdot f_{k-1} + f_{i}\cdot f_k + f{i-1}\cdot f_{k-2} + f_{i}\cdot f_{k-1}$$ $$\therefore\begin{eqnarray}f_{i+k} &amp;=&amp; f_{i-1}\cdot (f_{k-1}+f{k-2}) + f_{i}\cdot (f_{k}+f_{k-1})\\ &amp;=&amp; f_{i-1}\cdot f_{k} + f_{i}\cdot f_{k+1}\\\end{eqnarray}$$ $ gcd(f_{i+j},f_{i}) = gcd(f_{i},f_{j}) $$$\begin{eqnarray}gcd(f_{i+j},f_{i}) &amp;=&amp; gcd(f_{i-1}\cdot f_j + f_i\cdot f_{j+1},f_{i})\\&amp;=&amp; gcd(f_{i-1}\cdot f_{j},f_{i})\\&amp;=&amp; gcd(f_{j},f_{i}) (\because gcd(f_{i},f_{i-1}) = 1)\\\end{eqnarray}$$ 所以上面的结论可以继续推广,容易得到 $$gcd(f_{i},f_{j}) = gcd(f_{i\%j},f_{j})$$ $gcd(f_{i},f_{j}) = f_{gcd(i,j)} $由上面的结论,我们容易得到,我们不断调用上面的结论,直到$i==1||j==1$,然后可以得到,如果$k=gcd(i,j)$,那么有$gcd(f_{i},f_{j}) = gcd(f_{k},f_{1}) = f_{k} = f_{gcd(i,j)}$ 命题得证]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IC(answer.chepter2)]]></title>
    <url>%2F2018%2F12%2F24%2FIC_chepter2%2F</url>
    <content type="text"><![CDATA[作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢 1.$\emptyset$ : $4^5 = 1024$.$\lbrace a\rbrace$ : $5\times 4\times 4\times 4 = 320$.$\lbrace b\rbrace$ : $5\times 5\times 5\times 2 = 250$.$\lbrace a,b\rbrace$ : $4\times 4\times 4\times 2 = 128$ 2.$(13!)^4 = 1503561738404723998944447273369600000000$. 3.$$\left( \begin{matrix} 52\\ 5 \end{matrix}\right)=2598960$$ 4.(a) $5\times 3\times 7\times 2 = 210$(b) $620 = 2^2+3^1+5^1+7^1$,$3\times 2\times 2\times 2 = 24$(c) $10^{10} = 2^{10} 5^{10}$,$11\times 11 = 121$ 5.因为$10 = 2\times 5$,所以我们只用统计$2,5$的数量就行了,然后我们可以发现,$2$的数量显然多于$5$的数量,所以我们只用统计$5$的个数就是答案.下面给出一个通用的代码 12345int cal(int a)&#123; int ret = 0; while(a) ret+=a/=5; return ret;&#125; 6.小数据暴力,大数据模拟]]></content>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IC(answer.chepter1)]]></title>
    <url>%2F2018%2F12%2F24%2FIC_chepter1%2F</url>
    <content type="text"><![CDATA[作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢 1.利用反证法容易得到,如果$n$和$m$都是奇数,那么$n*m$也是奇数,显然不可覆盖,所以$n$和$m$至少有一个偶数 2.我们定义行号从上到下为$1\dots m$,列号从左到右为$1\dots n$,然后我们就可以得到被切掉的那个方块只可能是奇数行奇数列,或者偶数行偶数列,我们考虑对这两种方案分别进行构造来得到我们想要的答案. 奇数行奇数列:对于和他在同一行同一列的方块来说,因为他去掉了,所以剩下的一定是可以匹配的偶数,也就是说我们可以匹配上这一行一列,对于剩下的一定都是偶数行偶数列的联通块,显然可以构造 奇数行奇数列:这个稍微麻烦一点,我们可以选择他周围的奇数行奇数列的一个子矩阵,显然可以螺旋式的构造,也就是说我们用完左上角,对于剩下的容易证明也是两个偶数的联通块,同样可以构造,看图 3.显然是不能获得自由的,因为我们可以将这个棋盘黑白二染色,然后可以发现对顶角颜色相同,每一步颜色都会反转,一共要走63步,所以最后一步一定会在异色块上,所以不行. 4.(a)对于每一个$n$来说我们直接考虑最后一块的摆放方法,如果是竖着放,那么剩下的就是$f(n-1)$的子问题,如果是横着放,那么倒数第二块显然也是横着放的,所以剩下的就是$f(n-2)$的子问题,所以显然可以得到的是$f(n) = f(n-1)+f(n-2)$,也就是说答案就是fibonacci.$\therefore f(12) = 233$ 4.(b)这里我们可以考虑DP来做,具体程序如下: 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e5+10;int dp[maxm][8];int main()&#123; dp[0][0] = dp[0][3] = dp[0][6] = dp[1][1] = dp[1][4] = dp[1][7] = 1; for(int i = 2;i&lt;maxm;i++)&#123; dp[i][0] = dp[i-2][3]+dp[i-2][6]+dp[i-2][0]; dp[i][1] = dp[i-1][0]+dp[i-2][1]; dp[i][3] = dp[i][0]+dp[i-2][3]; dp[i][4] = dp[i][1]; dp[i][6] = dp[i][3]; &#125; return 0;&#125; 然后可以发现$g(n) = 4\ast g(n-2)-g(n-4)$ 5.用4.(b)的代码容易可得,$g(4) = 11$ 6.同样采用反证法容易证得$n$是偶数,下面我们考虑$n$是奇数扣掉中间一块的情况.不妨假设八个角上的颜色是黑色,可以得到黑块数量是$4k^3+6k^2+3k+1$,白块的数量是$4k^3+6k^2+3k$,我们可以分两种情况讨论,我们假设$n = 2k+1$ 当k是奇数时,也就是$k = 2t+1$,即$n = 4t+3$,中间块是白色的.然后扣掉白块后,显然黑块和白块不匹配,然后不行鸭. 当k是偶数时,也就是$k = 2t$,即$n = 4t+1$,中间块是黑色的,扣掉黑块后,白块和黑块是匹配的,可能可以.下面我们证明$n = 4t+1$时是可行的 我们按照层数拆分,我们抽掉其中的第$2t+1$层,我们可以得到,这一层显然是可行的,类比于二阶的时候,我们扣掉中心块 对于剩下的两个联通块,我们显然可以得到是他们对称,我们只考虑上面的$2t$层的部分,我们每两层考虑一下 对于相连的两层,也就是$2\ast n\ast n$的形状,我们显然可以构造,所以整个三维结构是可以构造的. 7.首先证明$a$既是$n$的因子,又是$m$的因子 因为$a$是$b$的因子,所以$a\ast b$的可以看成多个$a\ast a$的,采用反证法,假设$a$不是$m$的因子,那么对于剩下的$(m%a)\ast (n%a)$的矩阵显然不可以用$a\ast a$的矩阵填满,所以$m%a==0&amp;&amp;n%a==0$. 再证$b$是$n$或者$m$的因子 同样反证法,我们将$a,b,m,n$同时缩小$a$倍,然后可以转化成,现在有一个$x\ast y$的棋盘,我要用一个$1\ast z$的棋盘去覆盖他,但是$gcd(x,z)=gcd(y,z)=1$,这个可以显然发现是不可能的 8.先证:存在完美覆盖$\rightarrow$存在平凡完美覆盖 利用习题7,我们得到如果存在完美覆盖,那么$gcd(n,a)=gcd(m,a)=a$并且$gcd(m,b)=b$,然后我们显然可以让$b$的朝向指向$m$的方向,也就是存在平凡完美覆盖 再证:存在平凡完美覆盖$\rightarrow$存在完美覆盖 显然 9.显然,举个简单例子$n=5,m=6,a=2,b=3$存在完美覆盖,但是不存在平凡完美覆盖. 10.假设存在不妨设四个变量是$a,b,c,d$,那么可以得到$a+b=b+c$即$a=c$显然不能构成幻方 11.12.13 如图 14.所有可能的构造如图 15.暴力枚举的,确实没有解,并不知道为什么…… 16.$n$阶幻方,幻方总和是$n^2\ast (n^2+1)/2$,所以每一行每一列求和都是$n\ast (n^2+1)/2$,现在替换后每一行每一列的和换成了$n\ast (n^2+1) - n\ast (n^2+1)/2 = n\ast (n^2+1)/2$所以可能是个幻方,然后因为里面的元素都是属于$[1,n^2]$之间的,所以$n^2+1-a$可以保证换完之后每个元素还是只出现一次,所以新生成的还是幻方. 17.给出$n=4$和$n=8$时的图……. 18.这个应该是显然的,因为二阶幻方都没有,显然没有二阶幻方体. 19.首先我们拆开来看没一个单独的平面,我们可以得到,对于一个四阶幻方来说,如果对角线也满足幻和,那么显然可以得到任意三阶子矩阵的对顶角之和等于幻和的一半,所以我们任取出四阶幻方体的任一三阶子体,可以得到类似于$a+b=b+c$的等式,也就是说存在$a==c$的情况,这显然和题意不符,所以不可能存在四阶幻方体. 20.首先,$10$和$5$一个颜色,$1,3,7,9$一个颜色,$2,4,6,8$一种颜色,可以得到可以由三种颜色构成,然后,$1,2,10$相互接壤,显然需要三种及以上颜色来涂,方案数为$3\ast 2\ast 1 = 6$. 21.(a) 二阶的显然不存在,书后面给了答案,还有一个比较简单的想法就是如果存在显然可以得到类似于$a==b$的结论,所以不存在. (b) 暴搜剪枝,emmmmm……如图]]></content>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 463 A weird recurrence relation]]></title>
    <url>%2F2018%2F12%2F23%2FPE463%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The function $f$ is defined for all positive integers as follows: $f(1)$ = $1$ $f(3)$ = $3$ $f(2n)$ = $f(n)$ $f(4n+1)$ = $2\cdot f(2n+1)-f(n)$ $f(4n+3)$ = $3\cdot f(2n+1)-2\cdot f(n)$ The function $S(n)$ is defined as $\sum_{i=1}^{n} f(i)$. $S(8)=22$ and $S(100)=3604$. Find $S(3^{37})$. Give the last $9$ digits of your answer. 题意就是给你一个序列,问你这个序列的前缀和是多少 分析显然是推公式嘛. 根据题意我们显然可以得到 $f(4n)+f(4n+1)+f(4n+2)+f(4n+3) = 6\cdot f(2n+1) - 2\cdot f(n)$ for $n\geq 1$ 然后我们每四项加一下就可以得到下面这个公式 \begin{eqnarray}S(4n+3) &amp;=&amp; \sum_{i=1}^{4i+3} f(i)\\ &amp;=&amp; 5 + \sum_{i=4}^{4i+3} f(i)\\ &amp;=&amp; 5 + \sum_{i=1}^{n} (6\cdot f(2i+1) - 2\cdot f(i))\\ &amp;=&amp; 5 + 6\sum_{i=1}^{n} (f(2i+1)+f(2i)) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; 5 + 6\sum_{i=2}^{2n+1} f(i) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; 5 - 6 + 6\sum{i=1}{2n+1} f(i) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; -1 + 6\sum{i=1}{2n+1} f(i) -8\sum_{i=1}^{n} f(i)\\\end{eqnarray} 然后瞎搞就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+10;const int mod = 1e9;inline int add(long long a,long long b)&#123;return (a+b)%mod;&#125;inline int mul(long long a,long long b)&#123;return a*b%mod;&#125;int num[maxm];int sum[maxm];long long f(long long a)&#123; if(a&lt;maxm&amp;&amp;num[a]) return num[a]; if(a==0) return 0; if(a==1) return 1; if(a==3) return 3; if((a&amp;1)^1) return f(a&gt;&gt;1); else if((a&amp;3)==3) return add(mul(3,f(a&gt;&gt;1)),mod-(f(a&gt;&gt;2)&lt;&lt;1)); else return add((f(a&gt;&gt;1|1)&lt;&lt;1),mod-f(a&gt;&gt;2));&#125;long long S(long long a)&#123; if(a&lt;maxm) return sum[a]; long long ret = 0; if(a%4==3)&#123; ret = add(ret,mul(6,S(a&gt;&gt;1))); ret = add(ret,mod-mul(8,S(a&gt;&gt;2))); ret = add(ret,mod-1); &#125;else&#123; while(a%4!=3) ret = add(ret,mod-f(++a)); ret = add(ret,S(a)); &#125; return ret;&#125;int main()&#123; for(int i = 1;i&lt;maxm;i++) num[i] = f(i),sum[i] = add(sum[i-1],num[i]); long long nouse = 1; for(int i = 1;i&lt;=37;i++)&#123; nouse = (nouse&lt;&lt;2)-nouse; &#125; cout&lt;&lt;S(nouse)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab]]></title>
    <url>%2F2018%2F12%2F23%2Fmatlab%2F</url>
    <content type="text"><![CDATA[系统级命令 命令名称 功能说明 clear 清楚内存中所有的或指定的变量和函数 cd 显示和改变当前工作目录 clc 擦除MATLAB工作窗口中所有显示的内容 clf 擦除MATLAB当前工作窗口中的图形 dir 列出当前或者指定目录下的子目录和文件清单 disp 在运行中显示变量或文字信息 echo 控制运行的文字命令是否显示 hold 控制当前的图形窗口对象是否被刷新 home 擦除命令窗口中的内容,并把光标移动到命令窗口 pack 收集内存碎片以扩大内存空间 quit 关闭并退出MATLAB type 显示所指定文件的全部内容 exit 退出MATLAB save 将工作区的变量存放到指定文件 load 回复保存过的变量 系统变量 变量 解释 ans 结果的缺省变量名 pi 圆周率 i,j 虚数单位 inf 无穷大 NaN not a number 矩阵函数 函数 解释 complex 将两个矩阵并成一个复矩阵 zeros(a,b) a*b全0阵 ones(a,b) a*b全1阵 eye(a,b) a*b单位矩阵 randi([a,b],m,n) m*n在a,b之间等概率随机整数矩阵 randn(a,b) 产生均值为0,方差为1的a*b的高斯分布随机阵 repmat(a,b,c) 将a矩阵铺放成bc的形式,总大小size(a)b*c size(a) 确定矩阵大小,返回[行数,列数] length(a) 确定向量元素的个数 numel(a) 确定矩阵中元素个数 find() 查找矩阵中满足条件的下标,或者行列 reshape(a,b,c) 将a变成b行c列(按列重拍) a’ 转置,复数则共轭转置 a(:) 变成一列 rot90 旋转 fliplr 左右翻转 flipud 上下翻转 diag 抽取主对角线 tril 抽取上三角 triu 抽取下三角 max 各列最大值 min 各列最小值 sort 各列递增排序 sum 各列求和 mean 各列平均值 std 各列标准差 var 各列方差 基本数学函数 函数 解释 abs(x) x中每个实数元素的绝对值,复数元素的模 sqrt(x) x中每个元素求平方根 exp(x) 指数运算 real(x) 求实部 imag(x) 求虚部 conj(x) 求共轭 angle(x) 求相位角 sin(x) 正弦 cos(x) 余弦 asin(x) 反正弦 acos(x) 反余弦 tan(x) 正切 atan(x) 反正切 log10(x) 常用对数lgx log(x) 自然对数lnx loga(b) 任意对数 mod(x,y) 求余函数 rem(x,y) 输出对应元素的余数 sign(x) 求矩阵中元素的正负号 lcm(x,y) 最小公倍数 gcd(x,y) 最大公约数 round(a) 四舍五入 fix(a) 按0的方向取整 floor(a) 向负无穷方向取整 ceil(a) 向正无穷方向取整 randperm(n) 产生一个长度为n的排列 绘图 函数 解释 plot(x,y,’option’) x横轴,y纵轴,逐点连折线绘制二维图形,参数见下表 plot(y) y为向量,以下标作为x轴,y为纵轴,绘制曲线 title(‘text’) 添加标题 xlabel(‘text’) x轴加标注 ylabel(‘text’) y轴加标记 legend(‘图例1’,’图例2’,…) 添加图例 text(x,y,’text’) 在指定位置添加文本字符串 gtext(‘text’) 用鼠标放置文本 axis([xmin xmax ymin ymax zmin zmax]) 调整坐标 hold 图形保持函数 subplot 子图分割命令 stem 离散序列 绘图参数表 符号 含义 符号 含义 y 黄 b 蓝 m 洋红 w 白 c 青 k 黑 r 红 g 绿 - 实线 – 虚线 : 点线 -. 点划线 . 点 o 圆 x 叉号 + 加号 ^ 向上的三角形 v 向下的三角形 &gt; 大于号 &lt; 小于号 s 正方形 d 菱形 p 五角星 h 六角星 * 星号 字符串函数 函数 解释 abs 字符串到ascii转换 str2mat 字符串转换成字符矩阵 setstr ascii转字符串 num2str 数值转字符串 str2num 字符串转换成数值 dec2bin 十进制数转二进制字符串 bin2dec 二进制串转十进制 int2str 将数值取整后转成字符串 upper 字符串转换成大写 lower 字符串转换成小写 sprintf 用格式控制,数字转字符串 sscanf 格式控制,字符串转数字 输入输出 函数 解释 input(‘text’) 键盘提示输入 fprintf() 格式输出]]></content>
      <tags>
        <tag>live</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 368 A Kempner-like series]]></title>
    <url>%2F2018%2F12%2F21%2FPE368%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The harmonic series $1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\dots$ is well known to be divergent. If we however omit from this series every term where the denominator has a $9$ in it, the series remarkably enough converges to approximately $22.9206766193$. This modified harmonic series is called the Kempner series. Let us now consider another modified harmonic series by omitting from the harmonic series every term where the denominator has $3$ or more equal consecutive digits. One can verify that out of the first $1200$ terms of the harmonic series, only $20$ terms will be omitted.These $20$ omitted terms are: $$\frac{1}{111},\frac{1}{222},\frac{1}{333},\frac{1}{444},\frac{1}{555},\frac{1}{666},\frac{1}{777},\frac{1}{888},\frac{1}{999},\frac{1}{1000},\frac{1}{1110}, \frac{1}{1111},\frac{1}{1112},\frac{1}{1113},\frac{1}{1114},\frac{1}{1115},\frac{1}{1116},\frac{1}{1117},\frac{1}{1118},\frac{1}{1119}$$ This series converges as well. Find the value the series converges to.Give your answer rounded to $10$ digits behind the decimal point. 题意就是,调和级数不是发散的嘛,然后让你删掉那些分母含有连续三个相同数字的,然后可以证明剩下的级数是收敛的,然后问你收敛于多少. 分析做法比较巧妙,下面一点点分析. 首先我们令$S_1(n,d)$表示一个包含所有这样的$n$位数的集合,集合中所有的$n$位数最后一位是$n$,并且倒数第二位不是$n$. $S_2(n,d)$表示一个包含所有这样的$n$位数的集合,集合中所有的$n$位数最后两位是$n$,并且倒数第三位不是$n$. 然后我们令 $f_1(n,d,j)$ = $\sum_{x\in S_1(n,d)} \frac{1}{x^j}$ $f_2(n,d,j)$ = $\sum_{x\in S_2(n,d)} \frac{1}{x^j}$ 然后答案显然就是 $\sum_{i=1}^{99} \frac{1}{i}+\sum_{n=3}^{\infty } \sum_{d=0}^{9} [f_1(n,d,1)+f_2(n,d,1)]$ 关键是我们怎么算$f_1(n,d,j)$和$f_2(n,d,j)$ 二者分析方法一样,这里给出$f_2(n,d,j)$怎么推出来的. 首先根据定义我们有 $f_2(n,d,j)$ = $\sum_{x\in S_2(n,d)} \frac{1}{x^j}$ 我们不妨枚举每一个$x$,然后累加就是答案,所以子问题就是如何快速计算$\frac{1}{x^j} where x \in S_2(n,d)$ 因为最后一位是$d$,所以我们不妨设$x$ = $y\ast 100+d\ast 10+d$ 然后可以得到 $$(\frac{1}{x\ast 100+d\ast 10+d})^j=\frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot (\frac{1}{1+\frac{d}{x\ast 100+d\ast 10}})^j$$ 然后我们将第三个分式化简. 考虑到 $(1+a)^{-b} = \sum_{i=0}^{\infty } C_{b+i-1}^i \cdot (-a)^b$ 所以上式可以化简为 \begin{eqnarray}(\frac{1}{x\ast 100+d\ast 10+d})^j&amp;=&amp; \frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot \sum_{i=0}^{\infty } C_{j+i-1}^{i}(\frac{-d}{x\ast 100+d\ast 10})^i\\&amp;=&amp; \frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot \sum_{i=0}^{\infty } C_{j+i-1}^{i}(\frac{-d}{10})^i\cdot(\frac{1}{x\ast 10+d})^i\\&amp;=&amp; \frac{1}{10^j} \sum_{i=0}^{\infty } C_{j+i-1}^{i} \cdot (\frac{-d}{10})^i \cdot (\frac{1}{x\ast 10+d})^{i+j}\\\end{eqnarray} 然后我们考虑累加所有的$x$也就是原来的$f_2(n,d,j)$ 可以得到 $$f_2(n,d,j) = \frac{1}{10^j} \sum_{i=0}^{\infty } (\frac{-d}{10})^i \cdot C_{j+i-1}^{i} \cdot f_1(n-1,d,i+j)$$ 同理可以推得 $f_1(n,d,j)$ 然后就是代码如下啦啦啦$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 40;double C[maxm*3][maxm*3];double f1[2][10][maxm+1];double f2[2][10][maxm+1];double ans = 0;void init()&#123;//预处理出组合数和前99项的答案 for(int i = 0;i&lt;maxm*3;i++) for(int j = 0;j&lt;=i;j++)&#123; if(j==0) C[i][j] = 1; else C[i][j] = C[i-1][j-1]+C[i-1][j]; &#125; for(int i = 1;i&lt;100;i++) ans+=1.0/i;&#125;int main()&#123; init(); for(int d = 0;d&lt;=9;d++)&#123;//预处理出n = 3的情况 for(int j = 1;j&lt;=maxm;j++)&#123; for(int pre = 10;pre&lt;100;pre++)&#123; int fir = pre/10; int sec = pre%10; if(fir==sec&amp;&amp;sec==d) continue; if(sec==d) f2[1][d][j]+=1.0/pow(pre*10+d,j); else f1[1][d][j]+=1.0/pow(pre*10+d,j); &#125; &#125; ans+=f1[1][d][1]+f2[1][d][1]; &#125; for(int nouse = 4;nouse&lt;=10000;nouse++)&#123;//滚动的算n&gt;=4的时候 int now = nouse&amp;1; int las = now^1; for(int d = 0;d&lt;=9;d++)&#123; for(int j = 1;j&lt;=maxm;j++)&#123; f1[now][d][j] = f2[now][d][j] = 0;//别忘了初始化 double pre = 1.0/pow(10.0,j); for(int i = 0;i&lt;=maxm;i++)&#123; if(i+j&lt;=maxm) f2[now][d][j]+=pre*C[j+i-1][i]*f1[las][d][i+j]; for(int x = 0;x&lt;10;x++)&#123; if(x==d) continue; if(i+j&lt;=maxm) f1[now][d][j]+=pre*C[j+i-1][i]*(f1[las][x][i+j]+f2[las][x][i+j]); &#125; pre*=-d/10.0; &#125; &#125; ans+=f1[now][d][1]+f2[now][d][1]; &#125; printf("%.10f\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 492 Exploding sequence]]></title>
    <url>%2F2018%2F12%2F12%2FPE492%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Define the sequence $a_1, a_2, a_3,\dots$ as: $a_1 $=$ 1$ $a_{n+1} = 6a_n^2 + 10a_n + 3$ for $n \geq 1$. Examples: $a_3 $=$ 2359$ $a_6 $=$ 269221280981320216750489044576319$ $a_6 mod 1000000007 $=$ 203064689$ $a_{100} mod 1000000007 $=$ 456482974$ Define $B(x,y,n)$ as $\sum (a_n mod $ $p)$ for every prime $p$ such that $x \leq p \leq x+y$. Examples: $B(10^9, 10^3, 10^3)$ = $23674718882$ $B(10^9, 10^3, 10^{15})$ = $20731563854$ Find $B(10^9, 10^7, 10^{15})$. 题意给你一个二次递推序列,问你这个数列的第$10^{15}$项膜上一堆质数之后求和是多少. 分析看了大佬的题解之后才做出来的,还是太菜了$\dots$ 下面是分析. 首先我们令$b_n = 6a_n+5$ 于是有 $b_1$ = $11$ $b_{n+1} $=$ b_n^2-2$ 然后我们令 $ x + \frac{1}{x}$ = $11$ 可以显然发现 $b_n$ = $x^{2^{n-1}} + \frac{1}{x^{2^{n-1}}}$ 于是不妨设 $x$ = $\frac{11+\sqrt{117}}{2}$ $\therefore b_n$ = $(\frac{11+\sqrt{117}}{2})^{2^{n-1}} + (\frac{11-\sqrt{117}}{2})^{2^{n-1}}$ 然后我们可以直接算就行了 我们搞出递推式，然后用矩阵乘法的做法来做 我们考虑一个更一般的问题， 令$f_n = (\frac{11+\sqrt{117}}{2})^n + (\frac{11-\sqrt{117}}{2})^n$ 然后我们考虑$f_n$如何求解 首先我们假设$f_n = x\ast f_{n-1}+y\ast f_{n-2}$ $$令 (\frac{11+\sqrt{117}}{2})^{n-2} = a$$ $$令 (\frac{11-\sqrt{117}}{2})^{n-2} = b$$ 则有\begin{cases}\begin{eqnarray}f_n &amp;=&amp; a\ast (\frac{11+\sqrt{117}}{2})^2+b\ast (\frac{11-\sqrt{117}}{2})^2\\&amp;=&amp; a\ast (\frac{238+22\sqrt{117}}{4})+b\ast (\frac{238-22\sqrt{117}}{4})\\f_{n-1}&amp;=&amp;a\ast (\frac{11+\sqrt{117}}{2})+b\ast (\frac{11-\sqrt{117}}{2})\\f_{n-2}&amp;=&amp;a+b \\\end{eqnarray}\end{cases} \begin{eqnarray}&amp;\therefore&amp; a\ast (\frac{238+22\sqrt{117}}{4})+b\ast (\frac{238-22\sqrt{117}}{4})\\&amp;=&amp; x\ast a\ast (\frac{11+\sqrt{117}}{2})+x\ast b\ast (\frac{11-\sqrt{117}}{2}) + y\ast (a+b)\\\end{eqnarray} 将非根号项提出来，可以得到 $\therefore a\ast \frac{119}{2}+b\ast \frac{119}{2}$=$xa\ast \frac{11}{2}+xb\ast \frac{11}{2}+y(a+b) $ 同理将根号项提出可以得到 $a\ast \frac{11}{2}+b\ast \frac{-11}{2}$=$xa\ast \frac{1}{2}+xb\ast \frac{-1}{2} $ 然后可以解得 \begin{cases}x = 11\\y = -1\end{cases} 也就是说$f_n$ = $11\ast f_{n-1} - f_{n-2}$ 好了，我们得到了$f_n$的递推式，然后考虑原问题，也就是说 $$\left( \begin{matrix} b_{n+1}\\ b_n \end{matrix}\right)=\left( \begin{matrix} 11 &amp; -1\\ 1 &amp; 0 \end{matrix}\right)^{2^{n-1}-1}\left( \begin{matrix} b_2\\ b_1 \end{matrix}\right)=\left( \begin{matrix} 11 &amp; -1\\ 1 &amp; 0 \end{matrix}\right)^{2^{n-1}-1}\left( \begin{matrix} 119\\ 11 \end{matrix}\right)$$ $\because n$ 很大($10^{15}$) $\therefore 2^{n-1}-1$很大,以至于我们不能方便的计算 然后我们考虑降低指数 具体分析看大佬的分析,可以得到循环节可以是$(p+1)(p-1)$ 这个值我们可以接受,然后直接裸的矩阵ksm就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const long long n = 1e15;const long long l = 1e9;const long long r = l+1e7;long long add(long long a,long long b,long long mod)&#123; return (a+b)%mod; &#125;long long mul(long long a,long long b,long long mod)&#123; a = add(a,mod,mod); b = add(b,mod,mod); long long ret = 0; while(b)&#123; if(b&amp;1) ret = add(ret,a,mod); a = add(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;long long qpow(long long a,long long b,long long mod)&#123; long long ret = 1; while(b)&#123; if(b&amp;1) ret = mul(ret,a,mod); a = mul(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;bool is_prime(int a)&#123; if(a&amp;1)&#123; for(int i = 3;i*i&lt;=a;i++) if(a%i==0) return false; return true; &#125; return false;&#125;struct p&#123; int mat[2][2]; void show()&#123; for(int i = 0;i&lt;2;i++)&#123; for(int j = 0;j&lt;2;j++) cout&lt;&lt;mat[i][j]&lt;&lt;' '; cout&lt;&lt;endl; &#125; &#125;&#125;;p mul(p a,p b,long long mod)&#123; p ret; memset(ret.mat,0,sizeof ret.mat); for(int i = 0;i&lt;2;i++)&#123; for(int j =0;j&lt;2;j++)&#123; for(int k = 0;k&lt;2;k++)&#123; ret.mat[i][j] = add(ret.mat[i][j],mul(a.mat[i][k],b.mat[k][j],mod),mod); &#125; &#125; &#125; return ret;&#125;p qpow(p a,long long b,long long mod)&#123; p ret; for(int i = 0;i&lt;2;i++) for(int j = 0;j&lt;2;j++) &#123; if(i==j) ret.mat[i][j]=1; else ret.mat[i][j]=0; &#125; while(b)&#123; if(b&amp;1) ret = mul(ret,a,mod); a = mul(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;long long solve(long long prime)&#123; const long long MOD = prime*prime-1; long long zhi = qpow(2,n-1,MOD); zhi = add(zhi,MOD-1,MOD); p base; base.mat[0][0]=11,base.mat[0][1]=-1; base.mat[1][0]=1 ,base.mat[1][1]=0; base = qpow(base,zhi,prime); long long ret1 = mul(base.mat[1][0],119,prime); long long ret2 = mul(base.mat[1][1],11,prime); return add(ret1,ret2,prime);&#125;long long inv(long long a,long long mod)&#123; if(a==1) return 1; return mul(mod-mod/a,inv(mod%a,mod),mod);&#125;int main()&#123; long long ans = 0; for(int i = l;i&lt;=r;i++)&#123; if(is_prime(i))&#123; long long bn = solve(i); long long now1 = add(bn,i-5,i); long long an = mul(now1,inv(6,i),i); ans+=an; &#125; if(i%100000==0) cout&lt;&lt;i&lt;&lt;endl; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 294 Sum of digits-experience]]></title>
    <url>%2F2018%2F12%2F09%2FPE294%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For a positive integer $k$, define $d(k)$ as the sum of the digits of $k$ in its usual decimal representation. Thus $d(42) = 4+2 = 6$. For a positive integer $n$, define $S(n)$ as the number of positive integers $k &lt; 10^n$ with the following properties : $k$ is divisible by $23$ and $d(k) = 23$. You are given that $S(9) = 263626$ and $S(42) = 6377168878570056$. Find $S(11^{12})$ and give your answer mod $10^9$. 题意你要找到一个所有满足一下三个条件的数字数量 假设这个数是$k$ $k$ $&lt;$ $10^{11^{12}}$ $k\%23$ = 0 $k$每个十进制位求和为$23$ 分析这个题目困扰了我两天,我一度以为自己读错题了,主要是数据范围太大了,大的人一点想法都没有$\dots$ 下面说正解 虽然数据范围很大,但是我们可以从小数据入手 先看第二个条件$k%23==0$,是否感觉出了一丝丝猫腻? 于是我大胆写了一下,比较好想的就是一定存在一个$n$使得$10^n%23==1$,也就是说存在膜数存在循环,而且显然有循环节是$O(23)$的 于是大胆暴力,找到了,循环节长度为$22$ 这也就是说,在十进制下,位数最多有$11^{12}$个,而且这些里面,可以拆分成$22$份,每一份里面,你不管把数字安排到哪里,都是同膜的 于是我们可以简单的把$11^{12}$近似的均分成了$22$份.而且每一份可以单独统计答案 然后问题就转化成了以下两个子问题: 找到$a_1,a_2\dots a_{22}$使得$a_1+a_2+\dots +a_{22} = 23$ 对于每一份就成了一个$a_i$个相同的球放入近似$11^{12}$个盒子里,每个盒子最多放$9$个球,问你方案数 对于第一个子问题,我们显然可以动态规划搞一搞 定义$dp(i,j,k)$表示$a_1+a_2+\dots +a_i == j$并且当前膜数为$k$的方案数 然后暴力转移就行了 关键是第二个子问题不好想,因为盒子数量太大了,必须要有一个$log$的做法 然后就枚举算法(毕竟会的算法不多) 然后就想到了分治,但是能不能分治呢,并不知道,写一发就知道了,然后跑的挺快的(然后就过了) 并不会算分治的玄学复杂度 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9;int add(int a,int b)&#123;return (a+b)%mod;&#125;int mul(int a,int b)&#123;return 1ll*a*b%mod;&#125;long long n,m;void init()&#123; m = 23; n = 1; for(int i = 1;i&lt;=12;i++) n*=11;&#125;map&lt;pair&lt;long long,int&gt;,int&gt;mp;int solve(long long a,int b)&#123;///b ball,a boxes if(a==1) return b&lt;=9; if(a==0) return b==0; pair&lt;long long,int&gt; now = make_pair(a,b); if(mp[now]) return mp[now]; int ret = 0; long long l = a/2,r = a-l; for(int i = 0;i&lt;=b;i++) ret = add(ret,mul(solve(l,i),solve(r,b-i))); return mp[now] = ret;&#125;long long dp[30][30][30];int main()&#123; init(); dp[0][0][0] = 1; int w = 1; for(int i = 0;i&lt;m;i++)&#123; long long has = n/(m-1) + (i&lt;n%22); for(int j = 0;j&lt;=m;j++)&#123; for(int k = 0;k&lt;m;k++)&#123; for(int t = 0;j+t&lt;=m;t++)&#123; dp[i+1][j+t][(k+w*t)%m] = add(dp[i+1][j+t][(k+w*t)%m],mul(dp[i][j][k],solve(has,t))); &#125; &#125; &#125; w = w*10%m; &#125; cout&lt;&lt;dp[m-1][m][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 303 Multiples with small digits]]></title>
    <url>%2F2018%2F12%2F08%2FPE303%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For a positive integer $n$, define $f(n)$ as the least positive multiple of $n$ that, written in base $10$, uses only digits $≤ 2$. Thus $f(2)=2, f(3)=12, f(7)=21, f(42)=210, f(89)=1121222$. Also,$ \sum_{n=1}^{100} \frac{f(n)}{n} = 11363107 $ Find $ \sum_{n=1}^{10000} \frac{f(n)}{n}. $ 题意问你对于每个数字来说，找到他的一个最小整数倍，使得最小整数倍在十进制下每位都小于3 分析很显然，考的是搜索，如何高效搜索． 最简单的想法就是枚举倍数，然后逐个判断是否合法，然后你会发现所有$999$的倍数都Ｔ飞了 然后考虑剪枝，因为可以显然得到，有些倍数一定无效，比如： $5来说，5\ast 1 = 5,5\ast 11 = 55,5\ast 21 = 105 \dots$ 可以显然发现，对于$5$来说，以$1$结尾的倍数显然都不合理，因为他们的最后一位一定是$5$，可以直接判断掉． 然后你就就基本可以过掉大部分数据，但是还是有一个比较头疼，那就是$9999$. 因为他对应的答案贼大，暴力搜索基本都GG．然后我们换一个思路． 那就是我们直接暴力枚举所有的那些看起来长的像$3$进制的十进制数． 然后我们就直接存储所有的这样的数字，然后枚举？ 那么显然内存不够，那怎么办呢？ dfs? 还是Ｔ飞，所以我们还要在此基础上剪枝． 首先我们可以构造出一种做法就是，每次搜索的时候得到的都是之前没出现过的最小的这类数字． 然后我们维护一个mod数组，表示当前这个mod正确的情况下，最小的这类数字是多少 然后答案显然就是mod[0]啦……. 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define ll unsigned long longusing namespace std;ll vis[10000+100];ll cal(int a)&#123; queue&lt;ll&gt; que; que.push(1),que.push(2); memset(vis,0,sizeof vis); vis[1] = 1; vis[2] = 2; while(true)&#123; ll now = que.front(); que.pop(); if(now%a==0) return now/a; for(int i = 0;i&lt;3;i++)&#123; ll buf = now*10+i; ll buff = buf%a; if(vis[buff]) continue; vis[buff] = buf; que.push(buf); &#125; &#125;&#125;int main()&#123; ll ans = 0; for(int i = 1;i&lt;=10000;i++) ans+=cal(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>PE</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 288 An enormous factorial]]></title>
    <url>%2F2018%2F12%2F08%2FPE288%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For any prime $p$ the number $N(p,q)$ is defined by $N(p,q) = \sum_{n=0}^q T_n*p^n$with $T_n$ generated by the following random number generator: \begin{eqnarray}&amp;&amp;S_0 = 290797\\&amp;&amp;S_{n+1} = S_n^2 mod 50515093\\&amp;&amp;T_n = S_n mod p\\\end{eqnarray} Let $Nfac(p,q)$ be the factorial of $N(p,q)$.Let $NF(p,q)$ be the number of factors $p$ in $Nfac(p,q)$. You are given that $NF(3,10000) mod 3^{20}=624955285$. Find $NF(61,10^7)$ mod $61^{10}$ 题意题意说的有点麻烦，我简化一下 $T_i$是随机生成的数据，$N(p,q)=\sum_{n=0}^q T_n*p^n$ 问你$N(p,q)$的阶乘里面，质因数分解以后$p$的指数膜$p^{10}$答案是多少． 分析首先可以观察到的是，$T_i$很小，而且他是随机的，我们显然要把他存起来． 然后一个比较显然的结论是$$n!质因数分解后素因子p的数量为\lfloor \frac{n}{p} \rfloor + \lfloor \frac{n}{p^2} \rfloor + \cdots$$$$\because 最后的答案要膜 p^{10} \therefore 我们统计的时候，对于第一项，我们统计指数为 [1,10]的，第二项[2,11],然后枚举项统计答案即可$$ 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+1;const int pow_num = 10;long long T[maxm+100];const int p = 61;long long powp[1000];void init()&#123; powp[0] = 1; for(int i = 1;i&lt;=pow_num;i++) powp[i] = powp[i-1]*p; long long s0 = 290797; for(int i = 1;i&lt;maxm;i++) T[i] = (s0=s0*s0%50515093)%p;&#125;int main()&#123; init(); long long ans = 0; const long long mod = powp[pow_num]; for(int i = 1;i&lt;maxm;i++) for(int j = i;j&lt;=i+pow_num-1;j++) ans = (ans+(T[j]*powp[j-i]%mod))%mod; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mathematical formula(Irregular updates)]]></title>
    <url>%2F2018%2F12%2F07%2FMathematical_Formula%2F</url>
    <content type="text"><![CDATA[二元运算符 符号 功能 代码 符号 功能 代码 符号 功能 代码 $+$ 加 + $-$ 减 - $\triangleleft$ \triangleleft $\pm$ 加减 \pm $\mp$ 减加 \mp $\triangleright$ \triangleright $\times$ 乘 \times $\setminus$ 差集 \setminus $\star$ ５星乘 \star $\cup$ 并 \cup $\cap$ 交 \cap $\ast$ ６星乘 \ast $\sqcup$ \sqcup $\sqcap$ \sqcap $\circ$ \circ $\vee$ 合取 \vee $\wedge$ 析取 \wedge $\bullet$ \bullet $\oplus$ 异或 \oplus $\ominus$ \ominus $\diamond$ \diamond $\odot$ \odot $\oslash$ \oslash $\uplus$ \uplus $\otimes$ \otimes $\bigcirc$ \bigcirc $\amalg$ \amalg $\bigtriangleup$ \bigtriangleup $\bigtriangledown$ \bigtriangledown $\dagger$ \dagger $\lhd$ \lhd $\rhd$ \rhd $\ddagger$ \ddagger $\unlhd$ \unlhd $\unrhd$ \unrhd $\wr$ \wr 二元关系符 符号 功能 代码 符号 功能 代码 符号 功能 代码 $&lt;$ 小于 &lt; $&gt;$ 大于 &gt; $=$ 等于 = $\leq$ 小于等于 \leq $\geq$ 大于等于 \geq $\equiv$ 同余 \equiv $\ll$ 远小于 \ll $\gg$ 远大于 \gg $\doteq$ 约等于 \doteq $\prec$ \prec $\succ$ \succ $\sim$ \sim $\preceq$ \preceq $\succeq$ \succeq $\simeq$ \simeq $\subset$ 子集 \subset $\supset$ 父集 \supset $\approx$ \approx $\subseteq$ \subseteq $\supseteq$ \supseteq $\cong$ \cong $\sqsubset$ \sqsubset $\sqsupset$ \sqsupset $\Join$ \Join $\sqsubseteq$ \sqsubseteq $\sqsupseteq$ \sqsupseteq $\bowtie$ \bowtie $\in$ 属于 \in $\ni$ 被属于 \ni $\propto$ \propto $\vdash$ 蕴涵 \vdash $\dashv$ 被蕴涵 \dashv $\models$ \models $\mid$ 整除 \mid $\parallel$ 平行 \parallel $\perp$ \perp $\smile$ \smile $\frown$ \frown $\asymp$ \asymp $:$ ： $\notin$ 不属于 \notin $\neq$ 不等于 \neq 小写希腊字母 符号 代码 符号 代码 符号 代码 符号 代码 符号 代码 $\alpha$ \alpha $\beta$ \beta $\gamma$ \gamma $\delta$ \delta $\omega$ \omega $\epsilon$ \epsilon $\varepsilon$ \varepsilon $\zeta$ \zeta $\eta$ \eta $\psi$ \psi $\theta$ \theta $\vartheta$ \vartheta $\iota$ \iota $\kappa$ \kappa $\varphi$ \varphi $\lambda$ \lambda $\mu$ \mu $\nu$ \nu $\xi$ \xi $\phi$ \phi $\pi$ \pi $\varpi$ \varpi $\rho$ \rho $\varrho$ \varrho $\upsilon$ \upsilon $\sigma$ \sigma $\varsigma$ \varsigma $\tau$ \tau 大写希腊字母 符号 代码 符号 代码 符号 代码 符号 代码 符号 代码 $\Gamma$ \Gamma $\Delta$ \Delta $\Theta$ \Theta $\Lambda$ \Lambda $\Omega$ \Omega $\Xi$ \Xi $\Pi$ \Pi $\Sigma$ \Sigma $\Upsilon$ \Upsilon $\Psi$ \Psi $\Phi$ \Phi 箭头 符号 代码 符号 代码 符号 代码 符号 代码 $\leftarrow$ \leftarrow $\rightarrow$ \rightarrow $\Leftarrow$ \Leftarrow $\Rightarrow$ \Rightarrow $\longleftarrow$ \longleftarrow $\longrightarrow$ \longrightarrow $\Longleftarrow$ \Longleftarrow $\Longrightarrow$ \Longrightarrow $\uparrow$ \uparrow $\downarrow$ \downarrow $\Uparrow$ \Uparrow $\Downarrow$ \Downarrow $\nwarrow$ \nwarrow $\nearrow$ \nearrow $\swarrow$ \swarrow $\searrow$ \searrow $\Leftrightarrow$ \Leftrightarrow $\Longleftrightarrow$ \Longleftrightarrow $\Updownarrow$ \Updownarrow $\iff$ \iff $\mapsto$ \mapsto $\longmapsto$ \longmapsto $\hookleftarrow$ \hookleftarrow $\hookrightarrow$ \hookrightarrow $\leftharpoonup$ \leftharpoonup $\rightharpoonup$ \rightharpoonup $\leftharpoondown$ \leftharpoondown $\rightharpoondown$ \rightharpoondown $\updownarrow$ \updownarrow $\leadsto$ \leadsto $\rightleftharpoons$ \rightleftharpoons $\longleftrightarrow$ \longleftrightarrow $\leftrightarrow$ \leftrightarrow 括号 符号 代码 符号 代码 符号 代码 符号 代码 $\lbrack$ \lbrack $\rbrack$ \rbrack $\lbrace$ \lbrace $\rbrace$ \rbrace $\langle$ \langle $\rangle$ \rangle $\lfloor$ \lfloor $\rfloor$ \rfloor $\vert$ \vert $\Vert$ \Vert $\lceil$ \lceil $\rceil$ \rceil $\backslash$ \backslash 大尺寸符号 符号 代码 符号 代码 符号 代码 符号 代码 $\lgroup$ \lgroup $\rgroup$ \rgroup $\lmoustache$ \lmoustache $\rmoustache$ \rmoustache $\arrowvert$ \arrowvert $\Arrowvert$ \Arrowvert $\bracevert$ \bracevert]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UPCOJ 9805 Network Reliability]]></title>
    <url>%2F2018%2F12%2F03%2FUPCOJ9805%2F</url>
    <content type="text"><![CDATA[题目描述An undirected graph is given. Each edge of the graph disappears with a constant probability. Calculate the probability with which the remained graph is connected. 输入The first line contains three integers N (1≤N≤14), M (0≤M≤100) and P (0≤P≤100), separated by a single space. N is the number of the vertices and M is the number of the edges. P is the probability represented by a percentage. The following M lines describe the edges. Each line contains two integers $ v_i $ and $ u_i $ (1≤$ u_i $ ,$ v_i $≤N). ($ u_i $ ,$ v_i $) indicates the edge that connects the two vertices $ u_i $ and$ v_i $. 输出Output a line containing the probability with which the remained graph is connected. Your program may output an arbitrary number of digits after the decimal point. However, the absolute error should be $10^{−9}$ or less. 样例输入3 3 50 1 2 2 3 3 1 样例输出0.500000000000 题意zuhiul 和不超过14 个妹子存在着不清不楚的关系，但是他发现，有些妹子们相互之间是闺蜜，所以这些是闺蜜的妹子们有 $P$ 的概率会发现对面和zuhiul有关系从而导致关系破裂，现在问你多大的概率下，大家相安无事(妹子们还是一个联通图)． 分析数据量这么小，显然状压呀． 所以我们定义 $DP[i] 表示 state==i 时，i 包含的点相互联通的概率$ 那么比较容易得到答案就是 $ DP[(1&lt;&lt;n)-1] $ 现在我们考虑转移： ​ 因为要保证state内任意两点可达，所以我们不妨枚举出所有不可达的情况，容斥一下就行了． ​ 所以每次对于一个state，我们可以枚举他的每个点的子集，然后对于其他点到这个集合都割掉就行了 ​ 你问我为什么不会重复和遗漏？ ​ 这就要用到神奇的构造了． ​ 首先我们保证每个正确的点的子集里面都包含某一个点，那么对于包含这个点的所有正确子集来说肯定各不相同，这个保证了不会重复 ​ 然后怎么证明没有遗漏呢？ ​ 因为对于任何一个点来说，他都属于某一个联通块，我们实际上是在枚举每一个联通块，所以不会遗漏呀． ​ 恩，大概就是这样，详情请看代码． ​ 最后说一下复杂度． ​ 应该是 $O(\sum_{i = 1}^{n} C_n^i * 2^i) = O(3^n)$ 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;double p;double pow_p[100];int pow_2[100];int mat[100][100];void init()&#123; scanf("%d%d%lf",&amp;n,&amp;m,&amp;p); p/=100; pow_2[0] = 1; pow_p[0] = 1; for(int i = 1;i&lt;100;i++) pow_p[i] = pow_p[i-1]*p,pow_2[i] = pow_2[i-1]&lt;&lt;1; for(int i = 1,from,to;i&lt;=m;i++) &#123; scanf("%d%d",&amp;from,&amp;to); mat[--from][--to]++; mat[to][from]++; &#125;&#125;const int maxm = 1&lt;&lt;15;double dp[maxm];int has[100];int sub[100];void get(int state)&#123; dp[state] = 1; has[0] = 0; for(int i = 0;i&lt;n;i++) if(state&amp;(1&lt;&lt;i)) has[++has[0]] = i; if(has[0]==1) return ; for(int now = state&amp;(state-1);now;now = (now-1)&amp;state)&#123; if((now&amp;(1&lt;&lt;has[1]))==0) continue; sub[0] = 0; for(int i = 1;i&lt;=has[0];i++) if(now&amp;(1&lt;&lt;has[i])) sub[++sub[0]] = has[i]; int cnt = 0; for(int i = 1;i&lt;=has[0];i++) for(int j = 1;j&lt;=sub[0];j++)&#123; if(now&amp;(1&lt;&lt;has[i])) continue; cnt+=mat[has[i]][sub[j]]; &#125; dp[state]-=dp[now]*pow_p[cnt]; &#125;&#125;int main()&#123; init(); const int nouse = pow_2[n]; for(int i = 1;i&lt;nouse;i++)&#123; get(i); &#125; printf("%.10f\n",dp[nouse-1]); return 0;&#125;]]></content>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UPCOJ 9999 Cube]]></title>
    <url>%2F2018%2F12%2F03%2FUPCOJ9999%2F</url>
    <content type="text"><![CDATA[题目描述给你一个 $ n\ast m $ 的棋盘，有一个 $ 1\ast 1\ast 2 $ 的长方体竖直放在 (1,1)上，你可以将其在棋盘上滚动，你的目标是让其竖直放在 ( n , m ) 上，问至少需要多少次操作。(放倒、竖直、翻滚) 输入一行，两个整数n，m (n&lt;=m) 输出需要最少时间能从(1,1)到达(n,m)，如果无解输出 $ impossible $ . 样例输入1 1 样例输出0 提示 分析这个题目我的做法其实比较暴力，因为和队友赌能不能1Y ，我甚至怂到写暴力对拍了．．．． 闲话少说，下面看分析． 其实还是比较好想的． 首先我们考虑哪种情况是 impossible ．比较好观察的是，当ｎ和ｍ足够大的时候就一定可达 所以我们只用找到一个ｎ和ｍ可达的下界就行了 然后就可以发现只有当ｎ和ｍ都小于３的时候会有impossible的情况(因为转不动．．．． 接下来分析其他情况，首先比较好分析的是，如果n%3==1&amp;&amp;m%3==1的话，答案可以显然得到是 (n/3+m/3)\ast 2 剩下的同理搞搞就行了，大体情况见下表． 比较显然的是，加的那一项和n,m％3为2的数量一致，然后就是代码啦．．． 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std; int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; if(n&lt;=2)&#123; if(m%3==1) cout&lt;&lt;m/3*2+n-1&lt;&lt;endl; else cout&lt;&lt;"impossible"&lt;&lt;endl; &#125;else if(n==3&amp;&amp;m==3) cout&lt;&lt;8&lt;&lt;endl; else if(n==3)&#123; if(m%3==0) cout&lt;&lt;m/3*2+4&lt;&lt;endl; else if(m%3==1) cout&lt;&lt;(m+2)/3*2&lt;&lt;endl; else cout&lt;&lt;m/3*2+5&lt;&lt;endl; &#125;else &#123; int ans = (n/3+m/3)*2; ans+=(m%3==2)+(n%3==2); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3829 FarmCraft]]></title>
    <url>%2F2018%2F12%2F02%2FBZOJ3829%2F</url>
    <content type="text"><![CDATA[题目描述In a village called Byteville, there are houses connected with N-1 roads. For each pair of houses, there is a unique way to get from one to another. The houses are numbered from 1 to . The house no. 1 belongs to the village administrator Byteasar. As part of enabling modern technologies for rural areas framework, computers have been delivered to Byteasar’s house. Every house is to be supplied with a computer, and it is Byteasar’s task to distribute them. The citizens of Byteville have already agreed to play the most recent version of FarmCraft (the game) as soon as they have their computers. Byteasar has loaded all the computers on his pickup truck and is about to set out to deliver the goods. He has just the right amount of gasoline to drive each road twice. In each house, Byteasar leaves one computer, and immediately continues on his route. In each house, as soon as house dwellers get their computer, they turn it on and install FarmCraft. The time it takes to install and set up the game very much depends on one’s tech savviness, which is fortunately known for each household. After he delivers all the computers, Byteasar will come back to his house and install the game on his computer. The travel time along each road linking two houses is exactly 1 minute, and (due to citizens’ eagerness to play) the time to unload a computer is negligible. Help Byteasar in determining a delivery order that allows all Byteville’s citizens (including Byteasar) to start playing together as soon as possible. In other words, find an order that minimizes the time when everyone has FarmCraft installed. 输入The first line of the standard input contains a single integer N(2&lt;=N&lt;=5 00 000) that gives the number of houses in Byteville. The second line contains N integers C1,C2…Cn(1&lt;=Ci&lt;=10^9), separated by single spaces; Ci is the installation time (in minutes) for the dwellers of house no. i. The next N-1 lines specify the roads linking the houses. Each such line contains two positive integers a and b(1&lt;=a&lt;b&lt;=N) , separated by a single space. These indicate that there is a direct road between the houses no. a and b. 输出The first and only line of the standard output should contain a single integer: the (minimum) number of minutes after which all citizens will be able to play FarmCraft together. 样例输入6 1 8 9 6 3 2 1 3 2 3 3 4 4 5 4 6 样例输出11 HitsExplanation: Byteasar should deliver the computers to the houses in the following order: 3, 2, 4, 5, 6, and 1. The game will be installed after 11, 10, 10, 10, 8, and 9 minutes respectively, in the house number order. Thus everyone can play after 11 minutes. If Byteasar delivered the game in the following order: 3, 4, 5, 6, 2, and 1, then the game would be installed after: 11, 16, 10, 8, 6, and 7 minutes respectively. Hence, everyone could play only after 16 minutes. 题意zuhiul是镇长，住在1号房子，镇里的房子构成了一颗树，现在zuhiul要给镇里其他房子里的小姐姐送电脑，每经过一条路径，zuhiul都要花掉一分钟(才不是为了看小姐姐)。但是zuhiul只负责送不负责装，每个小姐姐的脑子都比较奇怪，有些装的快，有些装的慢，最后zuhiul会返回自己的家给自己装电脑，然后他就可以和小姐姐视频了，但是必须要等所有的小姐姐都装好了才行，现在问你zuhiul最早什么时候可以和所有的小姐姐视频。 分析显然是树上DP，我们考虑定义DP状态，则有 f[i]表示以 i 为根的子树里，花费总时间的最大值是多少 我们定义son_num表示这个节点对应子树的节点数量 然后我们考虑转移，我们首先考虑怎么搞两个子节点的时候，然后进行推广。 不妨假设这两个字节点分别是a和b，然后可以得到先遍历a再遍历b的最大时长为 max(f[a]+1,f[b]+son_num[a]*2+1) 同理，先遍历b的最大时常为max(f[b]+1,f[a]+son_num[b]*2+1) 所以如果有max(f[a]+1,f[b]+son_num[a]2+1)&lt;max(f[b]+1,f[a]+son_num[b]2+1) 因为f[a]+son_num[b]2+1&gt;f[a]+1并且f[b]+son_num[a]2+1&gt;f[b]+1 所以只需要得到 f[b]+son_num[a]2&lt;f[a]+son_num[b]2 也即 f[b]-son_num[b]2&lt;f[a]-son_num[a]2 同样，对于多个节点来说，我们同样只要对每个子节点按照 f[son]-son_num[son]*2降序排序，然后从前往后贪心选就行了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 7e5+10;struct p&#123; long long t,son_num;&#125; peo[maxm];long long len;vector&lt;int&gt;mat[maxm];long long f[maxm];int ind[maxm];bool cmp(int a,int b)&#123; return f[a]-peo[a].son_num*2&gt;f[b]-peo[b].son_num*2;&#125;void dfs(int a,int pre)&#123; peo[a].son_num = 1; if(a!=1) f[a] = peo[a].t; for(int i:mat[a])&#123; if(i==pre) continue; dfs(i,a); &#125; ind[0] = 0; for(int i:mat[a])&#123; if(i==pre) continue; ind[++ind[0]] = i; peo[a].son_num+=peo[i].son_num; &#125; sort(ind+1,ind+ind[0]+1,cmp); long long now = 0; for(int i = 1;i&amp;lt;=ind[0];i++)&#123; f[a] = max(f[a],f[ind[i]]+now+1); now+=peo[ind[i]].son_num*2; &#125;&#125;void solve()&#123; printf("%lld\n",max(f[1],len*2-2+peo[1].t));&#125;int main()&#123; scanf("%lld",&amp;len); for(int i = 1;i&amp;lt;=len;i++) scanf("%lld",&amp;peo[i].t); for(int i = 1,a,b;i&amp;lt;len;i++) &#123; scanf("%d%d",&amp;a,&amp;b); mat[a].push_back(b); mat[b].push_back(a); &#125; dfs(1,0); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
</search>
