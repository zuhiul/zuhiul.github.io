<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Project Euler 684 Inverse Digit Sum]]></title>
    <url>%2F2019%2F12%2F03%2FPE%2FPE684%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Define $s(n)$ to be the smallest number that has a digit sum of $n$. For example $s(10)=19$. Let $S(k)=\sum_{n=1}^k s(n)$. You are given $S(20)=1074$. Further let $f_i$ be the Fibonacci sequence defined by $f_0=0,f_1=1$ and $f_i=f_{i−2}+f_{i−1}$ for all $i≥2$. Find $\sum_{i=2}^{90} S(f_i)$. Give your answer modulo $1\ 000\ 000\ 007$. 题意定义 $s(n)$ 表示最小的数位和为 $n$ 的整数，例如 $s(10) = 19$。 并定义 $S(k) = \sum_{n=1}^k s(n)$ ，例如 $S(20) = 1074$ 。 此外定义 $f_i$ 为fibonacci第 $n$ 项。 求 $\sum_{i=2}^{90} S(f_i) % 1\ 000\ 000\ 007$ 。 分析首先我们有，$s(n)$ 的后缀显然是一串 $9$ ，前缀是某一个数字或者空。这样为最大。 然后一个简单的想法是，我们诸位统计答案，对于每一位来说，显然是存在 $1\rightarrow 9$ 。然后剩下的这个位置一定全是 $9$ 。这样可以统计出答案，但是我们发现，数据量太大了。$o(n)$ 的显然不太够。 我的做法是，我把每个数字都 $+1$ ，这样做的好处是，每一位一定是$1\rightarrow9$ 。然后后面的位数就是一个等比数列，然后稍微处理一下前面几位就可以了。 简单画个示意图，假设 $n = 20$。 老做法是这样： 百位 十位 个位 $0$ $0$ $1\rightarrow9$ $0$ $1\rightarrow 9$ $9$ $1\rightarrow 2$ $9$ $9$ 然后我们诸位统计，答案的计算表达式大概是这样：${\sum_{i=1}^9 1 + 9(n-9)} + {\sum_{i=1}^9 + 9(n-18)}10 + {\sum_{i=1}^2}*100$ 新做法是每个数 $+1$ ，然后补一个 $1$ 然后总答案 $-(n+1)$ 。补 $1$ 后： 百位 十位 个位 $0$ $0$ $1\rightarrow9$ $0$ $1\rightarrow 9$ $0$ $1\rightarrow 3$ $0$ $0$ 然后对于后缀是一个公比为 $10$ 的等比数列。可以直接统计： $45(1+10) + \sum_{i=1}^{3}100 - (20+1)$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9+7;inline int add(long long a,long long b) &#123;a%=mod, b%=mod;return (a+b+mod)%mod;&#125;inline int mul(long long a,long long b) &#123;return a*b%mod;&#125;inline int qpow(long long a, long long b) &#123;/*&#123;&#123;&#123;*/ int ret = 1; while(b) &#123; if(b&amp;1) ret = mul(ret, a); a = mul(a,a); b&gt;&gt;=1; &#125; return ret;&#125;/*&#125;&#125;&#125;*/inline int inv(long long a) &#123; return qpow(a, mod-2); &#125;long long num[100];long long S(long long a) &#123; long long ret = 0; ret = add(ret, mul(45, mul(inv(9), add(qpow(10, a/9), -1)))); long long buf = a%9+1; ret = add(ret, mul(mul(buf, buf+1), mul(inv(2), qpow(10, a/9)))); ret = add(ret, -a-1); return ret;&#125;void init_num() &#123;/*&#123;&#123;&#123;*/ num[1] = 1; cout&lt;&lt;"f_1 = "&lt;&lt;num[1]&lt;&lt;endl; for(int i = 2;i&lt;=90;i++) &#123; num[i] = num[i-1] + num[i-2]; cout&lt;&lt;"f_"&lt;&lt;i&lt;&lt;" = "&lt;&lt;num[i]&lt;&lt;endl; &#125;&#125;/*&#125;&#125;&#125;*/long long ans[100];int main() &#123; init_num(); for(int i = 2;i&lt;=90;i++) &#123; ans[i] = add(ans[i-1],S(num[i])); cout&lt;&lt;"sum of S(f_"&lt;&lt;i&lt;&lt;") = "&lt;&lt;ans[i]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 847 I]]></title>
    <url>%2F2019%2F09%2F23%2FCF%2FCF_847_I%2F</url>
    <content type="text"><![CDATA[I. Noise Level开启传送门 题目描述The Berland’s capital has the form of a rectangle with sizes $n × m$ quarters. All quarters are divided into three types: regular (labeled with the character ‘.’) — such quarters do not produce the noise but are not obstacles to the propagation of the noise; sources of noise (labeled with an uppercase Latin letter from ‘$A$’ to ‘$Z$’) — such quarters are noise sources and are not obstacles to the propagation of the noise; heavily built-up (labeled with the character ‘$*$’) — such quarters are soundproofed, the noise does not penetrate into them and they themselves are obstacles to the propagation of noise. A quarter labeled with letter ‘A’ produces $q$ units of noise. A quarter labeled with letter ‘B’ produces $2\cdot q$ units of noise. And so on, up to a quarter labeled with letter ‘Z’, which produces $26\cdot q$ units of noise. There can be any number of quarters labeled with each letter in the city. When propagating from the source of the noise, the noise level is halved when moving from one quarter to a quarter that shares a side with it (when an odd number is to be halved, it’s rounded down). The noise spreads along the chain. For example, if some quarter is located at a distance $2$ from the noise source, then the value of noise which will reach the quarter is divided by $4$. So the noise level that comes from the source to the quarter is determined solely by the length of the shortest path between them. Heavily built-up quarters are obstacles, the noise does not penetrate into them. The values in the cells of the table on the right show the total noise level in the respective quarters for q = 100, the first term in each sum is the noise from the quarter ‘A’, the second — the noise from the quarter ‘B’.The noise level in quarter is defined as the sum of the noise from all sources. To assess the quality of life of the population of the capital of Berland, it is required to find the number of quarters whose noise level exceeds the allowed level $p$. InputThe first line contains four integers $n, m, q$ and $p$ ($1 ≤ n, m ≤ 250, 1 ≤ q, p ≤ 10^6$) — the sizes of Berland’s capital, the number of noise units that a quarter ‘$A$’ produces, and the allowable noise level. Each of the following $n$ lines contains m characters — the description of the capital quarters, in the format that was described in the statement above. It is possible that in the Berland’s capital there are no quarters of any type. OutputPrint the number of quarters, in which the noise level exceeds the allowed level $p$. Examplesinput13 3 100 140 … A*. .B. output13 input23 3 2 8 B*. BB* BBB output24 input33 4 5 4 ..*B ..** D… output37 NoteThe illustration to the first example is in the main part of the statement. 题意zuhiul家里有很多妹子，但是有一天，妹子们对他都很不满，所以妹子们都在呼叫他，如你所见，妹子在一些点中，并且每个妹子的音量都是他的倍数，其中 A 表示一倍，B表示两倍，最厉害的妹子甚至可以喊出他 26 倍音量（也即 Z ），但是好处是，每个妹子的音量都会随着哈密顿距离指数级减半。zuhiul的耳朵有个承受上线，如果太多杂音，他会受不了。现在问，有多少个位置的音量是zuhiul可接受的。注意，他不能和妹子一个位置。也不能在*上。 分析一个显然的做法是，我们可以直接把每个有音量的地方传播下去，就可以得到一个比较完美的图。然后把音量叠加后枚举每个位置，判断当前音量是否超过阈值即可。 可以发现的是，因为每次音量都是倍减的，所以可以得到，最多倍减log次，所以对于一个音量来说，最大的传播范围是O($log(p_{max})log(p_{max})$) ，所以复杂度是O($nmlog(p_{max})log(p_{max})$) 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;const int maxm = 300;int n, m;long long a, b;char mat[maxm][maxm];long long ans[maxm][maxm];struct p &#123; int x,y,val;&#125;;int dirx[] = &#123;0,0,1,-1&#125;;int diry[] = &#123;1,-1,0,0&#125;;bool vis[maxm][maxm];vector&lt;p&gt; vis_buf;void gao(int a,int b, int val) &#123; queue&lt;p&gt; q; vis_buf.resize(0); q.push(p&#123;a,b,val&#125;); vis_buf.push_back(p&#123;a,b,val&#125;); vis[a][b] = true; ans[a][b] += val; while(!q.empty()) &#123; p buf = q.front(); q.pop(); if(buf.val==0) continue; for(int dir = 0;dir&lt;4;dir++) &#123; int x = buf.x + dirx[dir]; int y = buf.y + diry[dir]; if(x&lt;0||y&lt;0||x&gt;=n||y&gt;=m) continue; if(mat[x][y]=='*') continue; if(vis[x][y]) continue; vis[x][y] = true; vis_buf.push_back(p&#123;x,y,0&#125;); ans[x][y] += buf.val&gt;&gt;1; q.push(p&#123;x,y,buf.val&gt;&gt;1&#125;); &#125; &#125; for(auto i:vis_buf) &#123; vis[i.x][i.y] = false; &#125;&#125;int main() &#123; scanf("%d%d%lld%lld", &amp;n, &amp;m, &amp;a, &amp;b); for (int i = 0; i &lt; n; i++) scanf("%s", mat[i]); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (mat[i][j] == '*') continue; int val = mat[i][j] == '.' ? 0 : (mat[i][j] - 'A' + 1) * a; if(val==0) continue; gao(i,j,val); &#125; &#125; int rans = 0; for(int i = 0;i&lt;n;i++) for(int j = 0;j&lt;m;j++) if(ans[i][j]&gt;b) rans++; printf("%d\n", rans); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1187 E]]></title>
    <url>%2F2019%2F09%2F20%2FCF%2FCF_226_B%2F</url>
    <content type="text"><![CDATA[E. Tree Painting开启传送门 题目描述There are $n$ piles of stones of sizes $a_1,a_2,\dots,a_n$ lying on the table in front of you. During one move you can take one pile and add it to the other. As you add pile $i$ to pile $j$, the size of pile $j$ increases by the current size of pile $i$, and pile $i$ stops existing. The cost of the adding operation equals the size of the added pile. Your task is to determine the minimum cost at which you can gather all stones in one pile. To add some challenge, the stone piles built up conspiracy and decided that each pile will let you add to it not more than $k$ times (after that it can only be added to another pile). Moreover, the piles decided to puzzle you completely and told you $q$ variants (not necessarily distinct) of what $k$ might equal. Your task is to find the minimum cost for each of $q$ variants. InputThe first line contains integer $n$ ($1 \leq n \leq 10^5$) — the number of stone piles. The second line contains $n$ space-separated integers: $a_1,a_2,\dots,a_n$ ($1 \leq a_i \leq 10^9$) — the initial sizes of the stone piles. The third line contains integer $q$ ($1 \leq q \leq 10^5$) — the number of queries. The last line contains $q$ space-separated integers $k_1,k_2,\dots,k_q$ ($1 \leq k_i \leq 10^5$) — the values of number $k$ for distinct queries. Note that numbers $k_i$ can repeat. OutputPrint $q$ whitespace-separated integers — the answers to the queries in the order, in which the queries are given in the input. Please, do not use the $\%lld$ specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the $\%I64d$ specifier. Examplesinput15 2 3 4 1 1 2 2 3 output19 8 NoteIn the first sample one way to get the optimal answer goes like this: we add in turns the $4$-th and the $5$-th piles to the $2$-nd one; then we add the $1$-st pile to the $3$-rd one; we add the $2$-nd pile to the $3$-rd one. The first two operations cost $1$ each; the third one costs $2$, the fourth one costs $5$ (the size of the $2$-nd pile after the first two operations is not $3$, it already is $5$). In the second sample you can add the $2$-nd pile to the $3$-rd one (the operations costs $3$); then the $1$-st one to the $3$-th one (the cost is $2$); then the $5$-th one to the $4$-th one (the costs is $1$); and at last, the $4$-th one to the $3$-rd one (the cost is $2$). 题意这有 $n$ 堆石子，每堆分别有 $a_1,a_2,\dots,a_n$ 个石子放在你面前的桌子上。 在每次移动中，你可以选择一堆石子，并把它合并到其他的堆上。如果你把第 $i$ 堆加到第 $j$ 堆上，那么第 $j$ 堆会增加当前第 $i$ 堆拥有的石子数，并且第 $i$ 堆将不会继续存在。这样操作的代价是第 $i$ 堆的石子数。 你的任务是考虑把这些石子合成一堆的最小代价。 为了增加一些难度，我们规定，合并的石头堆最多被合并 $k$ 次（在这之后，你只能把这一堆合并到其他堆上）。 此外，你将会被询问 $q$ 次，每次给你可能相同的 $k$ 。 你的任务是对于这 $q$ 个询问，给出最小花费。 分析我们首先考虑如果只有一次询问我们怎么做。 假设当前每一堆最多被合并 $k$ 次。 假设当前只有 $k+1$ 堆，我们的做法显然是，排序，把最小的 $k$ 堆合并到最大堆上。 假设当前只有 $k+2$ 堆，那么我们可以得到的是，我们需要合并 $k+1$ 次，所以必然有一堆被合并了两次，除了最大堆之外，其他堆合并了一次。要让代价最小，我们需要让最小堆被合并两次。所以操作是，我们把最小堆合并到除最大堆的某一堆，然后其他堆合并到最大堆。 $\dots$ 假设当前有 $k*k + k + 1$ 堆，我们怎么操作呢？ 首先我们可以确定的是，需要合并 $kk+k$ 次，因为一堆最多被合并 $k$ 次，所以我们可以得到，这 $kk+k$ 次合并中，必定会有 $k$ 次合并，实际上是将两堆及以上合并到了某一堆中，也即：有 $k*k$ 堆被合并了两次， 有 $k$ 堆被合并了一次。所以一个显而易见的贪心策略就出来了。 每次我们倍增 $k$ 挑出这么多堆出来，合并次数增加。为了保证答案最小，显然是，最后合并的是大堆，也就是合并次数最少。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e5+10;int n, q;long long a[maxm];void input() &#123; cin&gt;&gt;n; for(int i = 0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); reverse(a,a+n); for(int i = 1;i&lt;n;i++) a[i] += a[i-1];&#125;long long get_ans(int len) &#123; long long ans = 0; long long rlen = len, cnt = 1; for(int i = 1;i&lt;n;) &#123; int r = min(n-1ll,i+rlen-1); ans += (a[r] - a[i-1])*cnt; cnt++; i = r+1; rlen *= len; &#125; return ans;&#125;long long ans[maxm];void solve() &#123; cin&gt;&gt;q; while(q--) &#123; int len; cin&gt;&gt;len; if(ans[len]) cout&lt;&lt;ans[len]&lt;&lt;' '; else &#123; ans[len] = get_ans(len); cout&lt;&lt;ans[len]&lt;&lt;' '; &#125; &#125; cout&lt;&lt;endl;&#125;int main()&#123; cin.tie(0); ios::sync_with_stdio(false); input(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1187 E]]></title>
    <url>%2F2019%2F09%2F20%2FCF%2FCF_1187_E%2F</url>
    <content type="text"><![CDATA[E. Tree Painting开启传送门 题目描述You are given a tree (an undirected connected acyclic graph) consisting of $n$ vertices. You are playing a game on this tree. Initially all vertices are white. On the first turn of the game you choose one vertex and paint it black. Then on each turn you choose a white vertex adjacent (connected by an edge) to any black vertex and paint it black. Each time when you choose a vertex (even during the first turn), you gain the number of points equal to the size of the connected component consisting only of white vertices that contains the chosen vertex. The game ends when all vertices are painted black. Let’s see the following example: Vertices $1$ and $4$ are painted black already. If you choose the vertex $2$, you will gain $4$ points for the connected component consisting of vertices $2,3,5$ and $6$. If you choose the vertex $9$, you will gain $3$ points for the connected component consisting of vertices $7,8$ and $9$. Your task is to maximize the number of points you gain. InputThe first line contains an integer $n$ — the number of vertices in the tree ($2≤n≤2⋅10^5$). Each of the next $n−1$ lines describes an edge of the tree. Edge $i$ is denoted by two integers $u_i$ and $v_i$, the indices of vertices it connects ($1≤u_i,v_i≤n$, $u_i\neq v_i$). It is guaranteed that the given edges form a tree. OutputPrint one integer — the maximum number of points you gain if you will play optimally. Examplesinput19 1 2 2 3 2 5 2 6 1 4 4 9 9 7 9 8 output136 input25 1 2 1 3 2 4 2 5 output214 NoteThe first example tree is shown in the problem statement. 题意zuhiul认识很多妹子（不超过$2\cdot 10^5$个），妹子之间是个树形关系。他决定每天聊一个妹子，但是他是个强迫症，第一天他可以随便聊任何一个妹子，但是之后每一天，他只能聊和之前聊过的妹子有关系的妹子。每次聊一个妹子之前，他会数一下这个妹子所在的未聊过的连通块的大小，当然，连通块越大他越开心（连通块为 $n$ ，他会得到 $n$ 开心度），现在问你，他聊完所有妹子后，开心度求和后为多少。 分析如果我们强制第一次聊编号为 $1$ 的妹子， 我们考虑怎么统计答案。 一个很直观的想法是，我们可以一次dfs出所有子树的大小，然后对于每棵子树大小求和就是答案。 那么现在问题就转化成了，如何对于每个根求答案。 显然换根可解，但是如何统计换根后的答案呢？ 我们考虑一下，我们以 $1$ 为根的时候怎么算的答案呢？ 每棵子树的大小求和。但是我们可以换个角度看问题，我们不看子树的贡献，我们考虑每个节点的贡献，可以显然的发现，每个节点的贡献就是每个节点到 $1$ 的距离。 所以换根就很直观了。我们定义 $ans[i]$ 表示以 $i$ 为根的答案，$cnt[i]$ 表示以 $1$ 为根的时候，$i$ 子树的大小。所以换根相对于当前节点的父亲的代价就是 $i$ 子树深度-1，其他节点深度+1。所以当前节点相对于父亲的答案是，减少了 $cnt[i]$，增加了 $n-cnt[i]$。也即 $$ans[ind] = ans[pre] - cnt[ind] + (n-cnt[ind]) $$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 2e5+10;int n;vector&lt;int&gt; mat[maxm];long long size[maxm];long long ans[maxm];void dfs(int ind = 1, int pre = 0) &#123; size[ind] = 1; for(auto i:mat[ind]) &#123; if(i==pre) continue; dfs(i, ind); size[ind] += size[i]; &#125; ans[1] += size[ind];&#125;void dfs2(int ind, int pre) &#123; ans[ind] = ans[pre] - size[ind] + (n-size[ind]); for(auto i:mat[ind]) &#123; if(i==pre) continue; dfs2(i, ind); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1, from, to;i&lt;n;i++) &#123; scanf("%d%d",&amp;from,&amp;to); mat[from].push_back(to); mat[to].push_back(from); &#125; dfs(); for(auto i:mat[1]) dfs2(i, 1); long long rans = 0; for(int i = 1;i&lt;=n;i++) rans = max(rans, ans[i]); printf("%lld\n", rans); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1215 E]]></title>
    <url>%2F2019%2F09%2F16%2FCF%2FCF_1215_E%2F</url>
    <content type="text"><![CDATA[E. Marbles开启传送门 题目描述Monocarp has arranged $n$ colored marbles in a row. The color of the $i$-th marble is $a_i$. Monocarp likes ordered things, so he wants to rearrange marbles in such a way that all marbles of the same color form a contiguos segment (and there is only one such segment for each color). In other words, Monocarp wants to rearrange marbles so that, for every color $j$, if the leftmost marble of color $j$ is $l$-th in the row, and the rightmost marble of this color has position $r$ in the row, then every marble from $l$ to $r$ has color $j$. To achieve his goal, Monocarp can do the following operation any number of times: choose two neighbouring marbles, and swap them. You have to calculate the minimum number of operations Monocarp has to perform to rearrange the marbles. Note that the order of segments of marbles having equal color does not matter, it is only required that, for every color, all the marbles of this color form exactly one contiguous segment. InputThe first line contains one integer $n$ ($2≤n≤4\cdot10^5$) — the number of marbles. The second line contains an integer sequence $a_1, a_2, \dots, a_n$($1≤a_i≤20$), where $a_i$ is the color of the $i$-th marble. OutputPrint the minimum number of operations Monocarp has to perform to achieve his goal. Examplesinput17 3 4 2 3 4 2 2 output13 input25 20 1 14 10 2 output20 input313 5 5 4 4 3 5 7 6 5 4 4 6 5 output321 NoteIn the first example three operations are enough. Firstly, Monocarp should swap the third and the fourth marbles, so the sequence of colors is $[3,4,3,2,4,2,2]$. Then Monocarp should swap the second and the third marbles, so the sequence is $[3,3,4,2,4,2,2]$. And finally, Monocarp should swap the fourth and the fifth marbles, so the sequence is $[3,3,4,4,2,2,2]$. In the second example there’s no need to perform any operations. 题意zuhiul认识很多妹子，显然不同的妹子有不同的颜值（颜值最高为20，最小为1），有一天他把他认识的所有妹子召集在一起（不超过$4\cdot 10^5$个），她们站成一排。现在zuhiul想把颜值相同的妹子放在一起，但是妹子们都在玩手机，所以他只能每次叫两个相邻的妹子配合一下交换。现在问你最小交换次数，使得所有颜值相同的妹子坐在一起。 分析当时没做出来，看的题解（orz）， 所以先给官方题解，强烈建议先看官方题解。 The main fact is that the number of colors is less than $20$, which allows us to use exponential solutions. For each pair of colors $(i,j)$, we can calculate $cnt[i][j]$ — the number of swaps required to place all marbles of color $i$ before all marbles of color $j$ (if we consider only marbles of these two colors). We can store a sorted vector for each color, and calculate this information for a fixed pair with two pointers. Then let’s use subset DP to fix the order of colors. Let $d[mask]$ be the minimum number of operations to correctly order all marbles from the $mask$ of colors. Let’s iterate on the next color we consider — it should be a position in binary representation of $mask$ with $0$ in it. We will place all marbles of this color after all marbles we already placed. If we fix a new color $i$, let’s calculate the $sum$ (the additional number of swaps we have to make) by iterating on the bit $j$ equal to $1$ in the $mask$, and increasing 𝑠𝑢𝑚 by $cnt[j][i]$ for every such bit. The new state of DP can be calculated as $nmask=mask|(1&lt;&lt;i)$. So the transition can be implemented as $d[nmask]=min(d[nmask],d[mask]+sum)$. The answer is the minimum number of swaps required to place all the colors, and that is $d[2^{20}-1]$. 因为看的题解，所以没想出第二种解法，用我的话复述一下。 因为不同的颜值数量很少（$&lt;=20$)，所以我们可以在这个方向上下文章。 如果考虑只有两种颜色，我们可以很轻易的知道答案是多少（通过枚举每个不同的位置算贡献）。 于是考虑可以用状压DP来搞，$dp[i]$表示状态为 $i$ 的时候的代价。那么答案显然是$d[2^{20}-1]$. 考虑转移，枚举每个已知答案的子集。我们怎么推算下一个状态的答案呢？ 显然是往里面加了一个之前没有的值。我们不妨设当前状态为$mask$，当前新加的是 $i$ ， $i$ 加进来的代价是 $sum$ 。那么新状态显然就是$nmask=mask|(1&lt;&lt;i)$。并且我们有$ans[nmask] = min(ans[nmask], ans[mask]+sum)$。 剩下的就是考虑怎么算 $sum$。 记得我们刚刚说的吗？对于两种颜值我们怎么计算的？利用两种颜值的计算方法，我们可以预处理处一个代价矩阵$cnt[i][j]$,表示只考虑 $i$ 和 $j$ 两种颜值，我们把这两堆人排好序（ $i$ 在前，$j$ 在后）的代价。 然后可以得到 $ sum = \sum_{j\in mask}^{} cnt[i][j]$ over. 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int n;const int maxm = 1e6;const long long inf = 1e18;vector&lt;long long&gt; mat[22];long long value[22][22];long long ans[1&lt;&lt;21];int main()&#123; scanf("%d",&amp;n); for(int i = 0, a;i&lt;n;i++) &#123; scanf("%d",&amp;a); mat[a].push_back(i); &#125; for(int i = 0;i&lt;=20;i++) mat[i].push_back(maxm&lt;&lt;1); for(int i = 1;i&lt;=20;i++) &#123; if(mat[i].size()==0) continue; for(int j = 1;j&lt;=20;j++) &#123; if(mat[j].size()==0||i==j) continue; long long ind1 = 0; for(auto ind : mat[j]) &#123; if(ind &gt; maxm) continue; while(ind &gt; mat[i][ind1]) ind1++; value[i-1][j-1] += ind1; &#125; &#125; &#125; for(int i = 0;i&lt;(1&lt;&lt;20);i++) ans[i] = inf; ans[0] = 0; for(int mask = 0;mask&lt;(1&lt;&lt;20);mask++) &#123; vector&lt;int&gt; has_bit; for(int i = 0;i&lt;20;i++) if(mask&amp;(1&lt;&lt;i)) has_bit.push_back(i); for(int i = 0;i&lt;20;i++)&#123; if(mask&amp;(1&lt;&lt;i)) continue; long long sum = 0; for(int j = 0;j&lt;has_bit.size();j++) sum+=value[i][has_bit[j]]; int nmask = mask|(1&lt;&lt;i); ans[nmask] = min(ans[nmask], ans[mask]+sum); &#125; &#125; printf("%lld\n", ans[(1&lt;&lt;20)-1]); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 761 E]]></title>
    <url>%2F2019%2F09%2F14%2FCF%2FCF_761_E%2F</url>
    <content type="text"><![CDATA[E. Dasha and Puzzle开启传送门 题目描述Dasha decided to have a rest after solving the problem. She had been ready to start her favourite activity — origami, but remembered the puzzle that she could not solve. The tree is a non-oriented connected graph without cycles. In particular, there always are $n - 1$ edges in a tree with $n$ vertices. The puzzle is to position the vertices at the points of the Cartesian plane with integral coordinates, so that the segments between the vertices connected by edges are parallel to the coordinate axes. Also, the intersection of segments is allowed only at their ends. Distinct vertices should be placed at different points. Help Dasha to find any suitable way to position the tree vertices on the plane. It is guaranteed that if it is possible to position the tree vertices on the plane without violating the condition which is given above, then you can do it by using points with integral coordinates which don’t exceed $10^{18}$ in absolute value. InputThe first line contains single integer $n$ ($1 ≤ n ≤ 30$) — the number of vertices in the tree. Each of next $n - 1$ lines contains two integers $u_i, v_i$ ($1 ≤ u_i, v_i ≤ n$) that mean that the $i$-th edge of the tree connects vertices $u_i$ and $v_i$. It is guaranteed that the described graph is a tree. OutputIf the puzzle doesn’t have a solution then in the only line print “NO”. Otherwise, the first line should contain “YES”. The next n lines should contain the pair of integers $x_i$, $y_i$ (|$x_i$|, |$y_i$| ≤ $10^{18}$) — the coordinates of the point which corresponds to the $i$-th vertex of the tree. If there are several solutions, print any of them. Examplesinput17 1 2 1 3 2 4 2 5 3 6 3 7 output1YES 0 0 1 0 0 1 2 0 1 -1 -1 1 0 2 input26 1 2 2 3 2 4 2 5 2 6 output2NO input34 1 2 2 3 3 4 output3YES 3 3 4 3 5 3 6 3 NoteIn the first sample one of the possible positions of tree is: 题意zuhiul认识很多妹子（不超过30个），妹子之间是个树形关系。zuhiul家很大，所以他想把所有妹子放家里，因为zuhiul比较喜欢整点，所以他希望妹子都在整点上，并且有关系的妹子，他们之间的连线平行于坐标轴，并且关系不能相交，也不能重合（贵圈真乱！）。虽然zuhiul很有钱，但是他家也不是无限大，也即：所有妹子的坐标的绝对值不能超过$10^{18}$。 分析显然的构造题。 首先因为妹子的关系不能相交，并且要平行于坐标轴，所以可以得到如果一个妹子和四个以上的妹子有关系，那么显然就不能构造出来。首先处理这种非法情况。 剩下的显然是一个dfs搞一下，因为无根，直接取$1$为根。 然后显然是找一个比较好的展开方式就行了。一个直观的做法就是按层次展开就行了。但是为了保证关系不交。我们考虑用下面两个规则展开。 1.每层的距离至多为前一层的$\frac{1}{2}$。 2.同层的节点的距离不同。 这样可以保证所有的点在四相扩展的时候不交。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int n;vector&lt;int&gt; son[100];long long dirx[] = &#123;1,-1,0,0&#125;;long long diry[] = &#123;0,0,1,-1&#125;;bool has_position[100];long long ansx[100],ansy[100];void lay(int ind, int pre, long long x,long long y, int dir, int floor) &#123; has_position[ind] = true; ansx[ind] = x; ansy[ind] = y; long long rdis = 1ll&lt;&lt;floor; int dir_ind = 0; for(int i:son[ind]) &#123; if(i==pre) continue; if(dir_ind==(dir^1)) dir_ind++; if(dir_ind&gt;3) &#123; printf("NO"); exit(0); &#125; lay(i, ind, x+dirx[dir_ind]*rdis, y+diry[dir_ind]*rdis, dir_ind, floor-1); rdis--; dir_ind ++ ; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1, from ,to;i&lt;n;i++) &#123; scanf("%d%d",&amp;from,&amp;to); son[from].push_back(to); son[to].push_back(from); &#125; lay(1,0,0,0,-1,50); for(int i = 1;i&lt;=n;i++) if(!has_position[i]) &#123; printf("NO\n"); return 0; &#125; printf("YES\n"); for(int i = 1;i&lt;=n;i++) printf("%lld %lld\n", ansx[i], ansy[i]); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下监听全局键盘输入]]></title>
    <url>%2F2019%2F08%2F04%2Fskill%2Fmac_keyboard_monitor%2F</url>
    <content type="text"><![CDATA[因为这段时间终于狠下心来买了把键盘。然后这两天脑子里面全是如何统计键盘敲击次数，在我踩了几个坑之后，终于搞定了，这里总结一下。 首先就是mac下不支持pyhook，貌似，所以只能用pynput来瞎搞。安装各种依赖就不说了。 首先一个坑点就是，mac为了安全考虑，拒绝一般的程序监听键盘和鼠标等外设的输入。 然后我就想办法给python权限，“系统偏好设置-&gt;安全性与隐私-&gt;完全磁盘访问权限”，给权限整上了，但是我发现一个比较尴尬的事是：依然是跑不起来。然后就各种寻求帮助。 后来发现是要在sudo下运行，我试了一下，还是不行。 最后才发现，需要的权限名字不叫“完全磁盘访问权限”，而是“辅助功能”，服了。我的理解是：你丫都有完全的磁盘访问权限了，还没有辅助功能？开玩笑呢？ 啊，我死了。 这里贴上我抄的代码 123456789101112131415161718192021from pynput import keyboarddef on_press(key): with open('out', 'a+') as f: try: f.write(str(key.char) + '\n') except AttributeError: f.write(str(key) + '\n') f.close()def on_release(key): pass# Collect events until releasedwith keyboard.Listener( on_press=on_press, on_release=on_release) as listener: listener.join()]]></content>
      <tags>
        <tag>体验优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Problems in Set Theory]]></title>
    <url>%2F2019%2F07%2F29%2Fknowledge%2FSet%20Theory%2F</url>
    <content type="text"><![CDATA[$\text{1.Prove Theorem 1 (show that $x$ is in the left-hand set iff it is in the right-hand set).For example,for (d),}$ \begin{eqnarray}x \in(A \cup B) \cap C &amp;\Longleftrightarrow&amp; [x \in(A \cup B) \text { and } x \in C] \\&amp;\Longleftrightarrow&amp; [(x \in A \text { or } x \in B), \text { and } x \in C] \\&amp;\Longleftrightarrow&amp; [(x \in A, x \in C) \text { or }(x \in B, x \in C)]\end{eqnarray} $ A \cup A = A ; A \cap A = A$ \begin{eqnarray}A \cup A &amp;=&amp; \{ x|x \in A \} \cup \{ x|x \in A \}\\&amp;=&amp; \{ x|x \in A \}\\&amp;=&amp;A\\A \cap A &amp;=&amp; \{ x| x \in A \} \cup \{ x|x \in A \}\\&amp;=&amp; \{ x|x \in A \}\\&amp;=&amp;A\\\end{eqnarray} $ A \cup B = B \cup A , A \cap B = B \cap A $ \begin{eqnarray}A \cup B &amp;=&amp; \{ x| x \in A \} \cup \{ x|x \in B \} \\&amp;=&amp; \{ x|x \in A\ or\ x \in B \}\\&amp;=&amp; \{ x|x \in B \} \cup \{ x|x \in A \}\\&amp;=&amp; B \cup A\end{eqnarray}]]></content>
      <tags>
        <tag>Mathematical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Curse of Knowledge]]></title>
    <url>%2F2019%2F07%2F22%2Fknowledge%2FThe_Curse_of_Knowledge%2F</url>
    <content type="text"><![CDATA[知识的诅咒今天看到这个很有意思的词，记录一下。 先扔链接。 英文链接 wiki 用自己的一句话理解来说这件事就是：双方知识的不对等，导致告知者理解不了被告知者因为不清楚某些信息而造成的错误。 因为告知者很难理解在他看来很“常识”的东西，被告知者却不知道。 很多时候，我们描述一个东西，通常会省略我们都认为大家默认如此的东西，但是往往这些我们漏掉的关键信息反而是对方不清楚的。 一个很常见的例子是：我上周要做一个merge数据的操作，老大让我搞一下，当时他的原话是“有时间把这个merge做一下，这个拖了好久了”，然后我就吭哧吭哧开始做了，当我写完设计文档之后，他看完说了句“我说的不是这个merge”。 事实是这样：我们有两部分数据需要做merge。第一部分是上周没做，留下来的，第二部分是一天前没时间做的，我的理解是“拖了很久”，意思应该是第一个，而老大的意思是第二个，因为他觉得第二个是比较紧急的。 这种信息的不对等，导致了我们理解的不一致，如果我继续做的话，必然是有问题的。但是显然大家的理解都没问题，只是知识不对等而已。 知识的诅咒，描述的就是这种现象：当一个人知道一件事后，他就无法想象自己是不知道这件事的。 或许我们可以通过这看懂另一句话：门当户对。 我其实一直不理解为什么要门当户对，后来我渐渐明白一件事：两个环境相似的家庭诞生的两个孩子，可能思维观点一致的可能性更高，稳定的婚姻就越容易。成长环境其实很能限制一个人的发展，每个人的想法很大程度基于自己的成长过程。 同理，我们也很好解释，为啥会产生“知识的诅咒”这种现象。]]></content>
      <tags>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 大数]]></title>
    <url>%2F2019%2F06%2F03%2Fknowledge%2FBigInt%2F</url>
    <content type="text"><![CDATA[闲来无事写了一发玩玩。。。 不保证正确性。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;using namespace std;const int mod = 10000;char for_cin[mod&lt;&lt;8];struct bigInt &#123;/*&#123;&#123;&#123;*/ bool neg; vector&lt;int&gt; num; bigInt() &#123; neg = false; &#125; bigInt(int len) &#123; neg = false; num.resize(len); for(int i = 0;i&lt;len;i++) num[i] = 0; &#125;&#125;;/*&#125;&#125;&#125;*/void relen(bigInt&amp;a) &#123;/*&#123;&#123;&#123;*/ int len = a.num.size(); for(int i = len-1;i&gt;0;i--) &#123; if(a.num[i] &amp;&amp; a.num[i-1]&lt;0) &#123; a.num[i]--; a.num[i-1] += mod; &#125; &#125; while(a.num.size()&gt;=1&amp;&amp;a.num[a.num.size()-1]==0) a.num.resize(a.num.size()-1); if(a.num.size()==0) a.num.push_back(0);&#125;/*&#125;&#125;&#125;*/void show(bigInt a,char b = '\n')&#123;/*&#123;&#123;&#123;*/ if(a.neg) putchar('-'); int len = a.num.size(); printf("%d",a.num[len-1]); for(int i = len-2;i&gt;=0;i--)&#123; printf("%04d",a.num[i]); &#125; cout&lt;&lt;b;&#125;/*&#125;&#125;&#125;*/bool input(bigInt &amp; ret)&#123;/*&#123;&#123;&#123;*/ if(scanf("%s",for_cin)==EOF) return false; ret.num.resize(0); int startInd = 0; int len = strlen(for_cin); if(for_cin[0]=='-') &#123; startInd = 1; ret.neg = true; &#125; int i; for(i = len-4;i&gt;=startInd;i-=4)&#123; ret.num.push_back(atoi(for_cin+i)); for_cin[i] = '\0'; &#125; if(i!=startInd) ret.num.push_back(atoi(for_cin+startInd)); relen(ret); return true;&#125;/*&#125;&#125;&#125;*/bigInt trans(int a)&#123;/*&#123;&#123;&#123;*/ bigInt ret(0); if(a&lt;0) ret.neg = true,a = -a; while(a)&#123; ret.num.resize(ret.num.size()+1); ret.num[ret.num.size()-1] = a%mod; a/=mod; &#125; relen(ret); return ret;&#125;/*&#125;&#125;&#125;*/bigInt trans(long long a)&#123;/*&#123;&#123;&#123;*/ bigInt ret(0); if(a&lt;0) ret.neg = true,a = -a; while(a)&#123; ret.num.resize(ret.num.size()+1); ret.num[ret.num.size()-1] = a%mod; a/=mod; &#125; relen(ret); return ret;&#125;/*&#125;&#125;&#125;*/bool equal(bigInt a,bigInt b)&#123;/*&#123;&#123;&#123;*/ if(a.neg!=b.neg) return false; if(a.num.size()!=b.num.size()) return false; int len = a.num.size(); for(int i = 0;i&lt;len;i++) if(a.num[i]!=b.num[i]) return false; return true;&#125;/*&#125;&#125;&#125;*/bool bigger(bigInt a,bigInt b) &#123;/*&#123;&#123;&#123;*/ if(a.neg&amp;&amp;!b.neg) return false; if(!a.neg&amp;&amp;b.neg) return true; if(a.neg&amp;&amp;b.neg) &#123; a.neg = b.neg = false; bool ret = bigger(b,a); a.neg = b.neg = true; return ret; &#125; if(a.num.size()&gt;b.num.size()) return true; if(a.num.size()&lt;b.num.size()) return false; int len = a.num.size(); for(int i = len-1;i&gt;=0;i--)&#123; if(a.num[i]!=b.num[i]) return a.num[i]&gt;b.num[i]; &#125; return false;&#125;/*&#125;&#125;&#125;*/bigInt add(bigInt a,bigInt b) &#123;/*&#123;&#123;&#123;*/ bigInt ret(max(a.num.size(),b.num.size())+1); if(a.neg&amp;&amp;b.neg)&#123; a.neg = b.neg = false; ret = add(a,b); ret.neg = true; return ret; &#125; if(a.neg)&#123;/*&#123;&#123;&#123;*/ a.neg = false; if(bigger(a,b)) &#123; for(int i = b.num.size()-1;i&gt;=0;i--)&#123; a.num[i]-=b.num[i]; if(a.num[i]&lt;0) &#123; a.num[i]+=mod; a.num[i+1]--; &#125; &#125; relen(a); a.neg = true; return a; &#125;else&#123; for(int i = a.num.size()-1;i&gt;=0;i--)&#123; b.num[i]-=a.num[i]; if(b.num[i]&lt;0)&#123; b.num[i]+=mod; b.num[i+1]--; &#125; &#125; relen(b); return b; &#125; &#125;/*&#125;&#125;&#125;*/ if(b.neg) return add(b,a); int maxlen = max(a.num.size(),b.num.size()); a.num.resize(maxlen+1); int minlen = min(a.num.size(),b.num.size()); for(int i = 0;i&lt;minlen;i++)&#123; a.num[i]+=b.num[i]; if(a.num[i]&gt;=mod) &#123; a.num[i]-=mod; a.num[i+1]++; &#125; b.num[i] = 0; &#125; relen(a); return a;&#125;/*&#125;&#125;&#125;*/bigInt sub(bigInt a,bigInt b)&#123;/*&#123;&#123;&#123;*/ b.neg = ~b.neg; return add(a,b);&#125;/*&#125;&#125;&#125;*/bigInt mul(bigInt a,bigInt b)&#123;/*&#123;&#123;&#123;*/ int lena = a.num.size(); int lenb = b.num.size(); int len = lena+lenb; bigInt ret(len); long long add = 0; for(int i = 0;i&lt;len;i++)&#123; long long buf = add; for(int j = max(0,i-lenb+1);j&lt;=i&amp;&amp;j&lt;lena;j++) buf = buf+a.num[j]*b.num[i-j]; add = buf/mod; ret.num[i] = buf%mod; &#125; ret.neg = (a.neg!=b.neg); relen(ret); return ret;&#125;/*&#125;&#125;&#125;*/bigInt exec(bigInt a,int b)&#123;/*&#123;&#123;&#123;*/ bool neg = (b&lt;0); bigInt ret(a.num.size()); ret.neg = (a.neg!=neg); a.neg = false; int buf = 0; for(int i = a.num.size()-1;i&gt;=0;i--)&#123; buf = buf*mod+a.num[i]; ret.num[i] = buf/b; buf%=b; &#125; relen(ret); return ret;&#125;/*&#125;&#125;&#125;*/bigInt exec(bigInt a,bigInt b)&#123;/*&#123;&#123;&#123;*/ bigInt base = trans(1); bigInt big10 = trans(10); bigInt big0 = trans(0); bigInt ans = trans(0); bool neg = (a.neg!=b.neg); a.neg = b.neg = false; while(bigger(a,mul(b,big10))) &#123; base = mul(base,big10); b = mul(b,big10); &#125; while(!equal(base,big0)) &#123; while(bigger(a,b)) &#123; ans = add(ans,base); a = sub(a,b); &#125; b = exec(b,10); base = exec(base,10); &#125; ans.neg = neg; return ans;&#125;/*&#125;&#125;&#125;*/int Mod(bigInt a,int b)&#123; int ret = 0; for(int i = a.num.size()-1;i&gt;=0;i--)&#123; ret = ret*mod+a.num[i]; ret%=b; &#125; return ret;&#125;bigInt table[mod];int main()&#123; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序对拍器]]></title>
    <url>%2F2019%2F05%2F29%2Fskill%2Fprogram_beat%2F</url>
    <content type="text"><![CDATA[对拍器123456789101112131415g++ -std=c++11 my.cpp -o myg++ -std=c++11 data.cpp -o datag++ -std=c++11 ac.cpp -o acwhile true; do ./data &gt; in ./my &lt; in &gt; my.out ./ac &lt; in &gt; ac.out if diff my.out ac.out; then ((var++)) echo $var else printf "WA\n" exit 0 fidone]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 63]]></title>
    <url>%2F2019%2F04%2F28%2FCF%2FEducational%20Codeforces%20Round%2063%2F</url>
    <content type="text"><![CDATA[F. Delivery Oligopoly开启传送门 题目描述The whole delivery market of Berland is controlled by two rival companies: BerEx and BerPS. They both provide fast and reliable delivery services across all the cities of Berland. The map of Berland can be represented as an undirected graph. The cities are vertices and the roads are edges between them. Each pair of cities has no more than one road between them. Each road connects different cities. BerEx and BerPS are so competitive that for each pair of cities $(v,u)$ they have set up their paths from $v$ to $u$ in such a way that these two paths don’t share a single road. It is guaranteed that it was possible. Now Berland government decided to cut down the road maintenance cost by abandoning some roads. Obviously, they want to maintain as little roads as possible. However, they don’t want to break the entire delivery system. So BerEx and BerPS should still be able to have their paths between every pair of cities non-intersecting. What is the minimal number of roads Berland government can maintain? More formally, given a 2-edge connected undirected graph, what is the minimum number of edges that can be left in it so that the resulting graph is also 2-edge connected? InputThe first line contains two integers $n$ and $m$ ($3\leq n\leq14$, $n\leq m\leq \frac{n(n-1)}{2}$) — the number of cities and the number of roads between them. Each of the next 𝑚 lines contains two integers $v$ and $u$ ($1\leq v,u\leq n,v\neq u$) — the cities connected by the next road. It is guaranteed that each pair of cities has no more than one road between them. It is guaranteed that each pair of cities have at least two paths between them that don’t share a single road. OutputThe first line should contain a single integer $k$ — the minimum number of roads Berland government can maintain so that BerEx and BerPS are still able to have their paths between every pair of cities non-intersecting. The next $k$ lines should contain the list of roads which are being maintained. Each line of form “$v\ u$”, where $v$ and $u$ are cities connected by the next road. If there are multiple lists of minimum size, print any of them. The order of roads in the list doesn’t matter. Examplesinput13 31 22 33 1 output131 33 21 2 input24 51 21 42 34 31 3 output241 44 33 21 2 input36 101 22 33 13 44 55 64 62 51 63 5 output361 66 55 44 33 21 2 NoteHere are graphs from the examples, red edges are the maintained ones. 题意给你一个不超过14个节点的无向图，让你找到满足一下条件的一个子图： 包含所有点 包含尽可能少的边 子图中任意两个点存在两条完全不交的路径 让你输出一个任意符合题意的子图。 分析当时没做出来，看题解才做出来的。建议先看原题解。如下： Let’s use dynamic programming to solve this problem. We will start with a single biconnected component consisting of vertex $0$, and connect other vertices to it. So, the state of our dynamic programming will be a $mask$ of vertices that are in the same biconnected component with $0$. How can we extend a biconnected component in such a way that some other vertices are added into it, but it is still biconnected? We will add a path (possibly cyclic) that starts in some vertex $x$ belonging to the $mask$, goes through some vertices not belonging to the $mask$, and ends in some vertex $y$ belonging to the $mask$ (possibly $x=y$). If for every triple ($x,y,addmask$) we precalculate some path that starts in $x$, goes through vertices from $addmask$ and ends in $y$ (and $addmask$ does not contain neither $x$ nor $y$), then we can solve the problem in $O(3^nn^2)$: there will be $2^n$ states, for every state we will iterate on two vertices $x$ and $y$ belonging to the $mask$, and the number of possible pairs of non-intersecting masks $mask$ and $addmask$ is $O(3^n)$. The only thing that’s left is precalculating the paths for triples ($x,y,addmask$). That can be done with auxiliary dynamic programming $dp2[x][y][addmask]$ which will denote whether such a path exists. For every edge ($u,v$) of the original graph, $dp2[u][v][0]$ is true, and we can go from $dp2[x][y][addmask]$ to some state $dp2[x][z][addmask^{‘}]$, where $addmask^{‘}$ will contain all vertices from $addmask$ and vertex $y$ (and we should ensure that there is an edge ($y,z$) in the graph and the $addmask$ didn’t contain vertex $y$ earlier). We should also somehow be able to restore the paths from this dp, and we also should be careful not to choose the same edge twice (for example, if we start a path by edge ($x,y$), we should not use the same edge to return to $x$) — both these things can be done, for example, by storing next-to-last vertex in the path. 我基本是看完题解才有想法的，和题解写的一模一样，（其实不一样，我写的比标程丑）。 大体思路还是很清晰的。 首先，我们可以很轻松的发现，答案一定是很多环交在了一起构成了答案对应的子图，然后对于任何一个存在很多环相交的图来说，我们可以拆成一个环和很多很多边构成的，如下图： 同样的我们可以很轻松的得到，任何一个环都可以作为拆分后唯一的环。剩下的问题就是我们怎么找到所有的边了。也即怎么找到我们需要的所有路径。我们做以下定义。 我们找到一条从$a$到$b$的路径，并且其中包括$mask$对应的其他点，我们假设$dp2[a][b][mask]$表示是否存在一条从$a$到$b$的路径，并且还包含了$mask$点，例如： $dp2[1][3][1] = 1$表示存在一条$1-0-3$的路径 $dp2[3][5][3] = 1$表示存在一条从$3$到$5$的路径，其中包含$0$号点和$1$号点，路径可能是$3-0-1-5$，也可能是$3-1-0-5$。 对于他的转移显然比较好想，直接枚举下一个点是谁就行了。 然后我们取出任意一个节点表示当前符合答案的子图的子图。因为一个点的时候显然符合答案（因为一对都没有）。然后我们在这个子图的子图中不断的添加边构成环，最后判断得到的全图是否满足答案就行了。。。。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 14;const int maxm = 1&lt;&lt;maxn;int n,m,upper;int dp[maxm|10];//记录答案是否存在，也即当前子图是否满足条件（子图中任意两个点存在两条完全不交的路径）bool dp2[maxn][maxn][maxm];//表示是否存在一条从i到j，包含mask对应点的路径int last[maxn][maxn][maxm];//用来记录i到j中上一个点是谁，用来输出路径vector&lt;int&gt; bit[maxm|10];//表示mask中对应的点的编号vector&lt;int&gt; mat[maxm|10];//存输入的图pair&lt;int,int&gt; con[maxm|10];//表示mask对应的两个外部点，也就是路径的起点终点int addmask[maxm|10];//mask对应的外部边对应的maskvoid show_bit(int a)&#123; if(a) show_bit(a&gt;&gt;1); else return ; if(a&amp;1) cout&lt;&lt;1; else cout&lt;&lt;0;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; upper = 1&lt;&lt;n; for(int i = 0,a,b;i&lt;m;i++)&#123; cin&gt;&gt;a&gt;&gt;b; a--,b--; mat[a].push_back(b); mat[b].push_back(a); &#125; memset(dp,0x3f,sizeof dp); memset(dp2,false,sizeof dp2); for(int i = 0;i&lt;n;i++) for(auto j: mat[i])&#123; dp2[i][j][0] = 1; last[i][j][0] = i; &#125; for(int mask = 0;mask&lt;upper;mask++) for(int j = 0;j&lt;n;j++) if(mask&amp;(1&lt;&lt;j)) bit[mask].push_back(j); for(int mask = 0;mask&lt;upper;mask++)&#123; for(int i = 0;i&lt;n;i++)&#123; if(mask&amp;(1&lt;&lt;i)) continue; for(int j = 0;j&lt;n;j++)&#123; if(mask&amp;(1&lt;&lt;j)) continue; if(i==j||dp2[i][j][mask]==false) continue; for(auto z:mat[j])&#123; if(mask&amp;(1&lt;&lt;z)) continue; if(z==last[i][j][mask]) continue; if(dp2[i][z][mask|(1&lt;&lt;j)]==false)&#123; last[i][z][mask|(1&lt;&lt;j)] = j; dp2[i][z][mask|(1&lt;&lt;j)] = true; &#125; &#125; &#125; &#125; &#125; dp[1] = 0; for(int mask = 0;mask &lt; upper;mask++) &#123; for(int add = mask;add;add = (add-1)&amp;mask)&#123; int pre = add^mask; int cnt = __builtin_popcount(add)+1; if(dp[pre]+cnt&gt;=dp[mask]) continue; bool flag = false; for(auto x:bit[pre])&#123; for(auto y: bit[pre])&#123; if(dp2[x][y][add])&#123; dp[mask] = dp[pre]+cnt; con[mask] = make_pair(x,y); addmask[mask] = add; &#125; &#125; &#125; &#125; &#125; if(dp[(1&lt;&lt;n)-1]==inf) cout&lt;&lt;-1&lt;&lt;endl; else &#123; cout&lt;&lt;dp[(1&lt;&lt;n)-1]&lt;&lt;endl; int cur = (1&lt;&lt;n) - 1; while(cur!=1)&#123; int add = addmask[cur]; int x = con[cur].first; int y = con[cur].second; cur^=add; while(add)&#123; int ny = last[x][y][add]; cout&lt;&lt;y+1&lt;&lt;' '&lt;&lt;ny+1&lt;&lt;endl; y = ny; add^=(1&lt;&lt;ny); &#125; cout&lt;&lt;x+1&lt;&lt;' '&lt;&lt;y+1&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 553]]></title>
    <url>%2F2019%2F04%2F19%2FCF%2FCodeforces_Round_553%2F</url>
    <content type="text"><![CDATA[F. Sonya and Informatics开启传送门 题目描述A girl named Sonya is studying in the scientific lyceum of the Kingdom of Kremland. The teacher of computer science (Sonya’s favorite subject!) invented a task for her. Given an array $a$ of length $n$, consisting only of the numbers $0$ and $1$, and the number $k$. Exactly $k$ times the following happens: Two numbers $i$ and $j$ are chosen equiprobable such that ($1\leq i&lt;j\leq n$). The numbers in the $i$ and $j$ positions are swapped. Sonya’s task is to find the probability that after all the operations are completed, the $a$ array will be sorted in non-decreasing order. She turned to you for help. Help Sonya solve this problem. It can be shown that the desired probability is either $0$ or it can be represented as $\frac{P}{Q}$, where $P$ and $Q$ are coprime integers and $Q\not\equiv0(mod\ 10^9+7)\textscA$. InputThe first line contains two integers $n$ and $k$ ($2\leq n\leq 100,1\leq k\leq 10^9$) — the length of the array $a$ and the number of operations. The second line contains $n$ integers $a_1,a_2,\dots,a_n$ ($0\leq a_i\leq 1$) — the description of the array $a$. OutputIf the desired probability is $0$, print $0$, otherwise print the value $P\cdot Q^{-1}$ ($mod\ 10^9+7$), where $P$ and $Q$ are defined above. Examplesinpus13 2 0 1 0 output1333333336 input25 1 1 1 1 0 0 output20 input36 4 1 0 0 1 1 0 output3968493834 NoteIn the first example, all possible variants of the final array $a$, after applying exactly two operations: $(0,1,0)$, $(0,0,1)$, $(1,0,0)$, $(1,0,0)$, $(0,1,0)$, $(0,0,1)$, $(0,0,1)$, $(1,0,0)$, $(0,1,0)$. Therefore, the answer is $\frac{3}{9}=\frac{1}{3}$. In the second example, the array will not be sorted in non-decreasing order after one operation, therefore the answer is 0. 题意给你一个长度为n的01序列，每次随机从中选择两个出来，交换一下，一共这样操作k次，问你经过k次交换之后，序列变成不降($00\dots 0011\dots 11$)的概率是？ 分析首先序列里面的$0$和$1$的数量是固定的，不妨设分别有$len_a$和$len_b$个。 也就是说在交换$k$次之后要保证前$len_a$个为$0$，后$len_b$个为$1$,如下$$\underbrace{00\dots 00}_{len_a} \underbrace{11\dots 11}_{len_b}$$ 然后我们分别统计前半段后半段$0$和$1$的数量，分别定义为$a_0,a_1,b_0,b_1$。例如$$\underbrace{\underbrace{\overbrace{01010000101110100}^{a_1=7}}_{a_0=10}}_{len_a=17}\underbrace{\underbrace{\overbrace{000101111101010}^{b_1=8}}_{b_0=7}}_{len_b=15}\tag{3}$$ 然后考虑一次交换产生的效果： $b_1$增加：$a_1$和$b_0$交换，使得后半段多了一个1，例如$$\underbrace{\underbrace{\overbrace{01010000101110000}^{a_1=6}}_{a_0=11}}_{len_a=17}\underbrace{\underbrace{\overbrace{010101111101010}^{b_1=9}}_{b_0=6}}_{len_b=15}\tag{2}$$ $b_1$减少：$a_0$和$b_1$交换，使得后半段少了一个1，例如$$\underbrace{\underbrace{\overbrace{01010000101110101}^{a_1=8}}_{a_0=9}}_{len_a=17}\underbrace{\underbrace{\overbrace{000101111101000}^{b_1=7}}_{b_0=8}}_{len_b=15}\tag{1}$$ 其他情况不影响$0$和$1$的数量。 然后多次操作和一次操作怎么联系起来呢？ 看到这个数据量$n = 100$，一次变多次，一个自然的想法就是快速幂啊啊啊啊啊啊啊啊啊啊。 然后就用上面的式子构造转移矩阵，然后快速幂，就能得到有解的方案数，然后除掉总方案数就行了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9+7;long long add(long long a,long long b)&#123;return (a+b)%mod;&#125;long long mul(long long a,long long b)&#123;return a*b%mod;&#125;long long qpow(long long a,long long b = mod-2)&#123;/*&#123;&#123;&#123;*/ long long ret = 1; while(b)&#123; if(b&amp;1) ret = mul(ret,a); a = mul(a,a); b&gt;&gt;=1; &#125; return ret;&#125;/*&#125;&#125;&#125;*/const int maxm = 105,inv_2 = qpow(2);long long C(long long a)&#123; return mul(inv_2,mul(a,add(a,mod-1)));&#125;int n,k,len_a,len_b;int num[maxm];struct matrix&#123; long long num[maxm][maxm];&#125;;matrix mul(matrix a,matrix b)&#123;/*&#123;&#123;&#123;*/ matrix c; memset(c.num,0,sizeof(c.num)); for(int i = 0;i&lt;=len_b;i++) for(int j = 0;j&lt;=len_b;j++) if(a.num[i][j]) for(int k = 0;k&lt;=len_b;k++) c.num[i][k] = add(c.num[i][k],mul(a.num[i][j],b.num[j][k])); return c;&#125;/*&#125;&#125;&#125;*/matrix qpow(matrix a,long long b)&#123; matrix e; for(int i = 0;i&lt;=len_b;i++) for(int j = 0;j&lt;=len_b;j++) e.num[i][j]=(i==j); while(b)&#123; if(b&amp;1) e = mul(e,a); a = mul(a,a); b&gt;&gt;=1; &#125; return e;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); int all = C(n); for(int i = 0;i&lt;n;i++)&#123;/*&#123;&#123;&#123;*/ scanf("%d",num+i); if(num[i]) len_b++; else len_a++; &#125;/*&#125;&#125;&#125;*/ matrix base; for(int i = 0;i&lt;=len_b;i++)&#123; for(int j = max(0,i-1);j&lt;=min(len_b,i+1);j++)&#123; int b1 = j,b0 = len_b - j,a0 = len_a - b0,a1 = len_a - a0; if(i==j-1) base.num[i][j] = a0*b1; else if(i==j+1) base.num[i][j] = a1*b0; else base.num[i][j] = add(all,add(mod - a0*b1,mod - a1*b0)); &#125; &#125; int cnt = 0; for(int i = len_a;i&lt;n;i++) if(num[i]) cnt++; matrix ano; memset(ano.num,0,sizeof(ano.num)); ano.num[cnt][0] = 1; base = mul(qpow(base,k),ano); long long ans = base.num[len_b][0]; ans = mul(ans,qpow(qpow(C(n),k))); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 552]]></title>
    <url>%2F2019%2F04%2F17%2FCF%2FCodeforces_Round_552%2F</url>
    <content type="text"><![CDATA[F. Shovels Shop开启传送门 题目描述There are $n$ shovels in the nearby shop. The $i$-th shovel costs $a_i$ bourles. Misha has to buy exactly $k$ shovels. Each shovel can be bought no more than once. Misha can buy shovels by several purchases. During one purchase he can choose any subset of remaining (non-bought) shovels and buy this subset. There are also $m$ special offers in the shop. The $j$-th of them is given as a pair $(x_j,y_j)$, and it means that if Misha buys exactly $x_j$ shovels during one purchase then $y_j$ most cheapest of them are for free (i.e. he will not pay for $y_j$ most cheapest shovels during the current purchase). Misha can use any offer any (possibly, zero) number of times, but he cannot use more than one offer during one purchase (but he can buy shovels without using any offers). Your task is to calculate the minimum cost of buying $k$ shovels, if Misha buys them optimally. InputThe first line of the input contains three integers $n,m$ and $k$ ($1\leq n,m\leq 2\cdot 10^5,1\leq k\leq min(n,2000)$) - the number of shovels in the shop, the number of special offers and the number of shovels Misha has to buy, correspondingly. The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_1\leq 2\cdot 10^5$), where $a_i$ is the cost of the $i$-th shovel. The next $m$ lines contain special offers. The $j$-th of them is given as a pair of integers ($x_i,y_i$) ($1\leq y_i\leq x_i\leq n$) and means that if Misha buys exactly $x_i$ shovels during some purchase, then he can take $y_i$ most cheapest of them for free. OutputPrint one integer $-$ the minimum cost of buying $k$ shovels if Misha buys them optimally. Examplesinpus17 4 5 2 5 4 2 6 3 1 2 1 6 5 2 1 3 1 output17 input29 4 8 6 8 5 1 8 1 1 2 1 9 2 8 4 5 3 9 7 output217 input35 1 4 2 5 7 4 6 5 4 output317 NoteIn the first example Misha can buy shovels on positions 1 and 4 (both with costs 2) during the first purchase and get one of them for free using the first or the third special offer. And then he can buy shovels on positions 3 and 6 (with costs 4 and 3) during the second purchase and get the second one for free using the first or the third special offer. Then he can buy the shovel on a position 7 with cost 1. So the total cost is 4+2+1=7. In the second example Misha can buy shovels on positions 1, 2, 3, 4 and 8 (costs are 6, 8, 5, 1 and 2) and get three cheapest (with costs 5, 1 and 2) for free. And then he can buy shovels on positions 6, 7 and 9 (all with costs 1) without using any special offers. So the total cost is 6+8+1+1+1=17. In the third example Misha can buy four cheapest shovels without using any special offers and get the total cost 17. 题意zuhiul 都20了，还没有对象，然后家里人给安排了n个菇凉和他相亲，他需要挑出k个来相亲。相亲当然是男方请客，和每个妹子相亲的成本是不一样的，每个妹子都有一个固定成本，为了促进zuhiul相亲，家里人说，如果一次邀约了$x_i$个菇凉，家里就给报销这次相亲的所有菇凉中，成本最低的$y_i$个菇凉的花费，现在zuhiul想花最少的钱相完所有的亲，他最少要花多少钱呢？ 分析首先可以确定的是，我们一定找n个中最便宜的k个来相亲，因为如果不是这k个，我们一定可以合理的交换，得到一个不劣的解。 然后排序，干掉贵的那一部分。 那么如果不考虑报销的话，成本是固定的，所以剩下的问题就是怎么得到尽可能多的报销。 然后，显然是一个$n^2$的dp了。 我们可以预处理出，如果一次约j个女孩的话，可以省掉多少个女孩的费用，设为sub[j] 假设每个女孩的费用为values[i] 考虑转移，设dp[i]表示邀约前n个妹子的最小花费，那么可以得到$$dp[i] = \min_{j=1}^{i} (dp[i-j] + \sum_{k=i-j+sub[j]+1}^{i} values[k])$$ 然后对于后面的求和，可以搞一个前缀和来维护，复杂度$O(n^2)$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int maxk = 2005;const int maxm = 2e5+10;int sub[maxk];int n,m,k;int values[maxm];long long sum[maxm];int ans[maxk];long long cost[maxk];int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i = 1;i&lt;=n;i++) scanf("%d",values+i); sort(values+1,values+n+1); for(int i = 1;i&lt;=n;i++) sum[i] = sum[i-1]+values[i]; while(m--) &#123;/*&#123;&#123;&#123;*/ int a,b; scanf("%d%d",&amp;a,&amp;b); if(a&gt;k) continue; sub[a] = max(sub[a],b); &#125;/*&#125;&#125;&#125;*/ for(int i = 1;i&lt;=k;i++) sub[i] = max(sub[i],sub[i-1]); memset(cost,0x3f,sizeof(cost)); cost[0] = 0; for(int i = 1;i&lt;=k;i++)&#123; cost[i] = sum[i]; for(int j = 1;j&lt;=i;j++)&#123; cost[i] = min(cost[i],cost[i-j]+sum[i]-sum[i-j+sub[j]]); &#125; &#125; printf("%lld\n",cost[k]); return 0;&#125; G. Minimum Possible LCM开启传送门 题目描述You are given an array $a$ consisting of $n$ integers $a_1,a_2,\dots,a_n$. Your problem is to find such pair of indices $i,j (1\leq i&lt;j\leq n)$ that $lcm(a_i,a_j)$ is minimum possible. $lcm(x,y)$ is the least common multiple of $x$ and $y$ (minimum positive number such that both $x$ and $y$ are divisors of this number). ###Input The first line of the input contains one integer $n$ ($2\leq n\leq10^6$) — the number of elements in $a$. The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_i\leq 10^7$), where $a_i$ is the $i$-th element of $a$. OutputPrint two integers $i$ and $j$ ($1\leq i&lt;j\leq n$) such that the value of $lcm(a_i,a_j)$ is minimum among all valid pairs $i,j$. If there are multiple answers, you can print any. Examplesinpus15 2 4 8 3 6 output11 2 input25 5 2 11 3 7 output22 4 input36 2 5 10 1 10 2 output31 4 题意zuhiul有很多妹子，今天他想找两个妹子出去吃饭，每个妹子都有一个权值，他今天要花的钱等于这两个妹子权值的lcm，他想花尽可能少的钱，他该约哪两个妹子呢？ 分析我们考虑一下那种情况可以构成解。 首先对于重复的数据，我们可以干掉，因为相同值的lcm等于本身，所以我们可以把相同的权值干掉，然后剩下的数据都是不同的。 然后我们考虑权值都不相同的时候怎么构成解。 首先，这两个数肯定有一个gcd，哪怕gcd = 1，然后我们考虑一下，这$n*(n-1)&gt;&gt;1$这么多对数中，哪些对可以构成解，一个显而易见的想法就是，我们可以枚举gcd。 然后我们枚举这个gcd的所有倍数，这样能不重不漏的枚举出所有对数，然后我们考虑怎么减少枚举量。假设当前的$gcd=x$,因为前一步保证了没有相同的数据，所以我们只要找到最小的$i,j$使得$i\%x==0\&amp;\&amp;j\%x==0$，然后就用这两个数更新一下答案就行了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+10;int n;int app[maxm];struct p&#123; long long ans; int ind1,ind2; bool operator&lt;(const p a) const &#123; return ans&lt;a.ans; &#125;&#125;;int main()&#123; scanf("%d",&amp;n); p ans = &#123;1000000000000000000ll,-1,-1&#125;; for(int i = 1,buf;i&lt;=n;i++)&#123; scanf("%d",&amp;buf); if(app[buf]) ans = min(ans,&#123;buf,app[buf],i&#125;); app[buf] = i; &#125; for(int i = 1;i&lt;maxm;i++)&#123; int buf[3] = &#123;0&#125;; for(int j = i;j&lt;maxm;j+=i)&#123; if(app[j])&#123; buf[++buf[0]] = j; if(buf[0]==2)&#123; ans = min(ans,&#123;1ll*buf[1]*buf[2]/i,app[buf[1]],app[buf[2]]&#125;); break; &#125; &#125; &#125; &#125; if(ans.ind1&gt;ans.ind2) swap(ans.ind1,ans.ind2); printf("%d %d\n",ans.ind1,ans.ind2); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 551]]></title>
    <url>%2F2019%2F04%2F14%2FCF%2FCodeforces_Round_551%2F</url>
    <content type="text"><![CDATA[A. Serval and Bus开启传送门 题目描述It is raining heavily. But this is the first day for Serval, who just became 3 years old, to go to the kindergarten. Unfortunately, he lives far from kindergarten, and his father is too busy to drive him there. The only choice for this poor little boy is to wait for a bus on this rainy day. Under such circumstances, the poor boy will use the first bus he sees no matter where it goes. If several buses come at the same time, he will choose one randomly. Serval will go to the bus station at time $t$, and there are $n$ bus routes which stop at this station. For the $i$-th bus route, the first bus arrives at time $s_i$ minutes, and each bus of this route comes $d_i$ minutes later than the previous one. As Serval’s best friend, you wonder which bus route will he get on. If several buses arrive at the same time, you can print any of them. InputThe first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station. Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route. OutputPrint one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them. Examplesinput12 2 6 4 9 5 output11 input25 5 3 3 2 5 5 6 4 9 6 1 output23 input33 7 2 2 2 3 2 4 output31 题意zuhiul很忙，他要约妹子，他一共有$n$个妹子要约，但是他$t$天后才有空，妹子们也不是每天都有时间，但是妹子都是周期性有时间，比如，第$i$个妹子，$s_i$天之后才有时间，而且每$d_i$天就会再次出线，现在问你，zuhiul最早会和哪个妹子约会，如果会和多个妹子约会，只需要输出任意一个妹子就行了。 分析只需要枚举每个妹子，然后看一下这个妹子什么时候最早可以邀约，然后算一下min就可以了 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 105;int s[maxm],d[maxm];int main()&#123; int n,t; cin&gt;&gt;n&gt;&gt;t; int ind,sum = 1e8; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;s[i]&gt;&gt;d[i]; if(s[i]&gt;=t)&#123; if(sum&gt;s[i])&#123; sum = s[i]; ind = i; &#125; &#125;else &#123; int nee = t-s[i]; if(nee%d[i]!=0) nee = (nee/d[i]+1)*d[i]; nee+=s[i]; if(nee&lt;sum)&#123; sum = nee; ind = i; &#125; &#125; &#125; cout&lt;&lt;ind&lt;&lt;endl; return 0;&#125; B. Serval and Toy Bricks开启传送门 题目描述Luckily, Serval got onto the right bus, and he came to the kindergarten on time. After coming to kindergarten, he found the toy bricks very funny. He has a special interest to create difficult problems for others to solve. This time, with many $1\times 1\times 1$ toy bricks, he builds up a 3-dimensional object. We can describe this object with a $n\times m$ matrix, such that in each cell $(i,j)$ , there are $h_{i,j}$ bricks standing on the top of each other. However, Serval doesn’t give you any $h_{i,j}$, and just give you the front view, left view, and the top view of this object, and he is now asking you to restore the object. Note that in the front view, there are $m$ columns, and in the $i$-th of them, the height is the maximum of $h_{1,i},h_{2,i},\dots,h_{n,i}$. It is similar for the left view, where there are $n$ columns. And in the top view, there is an 𝑛×𝑚 matrix $t_{i,j}$, where $t_{i,j}$ is 0 or 1. If $t_{i,j}$ equals 1, that means $h_{i,j}$&gt;0, otherwise, $h_{i,j}$=0. However, Serval is very lonely because others are bored about his unsolvable problems before, and refused to solve this one, although this time he promises there will be at least one object satisfying all the views. As his best friend, can you have a try? InputThe first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station. Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route. OutputPrint one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them. Examplesinput13 7 3 2 3 0 0 2 0 1 2 1 3 1 0 0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 output11 0 0 0 2 0 0 0 0 0 0 0 0 1 2 3 0 0 0 0 0 input24 5 5 3 5 2 0 4 4 2 5 4 0 0 0 0 1 1 0 1 0 0 0 1 0 0 0 1 1 1 0 0 output20 0 0 0 4 1 0 2 0 0 0 5 0 0 0 3 4 1 0 0 Note The graph above illustrates the object in the first example. The first graph illustrates the object in the example output for the second example, and the second graph shows the three-view drawing of it. 题意zuhiul和妹子玩游戏，妹子搭了一个积木，然后zuhiul猜积木长啥样，zuhiul必然不会，于是小姐姐放过了他，告诉了他现在的主视图，侧视图和俯视图，然后让zuhiul猜，zuhiul还是不会，但是为了脸面不能说不会，然后来问你了。你需要输出一种可能的解满足这个三视图。 分析告诉了主视图和左视图，相当于限制了最大值，告诉俯视图相当于告诉哪里可能有方块。然后枚举俯视图的每个位置，输出答案即可。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxm = 105;int hang[maxm],lie[maxm],nouse;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;nouse; for(int i = 0;i&lt;m;i++) cin&gt;&gt;hang[i]; for(int i = 0;i&lt;n;i++) cin&gt;&gt;lie[i]; for(int i = 0;i&lt;n;i++)&#123; for(int j = 0,a;j&lt;m;j++)&#123; cin&gt;&gt;a; if(a) cout&lt;&lt;min(lie[i],hang[j])&lt;&lt;' '; else cout&lt;&lt;0&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; C. Serval and Parenthesis Sequence开启传送门 题目描述Serval soon said goodbye to Japari kindergarten, and began his life in Japari Primary School. In his favorite math class, the teacher taught him the following interesting definitions. A parenthesis sequence is a string, containing only characters “(“ and “)”. A correct parenthesis sequence is a parenthesis sequence that can be transformed into a correct arithmetic expression by inserting characters “1” and “+” between the original characters of the sequence. For example, parenthesis sequences “()()”, “(())” are correct (the resulting expressions are: “(1+1)+(1+1)”, “((1+1)+1)”), while “)(“ and “)” are not. Note that the empty string is a correct parenthesis sequence by definition. We define that $|s|$ as the length of string $s$. A strict prefix $s[1\dots l]$ (1 ≤ $l$ &lt; $|s|$) of a string $s=s_{1}s_{2}\dots s_{|s|}$ is string $s_{1}s_{2}\dots s_{l}$. Note that the empty string and the whole string are not strict prefixes of any string by the definition. Having learned these definitions, he comes up with a new problem. He writes down a string $s$ containing only characters “(“, “)” and “?”. And what he is going to do, is to replace each of the “?” in $s$ independently by one of “(“ and “)” to make all strict prefixes of the new sequence not a correct parenthesis sequence, while the new sequence should be a correct parenthesis sequence. After all, he is just a primary school student so this problem is too hard for him to solve. As his best friend, can you help him to replace the question marks? If there are many solutions, any of them is acceptable. InputThe first line contains a single integer $|s|$ (1≤$|s|$≤$3\cdot 10^5$), the length of the string. The second line contains a string $s$, containing only “(“, “)” and “?”. OutputA single line contains a string representing the answer. If there are many solutions, any of them is acceptable. If there is no answer, print a single line containing “:(“ (without the quotes). Examplesinput16(????? output1(()()) input210(???(???(? output2:( NoteIt can be proved that there is no solution for the second sample, so print “:(“. 题意给你一堆左括号右括号和问号，问你能否把问号变成左括号或者右括号，使得这个变成一个括号匹配的序列，并且序列的任何前缀不是一个括号匹配序列。 分析显然对于后一个条件，我们只需要让最左边的左括号和最右边的右括号匹配就行了，然后中间是一个括号匹配序列就行了。然后填充的时候贪心的让左边填充左括号,右边填充右括号,然后check一下就行了. 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int len;const int maxm = 3e5+10;char que[maxm];void NO()&#123; cout&lt;&lt;":("&lt;&lt;endl; exit(0);&#125;int main()&#123; cin&gt;&gt;len&gt;&gt;que; if(len&amp;1) NO(); if(que[0]=='?') que[0] = '('; if(que[len-1]=='?') que[len-1] = ')'; if(que[0]!='(') NO(); if(que[len-1]!=')') NO(); if(len==2) &#123; puts("()"); return 0; &#125; int l = 0,r = 0,has = 0; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='(') l++; else if(que[i]==')') r++; else has++; &#125; if(abs(l-r)&gt;has) NO(); l = (len-2)/2 - l; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='?') &#123; if(l)&#123; que[i] = '('; l--; &#125;else que[i] = ')'; &#125; &#125; has = 0; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='(') has++; else has--; if(has&lt;0) NO(); &#125; puts(que); return 0;&#125; D. Serval and Rooted Tree开启传送门 题目描述Now Serval is a junior high school student in Japari Middle School, and he is still thrilled on math as before. As a talented boy in mathematics, he likes to play with numbers. This time, he wants to play with numbers on a rooted tree. A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a node $v$ is the last different from $v$ vertex on the path from the root to the vertex $v$. Children of vertex $v$ are all nodes for which $v$ is the parent. A vertex is a leaf if it has no children. The rooted tree Serval owns has $n$ nodes, node 1 is the root. Serval will write some numbers into all nodes of the tree. However, there are some restrictions. Each of the nodes except leaves has an operation max or min written in it, indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons, respectively. Assume that there are $k$ leaves in the tree. Serval wants to put integers $1,2,\dots,k$ to the $k$ leaves (each number should be used exactly once). He loves large numbers, so he wants to maximize the number in the root. As his best friend, can you help him? InputThe first line contains an integer $n$ (2≤$n$≤$3\cdot 10^5$), the size of the tree. The second line contains $n$ integers, the $i$-th of them represents the operation in the node $i$. 0 represents min and 1 represents max. If the node is a leaf, there is still a number of 0 or 1, but you can ignore it. The third line contains $n-1$ integers $f_2,f_3,\dots,f_n$ (1≤$f_i≤$i-1$), where $f_i$ represents the parent of the node $i$. OutputOutput one integer $-$ the maximum possible number in the root of the tree. Examplesinput16 1 0 1 1 0 1 1 2 2 2 2 output11 input25 1 0 1 0 1 1 1 1 1 output24 input38 1 0 0 1 0 1 1 0 1 1 2 2 3 3 3 output34 input49 1 1 0 0 1 0 1 0 1 1 1 2 2 3 3 4 4 output45 NotePictures below explain the examples. The numbers written in the middle of the nodes are their indices, and the numbers written on the top are the numbers written in the nodes. In the first example, no matter how you arrange the numbers, the answer is $1$. In the second example, no matter how you arrange the numbers, the answer is $4$. In the third example, one of the best solution to achieve $4$ is to arrange $4$ and $5$ to nodes $4$ and $5$. In the fourth example, the best solution is to arrange $5$ to node $5$. 题意给你一颗有根树，每个非叶节点上有一个函数，可能为min或者max，你需要在k个叶节点上填上$1,2,\dots,k$,使得经过非叶节点的操作之后，根节点的值最大。 分析显然是要分析函数的作用。 如果是取max，说明所有的子节点中，我们可以把某一个子节点的值取到最大，然后其他的节点全塞垃圾值。 如果是取min，说明所有子节点都起作用，说明我们对于每个子节点都要尽可能的大。 然后就可以得到，max的策略是，找到孙子节点最少的子节点，填充大值，min的策略是，对所有子节点求和。 然后这样得到的就是所有对答案有贡献的节点数，然后用总结点数减去贡献节点数就是答案。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 3e5+10;int n,cnt;int maxn[maxm];vector&lt;int&gt; son[maxm];int dfs(int a)&#123; if(son[a].size()==0)&#123; cnt++; return 1; &#125; if(maxn[a])&#123; int minm = 1e8; for(int i:son[a]) minm = min(minm,dfs(i)); return minm; &#125; int sum = 0; for(int i:son[a]) sum+=dfs(i); return sum;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++) cin&gt;&gt;maxn[i]; for(int i = 2,pre;i&lt;=n;i++)&#123; cin&gt;&gt;pre; son[pre].push_back(i); &#125; int nouse = dfs(1); cout&lt;&lt;cnt - nouse+1&lt;&lt;endl; return 0;&#125; E. Serval and Snake开启传送门 题目描述This is an interactive problem. Now Serval is a senior high school student in Japari Middle School. However, on the way to the school, he must go across a pond, in which there is a dangerous snake. The pond can be represented as a $n\times n$ grid. The snake has a head and a tail in different cells, and its body is a series of adjacent cells connecting the head and the tail without self-intersecting. If Serval hits its head or tail, the snake will bite him and he will die. Luckily, he has a special device which can answer the following question: you can pick a rectangle, it will tell you the number of times one needs to cross the border of the rectangle walking cell by cell along the snake from the head to the tail. The pictures below show a possible snake and a possible query to it, which will get an answer of $4$. Today Serval got up too late and only have time to make 2019 queries. As his best friend, can you help him find the positions of the head and the tail? Note that two cells are adjacent if and only if they have a common edge in the grid, and a snake can have a body of length 0, that means it only has adjacent head and tail. Also note that the snake is sleeping, so it won’t move while Serval using his device. And what’s obvious is that the snake position does not depend on your queries. InputThe first line contains a single integer $n$ (2≤$n$≤1000) $-$ the size of the grid. OutputWhen you are ready to answer, you should print ! x1 y1 x2 y2, where $(x_1,y_1)$ represents the position of the head and $(x_2,y_2)$ represents the position of the tail. You can print head and tail in any order. InteractionTo make a query, you should print ? x1 y1 x2 y2 (1≤$x_1$≤$x_2$≤𝑛, 1≤$y_1$≤$y_2$≤$n$), representing a rectangle consisting of all cells $(x,y)$ such that $x_1$≤$x$≤$x_2$ and $y_1$≤$y$≤$y_2$. You will get a single integer as the answer. After printing a query, do not forget to output the end of line and flush the output, otherwise you will get Idleness limit exceeded. To do this, use: fflush(stdout) or cout.flush() in C++; System.out.flush() in Java; flush(output) in Pascal; stdout.flush() in Python;see documentation for other languages. Answer $-1$ instead of a valid answer means that you made an invalid query or exceeded the maximum number of queries. Exit immediately after receiving $-1$ and you will see Wrong answer verdict. Otherwise you can get an arbitrary verdict because your solution will continue to read from a closed stream. If your program cannot find out the head and tail of the snake correctly, you will also get a Wrong Answer verdict. HacksTo make a hack, print a single integer $n$ (2≤$n$≤1000) in the first line, indicating the size of the grid. Then print an integer $k$ (2≤$k$≤𝑛2) in the second line, indicating the length of the snake. In the next $k$ lines, print $k$ pairs of integers $x_i,y_i$ (1≤$x_i,y_i$≤𝑛), each pair in a single line, indicating the $i$-th cell of snake, such that the adjacent pairs are adjacent, and all $k$ pairs are distinct. Examplesinput12 1 0 0 output1? 1 1 1 1 ? 1 2 1 2 ? 2 2 2 2 ! 1 1 2 1 input23 2 0 output2? 2 2 2 2 ? 2 1 2 3 ! 2 1 2 3 Note The pictures above show our queries and the answers in the first example. We first made a query for (1,1) and got an answer 1, then found that it must be connected to exactly one other cell. Then we made a query for (1,2) and got an answer of 0, then knew that the snake never entered it. So the cell connected to (1,1) must be (2,1). Then we made a query for (2,2) and got an answer 0, then knew that it never entered (2,2) as well. So the snake cannot leave (2,1), which implies that the answer is (1,1) and (2,1). The pictures above show our queries and the answers in the second example. By making query to (2,2) and receiving 2, we found that the snake occupies (2,2). And by making query to rectangle from (2,1) to (2,3) and receiving answer 0, we knew that it never goes out of the rectangle from (2,1) to (2,3). Since the first answer is 2, both (2,1) and (2,3) must be occupied but none of others, so the answer is (2,1) and (2,3). 题意现在有一条蛇在一个方格图中，你可以给出不超过2019次询问，每次询问一个矩形，回答是，你用这个矩形去切蛇，可以得到这个蛇被切了多少刀，现在问你蛇头和蛇尾的位置。 分析首先我们可以观察到，当一个矩形切下去之后发现切了奇数刀，那么可以有必然存在一个头或者尾在矩形中。 然后我们可以用$(n-1)&lt;&lt;1$次询问得到所有的行和列对应的切的次数。 然后可以证明的是，所有的数据中必然存在奇数。反证法易得。 然后可以证明奇数对应的行或者列左右必然存在头或者尾。 所以可以得到一个很直观的$O(6n)$的做法，$2n$用来寻找，剩下的$4n$来搜索答案。但是这必然会超过2019. 考虑哪些步骤可以优化？ $2n$不可优化，必然就只能优化搜索过程。 需要注意的是，可能存在行或者列不存在奇数的情况，稍微分析可以得到这种情况的特点了，头和尾在同一行或者同一列中。 我们考虑到，我们只用考虑奇偶的情况，而不用考虑具体值。 因为奇偶的加减特性，我们可以二分这个答案。 除此之外，如果行和列都有奇数值，那么可以得到行和列对应的四个点中，两个点是答案，枚举任何一个就可以得到答案。 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1005;int n;vector&lt;int&gt; r,c;int que(int u,int d,int l,int r)&#123; printf("? %d %d %d %d\n",u,l,d,r); fflush(stdout); int nouse; scanf("%d",&amp;nouse); return nouse&amp;1;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1;i&lt;=n;i++) if(que(i,i,1,n)) r.push_back(i); for(int i = 1;i&lt;=n;i++) if(que(1,n,i,i)) c.push_back(i); assert(r.size()+c.size()&gt;=2); if(c.empty()||r.empty())&#123; bool change = false; if(c.empty()) &#123; swap(r,c); change = true; &#125; int l = 1,r = n; while(l&lt;r)&#123; int mid = l+r&gt;&gt;1; int upper = l,down = mid,left = c[0],right = c[0]; if(change) swap(left,upper),swap(down,right); if(que(upper,down,left,right)) r = mid; else l = mid+1; &#125; if(!change) printf("! %d %d %d %d\n",l,c[1],l,c[0]); else printf("! %d %d %d %d\n",c[0],l,c[1],l); fflush(stdout); return 0; &#125; if(que(r[0],r[0],c[0],c[0])) printf("! %d %d %d %d\n",r[0],c[0],r[1],c[1]); else printf("! %d %d %d %d\n",r[0],c[1],r[1],c[0]); fflush(stdout); return 0;&#125; F. Serval and Bonus Problem开启传送门 题目描述Getting closer and closer to a mathematician, Serval becomes a university student on math major in Japari University. On the Calculus class, his teacher taught him how to calculate the expected length of a random subsegment of a given segment. Then he left a bonus problem as homework, with the award of a garage kit from IOI. The bonus is to extend this problem to the general case as follows. You are given a segment with length $l$. We randomly choose $n$ segments by choosing two points (maybe with non-integer coordinates) from the given segment equiprobably and the interval between the two points forms a segment. You are given the number of random segments $n$, and another integer $k$. The $2n$ endpoints of the chosen segments split the segment into ($2n+1$) intervals. Your task is to calculate the expected total length of those intervals that are covered by at least $k$ segments of the $n$ random segments. You should find the answer modulo $998244353$. InputFirst line contains three space-separated positive integers 𝑛, 𝑘 and 𝑙 ($1\leq k\leq n\leq 2000,1\leq l\leq 10^9$). OutputOutput one integer — the expected total length of all the intervals covered by at least $k$ segments of the $n$ random segments modulo $998244353$. Formally, let $M=998244353$. It can be shown that the answer can be expressed as an irreducible fraction $\frac{p}{q}$, where $p$ and $q$ are integers and $q\not\equiv0(modM)$. Output the integer equal to $p\cdot q^{-1}mod\ M$. In other words, output such an integer $x$ that $0\leq x&lt;M$ and $x\cdot q\equiv p(mod\ M)$. Examplesinpus11 1 1 output1332748118 input26 2 1 output2760234711 input37 5 3 output3223383352 input497 31 9984524 output4267137618 NoteIn the first example, the expected total length is $\int_0^1 \int_0^1 |x-y|\ dx\ dy = \frac{1}{3} $, and $\frac{1}{3}$ modulo $998244353$ is $332748118$. 题意长度为l的线段，随机选取n个线段，线段中至少被n个线段中k个线段覆盖的长度期望。 分析说实话我当时没做出来，看了题解才知道怎么做的，所以强烈建议看官方的题解。我这里也贴出来，感兴趣的可以看一下。 Without loss of generality, assume that $l$=1. For a segment covering, the total length of the legal intervals is the probability that we choose another point $P$ on this segment randomly such that it is in the legal intervals. Since all $2n+1$ points ($P$ and the endpoints of each segment) are chosen randomly and independently, we only need to find the probability that point $P$ is in the legal intervals. Note that only the order of these $2n+1$ points make sense. Because the points are chosen in the segment, the probability that some of them coincide is $0$, so we can assume that all points do not coincide. Now the problem is, how to calculate the number of arrangements that $P$ is between at least $k$ pairs of endpoints. It can be solved by dynamic programming in time complexity of $O(n^2)$. We define $f(i,j,x)$ as the number of arrangements for the first $i$ positions, with $j$ points haven’t been matched, and $P$ appeared $x$ times (obviously $x=0$ or $1$). So we can get three different types of transition for the $i$-th position below: Place $P$ at $i$-th position (if $j\geq k$): $f(i-1,j,0)\rightarrow f(i,j,1)$ Start a new segment (if $i+j+x&lt;2n$): $f(i-1,j-1,x)\rightarrow f(i,j,x)$ Match a started segment, note that we have 𝑗 choices of segments:$f(i-1,j+1,x)\times(j+1)\rightarrow f(i,j,x)$ Then $f(2n+1,0,1)$ is the number of legal arrangements. Obviously, the total number of arrangements is $(2n+1)!$. However, there are 𝑛 pairs of endpoints whose indices can be swapped, and the indices 𝑛 segments can be rearranged. So the final answer is $\frac{f(2n+1,0,1)\times n!\times 2^n}{(2n+1)!}$. 可能是受了题解的影响，后来也没想出来其他解法。 这里讲一下题解怎么做的。 首先我们可以发现，长度和答案成正比，也就是说如果长度为1的时候答案是a，那么长度为2的时候答案就是2a%mod. 然后我们不妨设长度为1，最后答案乘上l就行了。 然后因为我们要找到至少被线段覆盖k次的所有点，所以我们不如加上一个虚拟点，这样就一共有了$(n&lt;&lt;1|1)$个点，然后需要判断这个虚拟点被多少条线段覆盖了，如果覆盖次数超过k次，就说明可以统计进答案。然后就可以发现，所有点是随机取的，所以我们假设所有点不会重合，那么所有点就可以离散成一个序列。然后就可以统计k的覆盖次数。 接下来就是dp，我们设$dp[i][j][flag]$表示序列中前i个点，其中到目前为止有j条线段左节点出线了，但是右节点没有出现，也就是说当前这个点被覆盖了j次，flag表示虚拟点是否出现了。然后考虑转移： 当前节点是虚拟节点 如果这个需要统计进入答案，也就是说明当前节点需要被覆盖k次及以上，所以 $j\geq k$ $dp[i][j][1]+=dp[i-1][j][0]$ 当前节点是一个线段的左端点 也就是说左节点数量增加，被覆盖次数增加，但是不会影响虚拟节点的状态 $dp[i][j+1][flag]+=dp[i-1][j][flag]$ 当前节点是一个线段的右端点 也就是说右节点数量增加，被覆盖次数减少，但是不会影响虚拟节点的状态,注意右端点可能会有j个可能 $dp[i][j-1][flag]+=dp[i-1][j][flag]*j$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const long long mod = 998244353;const int maxm = 2345;inline long long add(long long a,long long b)&#123;return (a+b)%mod;&#125;inline long long mul(long long a,long long b)&#123;return a*b%mod;&#125;inline long long fac(long long a) &#123;return a==1?1:mul(a,fac(a-1));&#125;inline long long qpow(long long a,long long b = mod-2)&#123;/*&#123;&#123;&#123;*/ long long ret = 1; while(b)&#123; if(b&amp;1) ret = mul(ret,a); a = mul(a,a); b&gt;&gt;=1; &#125; return ret;&#125;/*&#125;&#125;&#125;*/long long n,k,l;long long dp[maxm&lt;&lt;1][maxm][2];int main()&#123; scanf("%lld%lld%lld",&amp;n,&amp;k,&amp;l); dp[0][0][0] = 1; for(int i = 1;i&lt;=(n&lt;&lt;1|1);i++) for(int j = 0;j&lt;=n;j++)&#123; if(j&gt;=k) dp[i][j][1] = add(dp[i][j][1],dp[i-1][j][0]); for(int flag = 0;flag&lt;2;flag++) if(dp[i-1][j][flag])&#123; if(j) dp[i][j-1][flag] = add(dp[i][j-1][flag],mul(dp[i-1][j][flag],j)); if(i+(j+1)-(1-flag)&lt;=(n&lt;&lt;1|1)) dp[i][j+1][flag] = add(dp[i][j+1][flag],dp[i-1][j][flag]); &#125; &#125; int ans = mul(dp[n&lt;&lt;1|1][0][1],qpow(2,n)); ans = mul(mul(ans,l),mul(fac(n),qpow(fac(n&lt;&lt;1|1)))); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[factorio]]></title>
    <url>%2F2019%2F03%2F31%2Ffactorio%2F</url>
    <content type="text"><![CDATA[level 1]]></content>
      <tags>
        <tag>factorio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试]]></title>
    <url>%2F2019%2F02%2F21%2Fgluten%2Fgluten_tt%2F</url>
    <content type="text"><![CDATA[头条面试回忆录废话这两天参加了头条的面试,总体来说,感觉不错,公司效率很高… 一面当天上午投的简历,下午让我第二天面试,时间很紧,很多东西都没来得及准备…. 1.自我介绍一下(balabalabala) 2.学过操作系统和计算机网络吗?(网络学了,操作系统下学期开,其实我很想说操作系统自学了,您可以问……) 3.说一下tcp和udp的区别(balabalabala) 2.1那个快?为什么?(udp快,因为三次握手四次挥手会占用cpu时间?) 2.2去掉三次握手四次挥手那个快?(不知道) 4.写两个题吧 3.1 给你一个数字矩阵,每行每列都是增序,问你某个值是否存在(剑指offer原题,我100%做过,但是我忘了怎么做的,只知道从角上枚举,然后先说了一下从右下角枚举,说不对,然后换成右上角,没啥问题….) 3.2 给一个矩阵,四联通,找到一个最长上升子序列(简单dp,写完就过了) 3.2.1 能把路径输出一下吗?(记录前驱….) 3.2.2 能把前驱数组去掉吗?(可以,瞎搞一下就行了…..) 4.闲聊(emmmmm) 二面二面感觉更严格,感觉答的不好….. 1.自我介绍(balabalabala) 2.有什么数据结构可以做到查询和插入都是o(1)的?(第一反映,显然不可能啊,这不是不可调和的矛盾吗?面试官说:知道hash吗?哇,感觉被鄙视了,确实傻了) 3.给你n个有序链表(从大到小),怎么找到这n个链表的前K大,(先取出每个链表的最大,然后建最大堆,然后每次取出堆顶,然后取出对应链表的后续元素,加入堆,然后一次操作,直到有k个元素) 3.1 复杂度多少?(o(n+klogn)) 3.2 n是怎么来的?(建堆时间) 3.3 能证明一下吗?(假设堆是用类树状数组的结构维护,先把数据随机放进来,然后每次从大到小枚举一个下标ind,比较当前位置ind和(ind&gt;&gt;1),然后根据大小关系交换一下,可以证明每次都是两个数比较,并且最多有n次比较,所以o(n)) 4.写两个题吧 2.1 给你一个字典,给你一个询问串,问你能否用字典中的某些单词(每个单词只能用一次),构成询问串.(想复杂了,一直在想怎么优化,后来才知道直接暴力就行,我当时还傻乎乎的用了lower_bound企图缩小范围,结果返回结果还死活不对,搞了30分钟才搞定,感觉要凉) 2.2 可能是看我太菜,没问第二道题,感觉好像对我不感兴趣就溜了??? 三面不知道自己怎么活过二面的……. 1.聊天,纯聊天,可能是怕我太紧张,感觉面试官很好 2.提出自我介绍被拒绝……. 3.简单说一下项目,(也不用详细说,因为项目就是很简单……) 4.有啥很厉害的技术要说明的吗?(没有……) 5.我们写两个题吧 5.1 给你一个无根树,让你转化成有根树,使得树的深度最小(一眼直径的中点,写了一下,好像有点问题,我问他我是调一下还是?他说不用调了,想法没啥大问题) 5.2 初始位置0,速度1,两个操作 1.position+=spead,spead*=2 2.spead&gt;0,spead = -1;else spead = 1 问你最少操作几次,使得,从0到x 我第一想法二进制拆分,然后瞎搞,写了一下,没啥大问题 复杂度?(32^2?) 怎么证明,我说每次考虑最高位的1,然后瞎搞一下balabalabala 说正解是dp,比我复杂,emmmmm…….. 6.浏览器输入baidu.com会发生啥?(balabalabala,昨天看过,不知道说的对不对) 7.你有啥觉得自己的技术亮点要说吗?(感觉瞎bb都能加分,但是我怂,老老实实说自己没啥技能点……) 8.你想过一些大的厂商,背后的技术部门都是怎么运行的吗?(不知道……..) 9.面试官可能觉得没啥聊的了,就放我走了…… 总结总的来说,面试官还是很和蔼的,有些问题还会引导你向正确的方向思考,问题都不难,好好准备应该好过,就这样吧…….]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 276 Primitive Triangles]]></title>
    <url>%2F2019%2F01%2F17%2FPE%2FPE276%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Consider the triangles with integer sides $a, b$ and $c$ with $a \leq b \leq c$.An integer sided triangle $(a,b,c)$ is called primitive if $gcd(a,b,c)=1$.How many primitive integer sided triangles exist with a perimeter not exceeding $10,000,000$? 题意问你存在多少个边长是整数的三角形,并且满足三边长的gcd为1,周长不超过$1e7$. 分析有一个比较奇奇怪怪的结论 我直接把结论搬过来$\dots$ \begin{eqnarray} F(n) = \begin{cases} \lfloor\frac{(n+3)^2+24}{48}\rfloor\ \ \ \ &amp;n\ \ is\ \ odd\\ \lfloor\frac{n^2+24}{48}\rfloor\ \ \ \ &amp;n\ \ is\ \ even\ \end{cases}\end{eqnarray} 这个结论说的是,周长为$n$的边长都是整数的三角形的数量.然后我们可以预处理出所有的周长为$n$的数量出来,然后我们怎么保证gcd呢,比较好想的就是容斥,我们容斥掉所有gcd不是1的就行了,也就是说我们用周长为$2\cdot n,3\cdot n,\dots$的减去周长为$n$的就行啦啦啦 给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+1;long long num[maxm];long long get(long long a)&#123; if(a&amp;1) return ((a+3)*(a+3)+24)/48; return (a*a+24)/48;&#125;void init()&#123;//预处理出每个周长对应的三角形数量,容斥得到正确的数量 for(int i = 1;i&lt;maxm;i++) num[i] = get(i); for(int i = 1;i&lt;maxm;i++) for(int j = i&lt;&lt;1;j&lt;maxm;j+=i) num[j]-=num[i];&#125;int main()&#123; init(); long long ans = 0; for(int i = 1;i&lt;maxm;i++) ans+=num[i]; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 643 2-Friendly]]></title>
    <url>%2F2019%2F01%2F09%2FPE%2FPE643%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Two positive integers $a$ and $b$ are 2-friendly when $gcd(a,b)=2^t,t&gt;0$. For example, $24$ and $40$ are 2-friendly because $gcd(24,40)=8=2^3$ while $24$ and $36$ are not because $gcd(24,36)=12=2^2\cdot 3$ not a power of $2$. Let $f(n)$ be the number of pairs, $(p,q)$, of positive integers with $1\leq p&lt;q\leq n$ such that $p$ and $q$ are 2-friendly. You are given $f(10^2)=1031$ and $f(10^6)=321418433$ modulo $1000000007$ . Find $f(10^{11})$ modulo $1000000007$. 题意问你所有满足$1\leq p&lt;q\leq 1e11$,并且$gcd(p,q)==2^t$的对数 分析显然可以对于每个$2^t$单独考虑,不妨设$2^t = x$,可以得到 $$ans = \sum_{i=1}^{upper/x} \varphi(i)$$ 然后显然是各种筛法搞一下,我这里用的杜教筛,然后稍微推一推就可以得到 $$s(m) = \frac{m\ast (m+1)}{2} - \sum_{d=2}^{m} s(\lfloor \frac{m}{d} \rfloor)$$ 然后分块一下,递归搞下去就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const long long upper = 1e11;const int maxm = 2e7+10;const int mod = 1e9+7;int add(int a,int b)&#123;return (a+b)%mod;&#125;int mul(long long a,long long b)&#123;return (a%mod)*(b%mod)%mod;&#125;int inv(long long a)&#123; return a==1?1:mul(mod-mod/a,inv(mod%a)); &#125;int inv2 = inv(2);bool p[maxm];int pri[maxm];//质数int phi[maxm];//欧拉函数前缀和void init()&#123; phi[1] = 1; for(int i =2;i&lt;maxm;i++)&#123; if(!p[i])&#123; pri[++pri[0]] = i; phi[i] = i-1; &#125; for(int j = 1;j&lt;=pri[0]&amp;&amp;i*pri[j]&lt;maxm;j++)&#123; p[i*pri[j]] = true; if(i%pri[j]) phi[i*pri[j]] = phi[i]*(pri[j]-1); else&#123; phi[i*pri[j]] = phi[i]*pri[j]; break; &#125; &#125; &#125; for(int i = 2;i&lt;maxm;i++) phi[i] = add(phi[i],phi[i-1]);//因为只会用到前缀和,所以我们直接预处理成前缀和&#125;map&lt;long long,int&gt; mp;int solve(long long m)&#123; if(m&lt;maxm) return phi[m];//查表 if(mp[m]) return mp[m];//记忆化 int ret = mul(m,mul(m+1,inv2)); for(long long l = 2,r;l&lt;=m;l = r+1) &#123;//分块 r = m/(m/l); ret = add(ret,mod-mul(solve(m/l),r-l+1)); &#125; return mp[m] = ret;&#125;int main()&#123; init(); int ans = 0; for(long long x = 2;x&lt;=upper;x&lt;&lt;=1) &#123;//单独统计每一个2的幂 cout&lt;&lt;x&lt;&lt;endl; ans = add(ans,solve(upper/x)); ans = add(ans,mod-1); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 222 Sphere Packing]]></title>
    <url>%2F2019%2F01%2F04%2FPE%2FPE222%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 What is the length of the shortest pipe, of internal radius $50$mm, that can fully contain $21$ balls of radii $30$mm, $31$mm, …, $50$mm? Give your answer in micrometres ($10^{-6}$ m) rounded to the nearest integer. 题意让你在一个内径$50$的圆管里塞$21$个内径分别为$31-50$的小球,问你圆管最短是多少 分析比较显然是dp 考虑dp状态:dp[i][j]表示选择小球对应的集合为j,并且用第i个小球结尾,然后我们转移的时候就直接添加一个小球,对于剩余的小球枚举一个结尾,取最优解就行了 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 21;double ans[maxm][1&lt;&lt;maxm];int num[maxm+10];double cal(int a,int b)&#123;//得到两个小球的距离 int t = a+b+60; return 10*sqrt(t*2-100);&#125;int main()&#123; for(int i = 0;i&lt;maxm;i++) for(int j = 0;j&lt;(1&lt;&lt;maxm);j++) ans[i][j] = 1e8; for(int s = 0;s&lt;(1&lt;&lt;maxm);s++) for(int i = 0;i&lt;maxm;i++)&#123; if(s==0)&#123;//初值条件 ans[i][1&lt;&lt;i] = i+30; continue; &#125; if((s &gt;&gt; i &amp; 1)==1) continue; int t = s|(1&lt;&lt;i);//用S来扩展t for(int j = 0;j&lt;maxm;j++) if(s&gt;&gt;j&amp;1) ans[i][t] = min(ans[i][t],ans[j][s]+cal(i,j)); &#125; double rans = 1e8; for(int i = 0;i&lt;maxm;i++) rans = min(rans,ans[i][(1&lt;&lt;maxm)-1]+i+30); printf("%.0f\n",rans*1000); return 0;&#125;]]></content>
      <tags>
        <tag>PE</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 122 Efficient exponentiation]]></title>
    <url>%2F2019%2F01%2F02%2FPE%2FPE122%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The most naive way of computing $n^{15}$ requires fourteen multiplications: $n \times n \times \dots \times n = n^{15}$ But using a “binary” method you can compute it in six multiplications: \begin{eqnarray}n \times n &amp;= n^2\\n^2 \times n^2 &amp;= n^4\\n^4 \times n^4 &amp;= n^8\\n^8 \times n^4 &amp;= n^{12}\\n^{12} \times n^2 &amp;= n^{14}\\n^{14} \times n &amp;= n^{15}\\\end{eqnarray} However it is yet possible to compute it in only five multiplications: \begin{eqnarray}n \times n &amp;= n^2\\n^2 \times n &amp;= n^3\\n^3 \times n^3 &amp;= n^6\\n^6 \times n^6 &amp;= n^{12}\\n^{12} \times n^3 &amp;= n^{15}\\\end{eqnarray} We shall define $m(k)$ to be the minimum number of multiplications to compute $n^k$; for example $m(15) = 5$. For $1 \leq k \leq 200$, find $\sum m(k)$. 题意我们知道快速计算一个数的幂次有各种不同的方法,快速幂只是其中一种而且不是最快的,然后问你对于1~200的幂次来说,最少需要几次乘法操作. 分析有一个wiki讲的就是这个问题,可以看一看…. 我们可以发现,对于所有幂次来说,我们按照最后一步操作的数来构成他的前驱,然后我们会发现他是一棵树,然后我们直接构造出这颗树出来,就是最优答案….. 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s[222];void cal(int a)&#123; int now = 1e8,ind = 0; for(int i = 1;i&lt;=a;i++)&#123;//枚举每一个比他小的数,看是否可以作为他的前驱 if(s[i].size()+1&gt;=now) continue;//如果不能优化解就不继续搜索 for(int x:s[i])//枚举每一个前驱的子元素 if(s[i].find(a-x)!=s[i].end())&#123;//如果能构成a now = s[i].size()+1;//更新解 ind = i; break; &#125; &#125; for(int i:s[ind]) s[a].insert(i);//保存路径 s[a].insert(a);&#125;int main()&#123; s[1].insert(1); for(int i = 2;i&lt;=200;i++) cal(i); int ans = 0; for(int i = 1;i&lt;=200;i++) ans+=s[i].size()-1;//要把里面的1剪掉,因为合成1不要代价 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 143 Investigating the Torricelli point of a triangle]]></title>
    <url>%2F2018%2F12%2F28%2FPE%2FPE143%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Let ABC be a triangle with all interior angles being less than $120$ degrees. Let $X$ be any point inside the triangle and let $XA = p, XC = q$, and $XB = r$. Fermat challenged Torricelli to find the position of X such that $p + q + r$ was minimised. Torricelli was able to prove that if equilateral triangles AOB, BNC and AMC are constructed on each side of triangle ABC, the circumscribed circles of AOB, BNC, and AMC will intersect at a single point, T, inside the triangle. Moreover he proved that T, called the Torricelli/Fermat point, minimises $p + q + r$. Even more remarkable, it can be shown that when the sum is minimised, $AN = BM = CO = p + q + r$ and that AN, BM and CO also intersect at T. If the sum is minimised and a, b, c, p, q and r are all positive integers we shall call triangle ABC a Torricelli triangle. For example, $a = 399, b = 455, c = 511$ is an example of a Torricelli triangle, with $p + q + r = 784$. Find the sum of all distinct values of $p + q + r ≤ 120000$ for Torricelli triangles. 题意就是三个角都小于120度的三角形存在费马点,然后让你找到所有这样的三角形,使得图上对应的六条边都是整数,其中$T$就是费马点.然后你要找到所有$p+q+r$不同的所有三角形,然后把$p+q+r$求和. 分析对于每一个圆来说,因为里面的三角形是对边三角形,然后因为$T$在园上,于是有$T$对应的角大小一定是$180-60 = 120$度,然后同理可得,三个角都是$120$度,然后我们运用余弦定理可以得到$p^2+q^2+pq=b^2$,因为我们只要$p+q+r$不同的解,所以我们不妨设$p&gt;=q&gt;=r$,因为三个角都是$120$度,所以余弦定理都成立,所以我们可以得到 \begin{eqnarray}q^2+r^2+qr &amp;= a^2\\p^2+q^2+pq &amp;= b^2\\p^2+r^2+pr &amp;= c^2\\p&gt;=q&gt;=r\\\end{eqnarray} 然后我们对于每对关系,可以显然发现都应该是类似的,然后我们可以存下来每个关系,然后暴搜就行了,emmmmmm$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int upper = 1.2e5;set&lt;int&gt; to[upper+10];bool ans[upper&lt;&lt;2];int main()&#123; for(long long i = 1;i&lt;=upper;i++)&#123; for(long long j = min(upper-i,i);j&gt;=1;j--)&#123; long long x = i*i+j*j+i*j; long long y = sqrt(x); if(y*y==x) to[i].insert(j); &#125; if(i%10==0) cout&lt;&lt;i&lt;&lt;'\n'; &#125; for(int i = 1;i&lt;=upper;i++)&#123; for(int j:to[i])&#123; for(int k:to[j])&#123; if(i+j+k&gt;upper) continue; if(to[i].count(k))&#123; ans[i+j+k] = true; &#125; &#125; &#125; &#125; int rans = 0; for(int i = 1;i&lt;=upper;i++) if(ans[i]) rans+=i; cout&lt;&lt;rans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IC(answer.chepter1)]]></title>
    <url>%2F2018%2F12%2F24%2Fknowledge%2FIC_chepter1%2F</url>
    <content type="text"><![CDATA[作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢 1.利用反证法容易得到,如果$n$和$m$都是奇数,那么$n*m$也是奇数,显然不可覆盖,所以$n$和$m$至少有一个偶数 2.我们定义行号从上到下为$1\dots m$,列号从左到右为$1\dots n$,然后我们就可以得到被切掉的那个方块只可能是奇数行奇数列,或者偶数行偶数列,我们考虑对这两种方案分别进行构造来得到我们想要的答案. 奇数行奇数列:对于和他在同一行同一列的方块来说,因为他去掉了,所以剩下的一定是可以匹配的偶数,也就是说我们可以匹配上这一行一列,对于剩下的一定都是偶数行偶数列的联通块,显然可以构造 奇数行奇数列:这个稍微麻烦一点,我们可以选择他周围的奇数行奇数列的一个子矩阵,显然可以螺旋式的构造,也就是说我们用完左上角,对于剩下的容易证明也是两个偶数的联通块,同样可以构造,看图 3.显然是不能获得自由的,因为我们可以将这个棋盘黑白二染色,然后可以发现对顶角颜色相同,每一步颜色都会反转,一共要走63步,所以最后一步一定会在异色块上,所以不行. 4.(a)对于每一个$n$来说我们直接考虑最后一块的摆放方法,如果是竖着放,那么剩下的就是$f(n-1)$的子问题,如果是横着放,那么倒数第二块显然也是横着放的,所以剩下的就是$f(n-2)$的子问题,所以显然可以得到的是$f(n) = f(n-1)+f(n-2)$,也就是说答案就是fibonacci.$\therefore f(12) = 233$ 4.(b)这里我们可以考虑DP来做,具体程序如下: 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e5+10;int dp[maxm][8];int main()&#123; dp[0][0] = dp[0][3] = dp[0][6] = dp[1][1] = dp[1][4] = dp[1][7] = 1; for(int i = 2;i&lt;maxm;i++)&#123; dp[i][0] = dp[i-2][3]+dp[i-2][6]+dp[i-2][0]; dp[i][1] = dp[i-1][0]+dp[i-2][1]; dp[i][3] = dp[i][0]+dp[i-2][3]; dp[i][4] = dp[i][1]; dp[i][6] = dp[i][3]; &#125; return 0;&#125; 然后可以发现$g(n) = 4\ast g(n-2)-g(n-4)$ 5.用4.(b)的代码容易可得,$g(4) = 11$ 6.同样采用反证法容易证得$n$是偶数,下面我们考虑$n$是奇数扣掉中间一块的情况.不妨假设八个角上的颜色是黑色,可以得到黑块数量是$4k^3+6k^2+3k+1$,白块的数量是$4k^3+6k^2+3k$,我们可以分两种情况讨论,我们假设$n = 2k+1$ 当k是奇数时,也就是$k = 2t+1$,即$n = 4t+3$,中间块是白色的.然后扣掉白块后,显然黑块和白块不匹配,然后不行鸭. 当k是偶数时,也就是$k = 2t$,即$n = 4t+1$,中间块是黑色的,扣掉黑块后,白块和黑块是匹配的,可能可以.下面我们证明$n = 4t+1$时是可行的 我们按照层数拆分,我们抽掉其中的第$2t+1$层,我们可以得到,这一层显然是可行的,类比于二阶的时候,我们扣掉中心块 对于剩下的两个联通块,我们显然可以得到是他们对称,我们只考虑上面的$2t$层的部分,我们每两层考虑一下 对于相连的两层,也就是$2\ast n\ast n$的形状,我们显然可以构造,所以整个三维结构是可以构造的. 7.首先证明$a$既是$n$的因子,又是$m$的因子 因为$a$是$b$的因子,所以$a\ast b$的可以看成多个$a\ast a$的,采用反证法,假设$a$不是$m$的因子,那么对于剩下的$(m%a)\ast (n%a)$的矩阵显然不可以用$a\ast a$的矩阵填满,所以$m%a==0&amp;&amp;n%a==0$. 再证$b$是$n$或者$m$的因子 同样反证法,我们将$a,b,m,n$同时缩小$a$倍,然后可以转化成,现在有一个$x\ast y$的棋盘,我要用一个$1\ast z$的棋盘去覆盖他,但是$gcd(x,z)=gcd(y,z)=1$,这个可以显然发现是不可能的 8.先证:存在完美覆盖$\rightarrow$存在平凡完美覆盖 利用习题7,我们得到如果存在完美覆盖,那么$gcd(n,a)=gcd(m,a)=a$并且$gcd(m,b)=b$,然后我们显然可以让$b$的朝向指向$m$的方向,也就是存在平凡完美覆盖 再证:存在平凡完美覆盖$\rightarrow$存在完美覆盖 显然 9.显然,举个简单例子$n=5,m=6,a=2,b=3$存在完美覆盖,但是不存在平凡完美覆盖. 10.假设存在不妨设四个变量是$a,b,c,d$,那么可以得到$a+b=b+c$即$a=c$显然不能构成幻方 11.12.13 如图 14.所有可能的构造如图 15.暴力枚举的,确实没有解,并不知道为什么…… 16.$n$阶幻方,幻方总和是$n^2\ast (n^2+1)/2$,所以每一行每一列求和都是$n\ast (n^2+1)/2$,现在替换后每一行每一列的和换成了$n\ast (n^2+1) - n\ast (n^2+1)/2 = n\ast (n^2+1)/2$所以可能是个幻方,然后因为里面的元素都是属于$[1,n^2]$之间的,所以$n^2+1-a$可以保证换完之后每个元素还是只出现一次,所以新生成的还是幻方. 17.给出$n=4$和$n=8$时的图……. 18.这个应该是显然的,因为二阶幻方都没有,显然没有二阶幻方体. 19.首先我们拆开来看没一个单独的平面,我们可以得到,对于一个四阶幻方来说,如果对角线也满足幻和,那么显然可以得到任意三阶子矩阵的对顶角之和等于幻和的一半,所以我们任取出四阶幻方体的任一三阶子体,可以得到类似于$a+b=b+c$的等式,也就是说存在$a==c$的情况,这显然和题意不符,所以不可能存在四阶幻方体. 20.首先,$10$和$5$一个颜色,$1,3,7,9$一个颜色,$2,4,6,8$一种颜色,可以得到可以由三种颜色构成,然后,$1,2,10$相互接壤,显然需要三种及以上颜色来涂,方案数为$3\ast 2\ast 1 = 6$. 21.(a) 二阶的显然不存在,书后面给了答案,还有一个比较简单的想法就是如果存在显然可以得到类似于$a==b$的结论,所以不存在. (b) 暴搜剪枝,emmmmm……如图]]></content>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IC(answer.chepter2)]]></title>
    <url>%2F2018%2F12%2F24%2Fknowledge%2FIC_chepter2%2F</url>
    <content type="text"><![CDATA[作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢 1.$\emptyset$ : $4^5 = 1024$.$\lbrace a\rbrace$ : $5\times 4\times 4\times 4 = 320$.$\lbrace b\rbrace$ : $5\times 5\times 5\times 2 = 250$.$\lbrace a,b\rbrace$ : $4\times 4\times 4\times 2 = 128$ 2.$(13!)^4 = 1503561738404723998944447273369600000000$. 3.$$\left( \begin{matrix} 52\\ 5 \end{matrix}\right)=2598960$$ 4.(a) $5\times 3\times 7\times 2 = 210$(b) $620 = 2^2+3^1+5^1+7^1$,$3\times 2\times 2\times 2 = 24$(c) $10^{10} = 2^{10} 5^{10}$,$11\times 11 = 121$ 5.因为$10 = 2\times 5$,所以我们只用统计$2,5$的数量就行了,然后我们可以发现,$2$的数量显然多于$5$的数量,所以我们只用统计$5$的个数就是答案.下面给出一个通用的代码 12345int cal(int a)&#123; int ret = 0; while(a) ret+=a/=5; return ret;&#125; 6.小数据暴力,大数据模拟]]></content>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 463 A weird recurrence relation]]></title>
    <url>%2F2018%2F12%2F23%2FPE%2FPE463%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The function $f$ is defined for all positive integers as follows: $f(1)$ = $1$ $f(3)$ = $3$ $f(2n)$ = $f(n)$ $f(4n+1)$ = $2\cdot f(2n+1)-f(n)$ $f(4n+3)$ = $3\cdot f(2n+1)-2\cdot f(n)$ The function $S(n)$ is defined as $\sum_{i=1}^{n} f(i)$. $S(8)=22$ and $S(100)=3604$. Find $S(3^{37})$. Give the last $9$ digits of your answer. 题意就是给你一个序列,问你这个序列的前缀和是多少 分析显然是推公式嘛. 根据题意我们显然可以得到 $f(4n)+f(4n+1)+f(4n+2)+f(4n+3) = 6\cdot f(2n+1) - 2\cdot f(n)$ for $n\geq 1$ 然后我们每四项加一下就可以得到下面这个公式 \begin{eqnarray}S(4n+3) &amp;=&amp; \sum_{i=1}^{4i+3} f(i)\\ &amp;=&amp; 5 + \sum_{i=4}^{4i+3} f(i)\\ &amp;=&amp; 5 + \sum_{i=1}^{n} (6\cdot f(2i+1) - 2\cdot f(i))\\ &amp;=&amp; 5 + 6\sum_{i=1}^{n} (f(2i+1)+f(2i)) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; 5 + 6\sum_{i=2}^{2n+1} f(i) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; 5 - 6 + 6\sum{i=1}{2n+1} f(i) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; -1 + 6\sum{i=1}{2n+1} f(i) -8\sum_{i=1}^{n} f(i)\\\end{eqnarray} 然后瞎搞就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+10;const int mod = 1e9;inline int add(long long a,long long b)&#123;return (a+b)%mod;&#125;inline int mul(long long a,long long b)&#123;return a*b%mod;&#125;int num[maxm];int sum[maxm];long long f(long long a)&#123; if(a&lt;maxm&amp;&amp;num[a]) return num[a]; if(a==0) return 0; if(a==1) return 1; if(a==3) return 3; if((a&amp;1)^1) return f(a&gt;&gt;1); else if((a&amp;3)==3) return add(mul(3,f(a&gt;&gt;1)),mod-(f(a&gt;&gt;2)&lt;&lt;1)); else return add((f(a&gt;&gt;1|1)&lt;&lt;1),mod-f(a&gt;&gt;2));&#125;long long S(long long a)&#123; if(a&lt;maxm) return sum[a]; long long ret = 0; if(a%4==3)&#123; ret = add(ret,mul(6,S(a&gt;&gt;1))); ret = add(ret,mod-mul(8,S(a&gt;&gt;2))); ret = add(ret,mod-1); &#125;else&#123; while(a%4!=3) ret = add(ret,mod-f(++a)); ret = add(ret,S(a)); &#125; return ret;&#125;int main()&#123; for(int i = 1;i&lt;maxm;i++) num[i] = f(i),sum[i] = add(sum[i-1],num[i]); long long nouse = 1; for(int i = 1;i&lt;=37;i++)&#123; nouse = (nouse&lt;&lt;2)-nouse; &#125; cout&lt;&lt;S(nouse)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab]]></title>
    <url>%2F2018%2F12%2F23%2Fknowledge%2Fmatlab%2F</url>
    <content type="text"><![CDATA[系统级命令 命令名称 功能说明 clear 清楚内存中所有的或指定的变量和函数 cd 显示和改变当前工作目录 clc 擦除MATLAB工作窗口中所有显示的内容 clf 擦除MATLAB当前工作窗口中的图形 dir 列出当前或者指定目录下的子目录和文件清单 disp 在运行中显示变量或文字信息 echo 控制运行的文字命令是否显示 hold 控制当前的图形窗口对象是否被刷新 home 擦除命令窗口中的内容,并把光标移动到命令窗口 pack 收集内存碎片以扩大内存空间 quit 关闭并退出MATLAB type 显示所指定文件的全部内容 exit 退出MATLAB save 将工作区的变量存放到指定文件 load 回复保存过的变量 系统变量 变量 解释 ans 结果的缺省变量名 pi 圆周率 i,j 虚数单位 inf 无穷大 NaN not a number 矩阵函数 函数 解释 complex 将两个矩阵并成一个复矩阵 zeros(a,b) a*b全0阵 ones(a,b) a*b全1阵 eye(a,b) a*b单位矩阵 randi([a,b],m,n) m*n在a,b之间等概率随机整数矩阵 randn(a,b) 产生均值为0,方差为1的a*b的高斯分布随机阵 repmat(a,b,c) 将a矩阵铺放成bc的形式,总大小size(a)b*c size(a) 确定矩阵大小,返回[行数,列数] length(a) 确定向量元素的个数 numel(a) 确定矩阵中元素个数 find() 查找矩阵中满足条件的下标,或者行列 reshape(a,b,c) 将a变成b行c列(按列重拍) a’ 转置,复数则共轭转置 a(:) 变成一列 rot90 旋转 fliplr 左右翻转 flipud 上下翻转 diag 抽取主对角线 tril 抽取上三角 triu 抽取下三角 max 各列最大值 min 各列最小值 sort 各列递增排序 sum 各列求和 mean 各列平均值 std 各列标准差 var 各列方差 基本数学函数 函数 解释 abs(x) x中每个实数元素的绝对值,复数元素的模 sqrt(x) x中每个元素求平方根 exp(x) 指数运算 real(x) 求实部 imag(x) 求虚部 conj(x) 求共轭 angle(x) 求相位角 sin(x) 正弦 cos(x) 余弦 asin(x) 反正弦 acos(x) 反余弦 tan(x) 正切 atan(x) 反正切 log10(x) 常用对数lgx log(x) 自然对数lnx loga(b) 任意对数 mod(x,y) 求余函数 rem(x,y) 输出对应元素的余数 sign(x) 求矩阵中元素的正负号 lcm(x,y) 最小公倍数 gcd(x,y) 最大公约数 round(a) 四舍五入 fix(a) 按0的方向取整 floor(a) 向负无穷方向取整 ceil(a) 向正无穷方向取整 randperm(n) 产生一个长度为n的排列 绘图 函数 解释 plot(x,y,’option’) x横轴,y纵轴,逐点连折线绘制二维图形,参数见下表 plot(y) y为向量,以下标作为x轴,y为纵轴,绘制曲线 title(‘text’) 添加标题 xlabel(‘text’) x轴加标注 ylabel(‘text’) y轴加标记 legend(‘图例1’,’图例2’,…) 添加图例 text(x,y,’text’) 在指定位置添加文本字符串 gtext(‘text’) 用鼠标放置文本 axis([xmin xmax ymin ymax zmin zmax]) 调整坐标 hold 图形保持函数 subplot 子图分割命令 stem 离散序列 绘图参数表 符号 含义 符号 含义 y 黄 b 蓝 m 洋红 w 白 c 青 k 黑 r 红 g 绿 - 实线 – 虚线 : 点线 -. 点划线 . 点 o 圆 x 叉号 + 加号 ^ 向上的三角形 v 向下的三角形 &gt; 大于号 &lt; 小于号 s 正方形 d 菱形 p 五角星 h 六角星 * 星号 字符串函数 函数 解释 abs 字符串到ascii转换 str2mat 字符串转换成字符矩阵 setstr ascii转字符串 num2str 数值转字符串 str2num 字符串转换成数值 dec2bin 十进制数转二进制字符串 bin2dec 二进制串转十进制 int2str 将数值取整后转成字符串 upper 字符串转换成大写 lower 字符串转换成小写 sprintf 用格式控制,数字转字符串 sscanf 格式控制,字符串转数字 输入输出 函数 解释 input(‘text’) 键盘提示输入 fprintf() 格式输出]]></content>
      <tags>
        <tag>live</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 368 A Kempner-like series]]></title>
    <url>%2F2018%2F12%2F21%2FPE%2FPE368%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The harmonic series $1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\dots$ is well known to be divergent. If we however omit from this series every term where the denominator has a $9$ in it, the series remarkably enough converges to approximately $22.9206766193$. This modified harmonic series is called the Kempner series. Let us now consider another modified harmonic series by omitting from the harmonic series every term where the denominator has $3$ or more equal consecutive digits. One can verify that out of the first $1200$ terms of the harmonic series, only $20$ terms will be omitted.These $20$ omitted terms are: $$\frac{1}{111},\frac{1}{222},\frac{1}{333},\frac{1}{444},\frac{1}{555},\frac{1}{666},\frac{1}{777},\frac{1}{888},\frac{1}{999},\frac{1}{1000},\frac{1}{1110}, \frac{1}{1111},\frac{1}{1112},\frac{1}{1113},\frac{1}{1114},\frac{1}{1115},\frac{1}{1116},\frac{1}{1117},\frac{1}{1118},\frac{1}{1119}$$ This series converges as well. Find the value the series converges to.Give your answer rounded to $10$ digits behind the decimal point. 题意就是,调和级数不是发散的嘛,然后让你删掉那些分母含有连续三个相同数字的,然后可以证明剩下的级数是收敛的,然后问你收敛于多少. 分析做法比较巧妙,下面一点点分析. 首先我们令$S_1(n,d)$表示一个包含所有这样的$n$位数的集合,集合中所有的$n$位数最后一位是$n$,并且倒数第二位不是$n$. $S_2(n,d)$表示一个包含所有这样的$n$位数的集合,集合中所有的$n$位数最后两位是$n$,并且倒数第三位不是$n$. 然后我们令 $f_1(n,d,j)$ = $\sum_{x\in S_1(n,d)} \frac{1}{x^j}$ $f_2(n,d,j)$ = $\sum_{x\in S_2(n,d)} \frac{1}{x^j}$ 然后答案显然就是 $\sum_{i=1}^{99} \frac{1}{i}+\sum_{n=3}^{\infty } \sum_{d=0}^{9} [f_1(n,d,1)+f_2(n,d,1)]$ 关键是我们怎么算$f_1(n,d,j)$和$f_2(n,d,j)$ 二者分析方法一样,这里给出$f_2(n,d,j)$怎么推出来的. 首先根据定义我们有 $f_2(n,d,j)$ = $\sum_{x\in S_2(n,d)} \frac{1}{x^j}$ 我们不妨枚举每一个$x$,然后累加就是答案,所以子问题就是如何快速计算$\frac{1}{x^j} where x \in S_2(n,d)$ 因为最后一位是$d$,所以我们不妨设$x$ = $y\ast 100+d\ast 10+d$ 然后可以得到 $$(\frac{1}{x\ast 100+d\ast 10+d})^j=\frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot (\frac{1}{1+\frac{d}{x\ast 100+d\ast 10}})^j$$ 然后我们将第三个分式化简. 考虑到 $(1+a)^{-b} = \sum_{i=0}^{\infty } C_{b+i-1}^i \cdot (-a)^b$ 所以上式可以化简为 \begin{eqnarray}(\frac{1}{x\ast 100+d\ast 10+d})^j&amp;=&amp; \frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot \sum_{i=0}^{\infty } C_{j+i-1}^{i}(\frac{-d}{x\ast 100+d\ast 10})^i\\&amp;=&amp; \frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot \sum_{i=0}^{\infty } C_{j+i-1}^{i}(\frac{-d}{10})^i\cdot(\frac{1}{x\ast 10+d})^i\\&amp;=&amp; \frac{1}{10^j} \sum_{i=0}^{\infty } C_{j+i-1}^{i} \cdot (\frac{-d}{10})^i \cdot (\frac{1}{x\ast 10+d})^{i+j}\\\end{eqnarray} 然后我们考虑累加所有的$x$也就是原来的$f_2(n,d,j)$ 可以得到 $$f_2(n,d,j) = \frac{1}{10^j} \sum_{i=0}^{\infty } (\frac{-d}{10})^i \cdot C_{j+i-1}^{i} \cdot f_1(n-1,d,i+j)$$ 同理可以推得 $f_1(n,d,j)$ 然后就是代码如下啦啦啦$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 40;double C[maxm*3][maxm*3];double f1[2][10][maxm+1];double f2[2][10][maxm+1];double ans = 0;void init()&#123;//预处理出组合数和前99项的答案 for(int i = 0;i&lt;maxm*3;i++) for(int j = 0;j&lt;=i;j++)&#123; if(j==0) C[i][j] = 1; else C[i][j] = C[i-1][j-1]+C[i-1][j]; &#125; for(int i = 1;i&lt;100;i++) ans+=1.0/i;&#125;int main()&#123; init(); for(int d = 0;d&lt;=9;d++)&#123;//预处理出n = 3的情况 for(int j = 1;j&lt;=maxm;j++)&#123; for(int pre = 10;pre&lt;100;pre++)&#123; int fir = pre/10; int sec = pre%10; if(fir==sec&amp;&amp;sec==d) continue; if(sec==d) f2[1][d][j]+=1.0/pow(pre*10+d,j); else f1[1][d][j]+=1.0/pow(pre*10+d,j); &#125; &#125; ans+=f1[1][d][1]+f2[1][d][1]; &#125; for(int nouse = 4;nouse&lt;=10000;nouse++)&#123;//滚动的算n&gt;=4的时候 int now = nouse&amp;1; int las = now^1; for(int d = 0;d&lt;=9;d++)&#123; for(int j = 1;j&lt;=maxm;j++)&#123; f1[now][d][j] = f2[now][d][j] = 0;//别忘了初始化 double pre = 1.0/pow(10.0,j); for(int i = 0;i&lt;=maxm;i++)&#123; if(i+j&lt;=maxm) f2[now][d][j]+=pre*C[j+i-1][i]*f1[las][d][i+j]; for(int x = 0;x&lt;10;x++)&#123; if(x==d) continue; if(i+j&lt;=maxm) f1[now][d][j]+=pre*C[j+i-1][i]*(f1[las][x][i+j]+f2[las][x][i+j]); &#125; pre*=-d/10.0; &#125; &#125; ans+=f1[now][d][1]+f2[now][d][1]; &#125; printf("%.10f\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 492 Exploding sequence]]></title>
    <url>%2F2018%2F12%2F12%2FPE%2FPE492%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Define the sequence $a_1, a_2, a_3,\dots$ as: $a_1 $=$ 1$ $a_{n+1} = 6a_n^2 + 10a_n + 3$ for $n \geq 1$. Examples: $a_3 $=$ 2359$ $a_6 $=$ 269221280981320216750489044576319$ $a_6 mod 1000000007 $=$ 203064689$ $a_{100} mod 1000000007 $=$ 456482974$ Define $B(x,y,n)$ as $\sum (a_n mod $ $p)$ for every prime $p$ such that $x \leq p \leq x+y$. Examples: $B(10^9, 10^3, 10^3)$ = $23674718882$ $B(10^9, 10^3, 10^{15})$ = $20731563854$ Find $B(10^9, 10^7, 10^{15})$. 题意给你一个二次递推序列,问你这个数列的第$10^{15}$项膜上一堆质数之后求和是多少. 分析看了大佬的题解之后才做出来的,还是太菜了$\dots$ 下面是分析. 首先我们令$b_n = 6a_n+5$ 于是有 $b_1$ = $11$ $b_{n+1} $=$ b_n^2-2$ 然后我们令 $ x + \frac{1}{x}$ = $11$ 可以显然发现 $b_n$ = $x^{2^{n-1}} + \frac{1}{x^{2^{n-1}}}$ 于是不妨设 $x$ = $\frac{11+\sqrt{117}}{2}$ $\therefore b_n$ = $(\frac{11+\sqrt{117}}{2})^{2^{n-1}} + (\frac{11-\sqrt{117}}{2})^{2^{n-1}}$ 然后我们可以直接算就行了 我们搞出递推式，然后用矩阵乘法的做法来做 我们考虑一个更一般的问题， 令$f_n = (\frac{11+\sqrt{117}}{2})^n + (\frac{11-\sqrt{117}}{2})^n$ 然后我们考虑$f_n$如何求解 首先我们假设$f_n = x\ast f_{n-1}+y\ast f_{n-2}$ $$令 (\frac{11+\sqrt{117}}{2})^{n-2} = a$$ $$令 (\frac{11-\sqrt{117}}{2})^{n-2} = b$$ 则有\begin{cases}\begin{eqnarray}f_n &amp;=&amp; a\ast (\frac{11+\sqrt{117}}{2})^2+b\ast (\frac{11-\sqrt{117}}{2})^2\\&amp;=&amp; a\ast (\frac{238+22\sqrt{117}}{4})+b\ast (\frac{238-22\sqrt{117}}{4})\\f_{n-1}&amp;=&amp;a\ast (\frac{11+\sqrt{117}}{2})+b\ast (\frac{11-\sqrt{117}}{2})\\f_{n-2}&amp;=&amp;a+b \\\end{eqnarray}\end{cases} \begin{eqnarray}&amp;\therefore&amp; a\ast (\frac{238+22\sqrt{117}}{4})+b\ast (\frac{238-22\sqrt{117}}{4})\\&amp;=&amp; x\ast a\ast (\frac{11+\sqrt{117}}{2})+x\ast b\ast (\frac{11-\sqrt{117}}{2}) + y\ast (a+b)\\\end{eqnarray} 将非根号项提出来，可以得到 $\therefore a\ast \frac{119}{2}+b\ast \frac{119}{2}$=$xa\ast \frac{11}{2}+xb\ast \frac{11}{2}+y(a+b) $ 同理将根号项提出可以得到 $a\ast \frac{11}{2}+b\ast \frac{-11}{2}$=$xa\ast \frac{1}{2}+xb\ast \frac{-1}{2} $ 然后可以解得 \begin{cases}x = 11\\y = -1\end{cases} 也就是说$f_n$ = $11\ast f_{n-1} - f_{n-2}$ 好了，我们得到了$f_n$的递推式，然后考虑原问题，也就是说 $$\left( \begin{matrix} b_{n+1}\\ b_n \end{matrix}\right)=\left( \begin{matrix} 11 &amp; -1\\ 1 &amp; 0 \end{matrix}\right)^{2^{n-1}-1}\left( \begin{matrix} b_2\\ b_1 \end{matrix}\right)=\left( \begin{matrix} 11 &amp; -1\\ 1 &amp; 0 \end{matrix}\right)^{2^{n-1}-1}\left( \begin{matrix} 119\\ 11 \end{matrix}\right)$$ $\because n$ 很大($10^{15}$) $\therefore 2^{n-1}-1$很大,以至于我们不能方便的计算 然后我们考虑降低指数 具体分析看大佬的分析,可以得到循环节可以是$(p+1)(p-1)$ 这个值我们可以接受,然后直接裸的矩阵ksm就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const long long n = 1e15;const long long l = 1e9;const long long r = l+1e7;long long add(long long a,long long b,long long mod)&#123; return (a+b)%mod; &#125;long long mul(long long a,long long b,long long mod)&#123; a = add(a,mod,mod); b = add(b,mod,mod); long long ret = 0; while(b)&#123; if(b&amp;1) ret = add(ret,a,mod); a = add(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;long long qpow(long long a,long long b,long long mod)&#123; long long ret = 1; while(b)&#123; if(b&amp;1) ret = mul(ret,a,mod); a = mul(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;bool is_prime(int a)&#123; if(a&amp;1)&#123; for(int i = 3;i*i&lt;=a;i++) if(a%i==0) return false; return true; &#125; return false;&#125;struct p&#123; int mat[2][2]; void show()&#123; for(int i = 0;i&lt;2;i++)&#123; for(int j = 0;j&lt;2;j++) cout&lt;&lt;mat[i][j]&lt;&lt;' '; cout&lt;&lt;endl; &#125; &#125;&#125;;p mul(p a,p b,long long mod)&#123; p ret; memset(ret.mat,0,sizeof ret.mat); for(int i = 0;i&lt;2;i++)&#123; for(int j =0;j&lt;2;j++)&#123; for(int k = 0;k&lt;2;k++)&#123; ret.mat[i][j] = add(ret.mat[i][j],mul(a.mat[i][k],b.mat[k][j],mod),mod); &#125; &#125; &#125; return ret;&#125;p qpow(p a,long long b,long long mod)&#123; p ret; for(int i = 0;i&lt;2;i++) for(int j = 0;j&lt;2;j++) &#123; if(i==j) ret.mat[i][j]=1; else ret.mat[i][j]=0; &#125; while(b)&#123; if(b&amp;1) ret = mul(ret,a,mod); a = mul(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;long long solve(long long prime)&#123; const long long MOD = prime*prime-1; long long zhi = qpow(2,n-1,MOD); zhi = add(zhi,MOD-1,MOD); p base; base.mat[0][0]=11,base.mat[0][1]=-1; base.mat[1][0]=1 ,base.mat[1][1]=0; base = qpow(base,zhi,prime); long long ret1 = mul(base.mat[1][0],119,prime); long long ret2 = mul(base.mat[1][1],11,prime); return add(ret1,ret2,prime);&#125;long long inv(long long a,long long mod)&#123; if(a==1) return 1; return mul(mod-mod/a,inv(mod%a,mod),mod);&#125;int main()&#123; long long ans = 0; for(int i = l;i&lt;=r;i++)&#123; if(is_prime(i))&#123; long long bn = solve(i); long long now1 = add(bn,i-5,i); long long an = mul(now1,inv(6,i),i); ans+=an; &#125; if(i%100000==0) cout&lt;&lt;i&lt;&lt;endl; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 294 Sum of digits-experience]]></title>
    <url>%2F2018%2F12%2F09%2FPE%2FPE294%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For a positive integer $k$, define $d(k)$ as the sum of the digits of $k$ in its usual decimal representation. Thus $d(42) = 4+2 = 6$. For a positive integer $n$, define $S(n)$ as the number of positive integers $k &lt; 10^n$ with the following properties : $k$ is divisible by $23$ and $d(k) = 23$. You are given that $S(9) = 263626$ and $S(42) = 6377168878570056$. Find $S(11^{12})$ and give your answer mod $10^9$. 题意你要找到一个所有满足一下三个条件的数字数量 假设这个数是$k$ $k$ $&lt;$ $10^{11^{12}}$ $k\%23$ = 0 $k$每个十进制位求和为$23$ 分析这个题目困扰了我两天,我一度以为自己读错题了,主要是数据范围太大了,大的人一点想法都没有$\dots$ 下面说正解 虽然数据范围很大,但是我们可以从小数据入手 先看第二个条件$k%23==0$,是否感觉出了一丝丝猫腻? 于是我大胆写了一下,比较好想的就是一定存在一个$n$使得$10^n%23==1$,也就是说存在膜数存在循环,而且显然有循环节是$O(23)$的 于是大胆暴力,找到了,循环节长度为$22$ 这也就是说,在十进制下,位数最多有$11^{12}$个,而且这些里面,可以拆分成$22$份,每一份里面,你不管把数字安排到哪里,都是同膜的 于是我们可以简单的把$11^{12}$近似的均分成了$22$份.而且每一份可以单独统计答案 然后问题就转化成了以下两个子问题: 找到$a_1,a_2\dots a_{22}$使得$a_1+a_2+\dots +a_{22} = 23$ 对于每一份就成了一个$a_i$个相同的球放入近似$11^{12}$个盒子里,每个盒子最多放$9$个球,问你方案数 对于第一个子问题,我们显然可以动态规划搞一搞 定义$dp(i,j,k)$表示$a_1+a_2+\dots +a_i == j$并且当前膜数为$k$的方案数 然后暴力转移就行了 关键是第二个子问题不好想,因为盒子数量太大了,必须要有一个$log$的做法 然后就枚举算法(毕竟会的算法不多) 然后就想到了分治,但是能不能分治呢,并不知道,写一发就知道了,然后跑的挺快的(然后就过了) 并不会算分治的玄学复杂度 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9;int add(int a,int b)&#123;return (a+b)%mod;&#125;int mul(int a,int b)&#123;return 1ll*a*b%mod;&#125;long long n,m;void init()&#123; m = 23; n = 1; for(int i = 1;i&lt;=12;i++) n*=11;&#125;map&lt;pair&lt;long long,int&gt;,int&gt;mp;int solve(long long a,int b)&#123;///b ball,a boxes if(a==1) return b&lt;=9; if(a==0) return b==0; pair&lt;long long,int&gt; now = make_pair(a,b); if(mp[now]) return mp[now]; int ret = 0; long long l = a/2,r = a-l; for(int i = 0;i&lt;=b;i++) ret = add(ret,mul(solve(l,i),solve(r,b-i))); return mp[now] = ret;&#125;long long dp[30][30][30];int main()&#123; init(); dp[0][0][0] = 1; int w = 1; for(int i = 0;i&lt;m;i++)&#123; long long has = n/(m-1) + (i&lt;n%22); for(int j = 0;j&lt;=m;j++)&#123; for(int k = 0;k&lt;m;k++)&#123; for(int t = 0;j+t&lt;=m;t++)&#123; dp[i+1][j+t][(k+w*t)%m] = add(dp[i+1][j+t][(k+w*t)%m],mul(dp[i][j][k],solve(has,t))); &#125; &#125; &#125; w = w*10%m; &#125; cout&lt;&lt;dp[m-1][m][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 288 An enormous factorial]]></title>
    <url>%2F2018%2F12%2F08%2FPE%2FPE288%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For any prime $p$ the number $N(p,q)$ is defined by $N(p,q) = \sum_{n=0}^q T_n*p^n$with $T_n$ generated by the following random number generator: \begin{eqnarray}&amp;&amp;S_0 = 290797\\&amp;&amp;S_{n+1} = S_n^2 mod 50515093\\&amp;&amp;T_n = S_n mod p\\\end{eqnarray} Let $Nfac(p,q)$ be the factorial of $N(p,q)$.Let $NF(p,q)$ be the number of factors $p$ in $Nfac(p,q)$. You are given that $NF(3,10000) mod 3^{20}=624955285$. Find $NF(61,10^7)$ mod $61^{10}$ 题意题意说的有点麻烦，我简化一下 $T_i$是随机生成的数据，$N(p,q)=\sum_{n=0}^q T_n*p^n$ 问你$N(p,q)$的阶乘里面，质因数分解以后$p$的指数膜$p^{10}$答案是多少． 分析首先可以观察到的是，$T_i$很小，而且他是随机的，我们显然要把他存起来． 然后一个比较显然的结论是$$n!质因数分解后素因子p的数量为\lfloor \frac{n}{p} \rfloor + \lfloor \frac{n}{p^2} \rfloor + \cdots$$$$\because 最后的答案要膜 p^{10} \therefore 我们统计的时候，对于第一项，我们统计指数为 [1,10]的，第二项[2,11],然后枚举项统计答案即可$$ 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+1;const int pow_num = 10;long long T[maxm+100];const int p = 61;long long powp[1000];void init()&#123; powp[0] = 1; for(int i = 1;i&lt;=pow_num;i++) powp[i] = powp[i-1]*p; long long s0 = 290797; for(int i = 1;i&lt;maxm;i++) T[i] = (s0=s0*s0%50515093)%p;&#125;int main()&#123; init(); long long ans = 0; const long long mod = powp[pow_num]; for(int i = 1;i&lt;maxm;i++) for(int j = i;j&lt;=i+pow_num-1;j++) ans = (ans+(T[j]*powp[j-i]%mod))%mod; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 303 Multiples with small digits]]></title>
    <url>%2F2018%2F12%2F08%2FPE%2FPE303%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For a positive integer $n$, define $f(n)$ as the least positive multiple of $n$ that, written in base $10$, uses only digits $≤ 2$. Thus $f(2)=2, f(3)=12, f(7)=21, f(42)=210, f(89)=1121222$. Also,$ \sum_{n=1}^{100} \frac{f(n)}{n} = 11363107 $ Find $ \sum_{n=1}^{10000} \frac{f(n)}{n}. $ 题意问你对于每个数字来说，找到他的一个最小整数倍，使得最小整数倍在十进制下每位都小于3 分析很显然，考的是搜索，如何高效搜索． 最简单的想法就是枚举倍数，然后逐个判断是否合法，然后你会发现所有$999$的倍数都Ｔ飞了 然后考虑剪枝，因为可以显然得到，有些倍数一定无效，比如： $5来说，5\ast 1 = 5,5\ast 11 = 55,5\ast 21 = 105 \dots$ 可以显然发现，对于$5$来说，以$1$结尾的倍数显然都不合理，因为他们的最后一位一定是$5$，可以直接判断掉． 然后你就就基本可以过掉大部分数据，但是还是有一个比较头疼，那就是$9999$. 因为他对应的答案贼大，暴力搜索基本都GG．然后我们换一个思路． 那就是我们直接暴力枚举所有的那些看起来长的像$3$进制的十进制数． 然后我们就直接存储所有的这样的数字，然后枚举？ 那么显然内存不够，那怎么办呢？ dfs? 还是Ｔ飞，所以我们还要在此基础上剪枝． 首先我们可以构造出一种做法就是，每次搜索的时候得到的都是之前没出现过的最小的这类数字． 然后我们维护一个mod数组，表示当前这个mod正确的情况下，最小的这类数字是多少 然后答案显然就是mod[0]啦……. 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define ll unsigned long longusing namespace std;ll vis[10000+100];ll cal(int a)&#123; queue&lt;ll&gt; que; que.push(1),que.push(2); memset(vis,0,sizeof vis); vis[1] = 1; vis[2] = 2; while(true)&#123; ll now = que.front(); que.pop(); if(now%a==0) return now/a; for(int i = 0;i&lt;3;i++)&#123; ll buf = now*10+i; ll buff = buf%a; if(vis[buff]) continue; vis[buff] = buf; que.push(buf); &#125; &#125;&#125;int main()&#123; ll ans = 0; for(int i = 1;i&lt;=10000;i++) ans+=cal(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>PE</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mathematical formula(Irregular updates)]]></title>
    <url>%2F2018%2F12%2F07%2Fknowledge%2FMathematical_Formula%2F</url>
    <content type="text"><![CDATA[二元运算符 符号 功能 代码 符号 功能 代码 符号 功能 代码 $+$ 加 + $-$ 减 - $\triangleleft$ \triangleleft $\pm$ 加减 \pm $\mp$ 减加 \mp $\triangleright$ \triangleright $\times$ 乘 \times $\setminus$ 差集 \setminus $\star$ ５星乘 \star $\cup$ 并 \cup $\cap$ 交 \cap $\ast$ ６星乘 \ast $\sqcup$ \sqcup $\sqcap$ \sqcap $\circ$ \circ $\vee$ 合取 \vee $\wedge$ 析取 \wedge $\bullet$ \bullet $\oplus$ 异或 \oplus $\ominus$ \ominus $\diamond$ \diamond $\odot$ \odot $\oslash$ \oslash $\uplus$ \uplus $\otimes$ \otimes $\bigcirc$ \bigcirc $\amalg$ \amalg $\bigtriangleup$ \bigtriangleup $\bigtriangledown$ \bigtriangledown $\dagger$ \dagger $\lhd$ \lhd $\rhd$ \rhd $\ddagger$ \ddagger $\unlhd$ \unlhd $\unrhd$ \unrhd $\wr$ \wr 二元关系符 符号 功能 代码 符号 功能 代码 符号 功能 代码 $&lt;$ 小于 &lt; $&gt;$ 大于 &gt; $=$ 等于 = $\leq$ 小于等于 \leq $\geq$ 大于等于 \geq $\equiv$ 同余 \equiv $\ll$ 远小于 \ll $\gg$ 远大于 \gg $\doteq$ 约等于 \doteq $\prec$ \prec $\succ$ \succ $\sim$ \sim $\preceq$ \preceq $\succeq$ \succeq $\simeq$ \simeq $\subset$ 子集 \subset $\supset$ 父集 \supset $\approx$ \approx $\subseteq$ \subseteq $\supseteq$ \supseteq $\cong$ \cong $\sqsubset$ \sqsubset $\sqsupset$ \sqsupset $\Join$ \Join $\sqsubseteq$ \sqsubseteq $\sqsupseteq$ \sqsupseteq $\bowtie$ \bowtie $\in$ 属于 \in $\ni$ 被属于 \ni $\propto$ \propto $\vdash$ 蕴涵 \vdash $\dashv$ 被蕴涵 \dashv $\models$ \models $\mid$ 整除 \mid $\parallel$ 平行 \parallel $\perp$ \perp $\smile$ \smile $\frown$ \frown $\asymp$ \asymp $:$ ： $\notin$ 不属于 \notin $\neq$ 不等于 \neq 小写希腊字母 符号 代码 符号 代码 符号 代码 符号 代码 符号 代码 $\alpha$ \alpha $\beta$ \beta $\gamma$ \gamma $\delta$ \delta $\omega$ \omega $\epsilon$ \epsilon $\varepsilon$ \varepsilon $\zeta$ \zeta $\eta$ \eta $\psi$ \psi $\theta$ \theta $\vartheta$ \vartheta $\iota$ \iota $\kappa$ \kappa $\varphi$ \varphi $\lambda$ \lambda $\mu$ \mu $\nu$ \nu $\xi$ \xi $\phi$ \phi $\pi$ \pi $\varpi$ \varpi $\rho$ \rho $\varrho$ \varrho $\upsilon$ \upsilon $\sigma$ \sigma $\varsigma$ \varsigma $\tau$ \tau 大写希腊字母 符号 代码 符号 代码 符号 代码 符号 代码 符号 代码 $\Gamma$ \Gamma $\Delta$ \Delta $\Theta$ \Theta $\Lambda$ \Lambda $\Omega$ \Omega $\Xi$ \Xi $\Pi$ \Pi $\Sigma$ \Sigma $\Upsilon$ \Upsilon $\Psi$ \Psi $\Phi$ \Phi 箭头 符号 代码 符号 代码 符号 代码 符号 代码 $\leftarrow$ \leftarrow $\rightarrow$ \rightarrow $\Leftarrow$ \Leftarrow $\Rightarrow$ \Rightarrow $\longleftarrow$ \longleftarrow $\longrightarrow$ \longrightarrow $\Longleftarrow$ \Longleftarrow $\Longrightarrow$ \Longrightarrow $\uparrow$ \uparrow $\downarrow$ \downarrow $\Uparrow$ \Uparrow $\Downarrow$ \Downarrow $\nwarrow$ \nwarrow $\nearrow$ \nearrow $\swarrow$ \swarrow $\searrow$ \searrow $\Leftrightarrow$ \Leftrightarrow $\Longleftrightarrow$ \Longleftrightarrow $\Updownarrow$ \Updownarrow $\iff$ \iff $\mapsto$ \mapsto $\longmapsto$ \longmapsto $\hookleftarrow$ \hookleftarrow $\hookrightarrow$ \hookrightarrow $\leftharpoonup$ \leftharpoonup $\rightharpoonup$ \rightharpoonup $\leftharpoondown$ \leftharpoondown $\rightharpoondown$ \rightharpoondown $\updownarrow$ \updownarrow $\leadsto$ \leadsto $\rightleftharpoons$ \rightleftharpoons $\longleftrightarrow$ \longleftrightarrow $\leftrightarrow$ \leftrightarrow 括号 符号 代码 符号 代码 符号 代码 符号 代码 $\lbrack$ \lbrack $\rbrack$ \rbrack $\lbrace$ \lbrace $\rbrace$ \rbrace $\langle$ \langle $\rangle$ \rangle $\lfloor$ \lfloor $\rfloor$ \rfloor $\vert$ \vert $\Vert$ \Vert $\lceil$ \lceil $\rceil$ \rceil $\backslash$ \backslash 大尺寸符号 符号 代码 符号 代码 符号 代码 符号 代码 $\lgroup$ \lgroup $\rgroup$ \rgroup $\lmoustache$ \lmoustache $\rmoustache$ \rmoustache $\arrowvert$ \arrowvert $\Arrowvert$ \Arrowvert $\bracevert$ \bracevert]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UPCOJ 9805 Network Reliability]]></title>
    <url>%2F2018%2F12%2F03%2Fother_oj%2FUPCOJ9805%2F</url>
    <content type="text"><![CDATA[题目描述An undirected graph is given. Each edge of the graph disappears with a constant probability. Calculate the probability with which the remained graph is connected. 输入The first line contains three integers N (1≤N≤14), M (0≤M≤100) and P (0≤P≤100), separated by a single space. N is the number of the vertices and M is the number of the edges. P is the probability represented by a percentage. The following M lines describe the edges. Each line contains two integers $ v_i $ and $ u_i $ (1≤$ u_i $ ,$ v_i $≤N). ($ u_i $ ,$ v_i $) indicates the edge that connects the two vertices $ u_i $ and$ v_i $. 输出Output a line containing the probability with which the remained graph is connected. Your program may output an arbitrary number of digits after the decimal point. However, the absolute error should be $10^{−9}$ or less. 样例输入3 3 50 1 2 2 3 3 1 样例输出0.500000000000 题意zuhiul 和不超过14 个妹子存在着不清不楚的关系，但是他发现，有些妹子们相互之间是闺蜜，所以这些是闺蜜的妹子们有 $P$ 的概率会发现对面和zuhiul有关系从而导致关系破裂，现在问你多大的概率下，大家相安无事(妹子们还是一个联通图)． 分析数据量这么小，显然状压呀． 所以我们定义 $DP[i] 表示 state==i 时，i 包含的点相互联通的概率$ 那么比较容易得到答案就是 $ DP[(1&lt;&lt;n)-1] $ 现在我们考虑转移： ​ 因为要保证state内任意两点可达，所以我们不妨枚举出所有不可达的情况，容斥一下就行了． ​ 所以每次对于一个state，我们可以枚举他的每个点的子集，然后对于其他点到这个集合都割掉就行了 ​ 你问我为什么不会重复和遗漏？ ​ 这就要用到神奇的构造了． ​ 首先我们保证每个正确的点的子集里面都包含某一个点，那么对于包含这个点的所有正确子集来说肯定各不相同，这个保证了不会重复 ​ 然后怎么证明没有遗漏呢？ ​ 因为对于任何一个点来说，他都属于某一个联通块，我们实际上是在枚举每一个联通块，所以不会遗漏呀． ​ 恩，大概就是这样，详情请看代码． ​ 最后说一下复杂度． ​ 应该是 $O(\sum_{i = 1}^{n} C_n^i * 2^i) = O(3^n)$ 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;double p;double pow_p[100];int pow_2[100];int mat[100][100];void init()&#123; scanf("%d%d%lf",&amp;n,&amp;m,&amp;p); p/=100; pow_2[0] = 1; pow_p[0] = 1; for(int i = 1;i&lt;100;i++) pow_p[i] = pow_p[i-1]*p,pow_2[i] = pow_2[i-1]&lt;&lt;1; for(int i = 1,from,to;i&lt;=m;i++) &#123; scanf("%d%d",&amp;from,&amp;to); mat[--from][--to]++; mat[to][from]++; &#125;&#125;const int maxm = 1&lt;&lt;15;double dp[maxm];int has[100];int sub[100];void get(int state)&#123; dp[state] = 1; has[0] = 0; for(int i = 0;i&lt;n;i++) if(state&amp;(1&lt;&lt;i)) has[++has[0]] = i; if(has[0]==1) return ; for(int now = state&amp;(state-1);now;now = (now-1)&amp;state)&#123; if((now&amp;(1&lt;&lt;has[1]))==0) continue; sub[0] = 0; for(int i = 1;i&lt;=has[0];i++) if(now&amp;(1&lt;&lt;has[i])) sub[++sub[0]] = has[i]; int cnt = 0; for(int i = 1;i&lt;=has[0];i++) for(int j = 1;j&lt;=sub[0];j++)&#123; if(now&amp;(1&lt;&lt;has[i])) continue; cnt+=mat[has[i]][sub[j]]; &#125; dp[state]-=dp[now]*pow_p[cnt]; &#125;&#125;int main()&#123; init(); const int nouse = pow_2[n]; for(int i = 1;i&lt;nouse;i++)&#123; get(i); &#125; printf("%.10f\n",dp[nouse-1]); return 0;&#125;]]></content>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UPCOJ 9999 Cube]]></title>
    <url>%2F2018%2F12%2F03%2Fother_oj%2FUPCOJ9999%2F</url>
    <content type="text"><![CDATA[题目描述给你一个 $ n\ast m $ 的棋盘，有一个 $ 1\ast 1\ast 2 $ 的长方体竖直放在 (1,1)上，你可以将其在棋盘上滚动，你的目标是让其竖直放在 ( n , m ) 上，问至少需要多少次操作。(放倒、竖直、翻滚) 输入一行，两个整数n，m (n&lt;=m) 输出需要最少时间能从(1,1)到达(n,m)，如果无解输出 $ impossible $ . 样例输入1 1 样例输出0 提示 分析这个题目我的做法其实比较暴力，因为和队友赌能不能1Y ，我甚至怂到写暴力对拍了．．．． 闲话少说，下面看分析． 其实还是比较好想的． 首先我们考虑哪种情况是 impossible ．比较好观察的是，当ｎ和ｍ足够大的时候就一定可达 所以我们只用找到一个ｎ和ｍ可达的下界就行了 然后就可以发现只有当ｎ和ｍ都小于３的时候会有impossible的情况(因为转不动．．．． 接下来分析其他情况，首先比较好分析的是，如果n%3==1&amp;&amp;m%3==1的话，答案可以显然得到是 $(n/3+m/3)\ast 2$ 剩下的同理搞搞就行了，大体情况见下表． 比较显然的是，加的那一项和n,m％3为2的数量一致，然后就是代码啦．．． 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std; int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; if(n&lt;=2)&#123; if(m%3==1) cout&lt;&lt;m/3*2+n-1&lt;&lt;endl; else cout&lt;&lt;"impossible"&lt;&lt;endl; &#125;else if(n==3&amp;&amp;m==3) cout&lt;&lt;8&lt;&lt;endl; else if(n==3)&#123; if(m%3==0) cout&lt;&lt;m/3*2+4&lt;&lt;endl; else if(m%3==1) cout&lt;&lt;(m+2)/3*2&lt;&lt;endl; else cout&lt;&lt;m/3*2+5&lt;&lt;endl; &#125;else &#123; int ans = (n/3+m/3)*2; ans+=(m%3==2)+(n%3==2); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3829 FarmCraft]]></title>
    <url>%2F2018%2F12%2F02%2Fother_oj%2FBZOJ3829%2F</url>
    <content type="text"><![CDATA[题目描述In a village called Byteville, there are houses connected with N-1 roads. For each pair of houses, there is a unique way to get from one to another. The houses are numbered from 1 to . The house no. 1 belongs to the village administrator Byteasar. As part of enabling modern technologies for rural areas framework, computers have been delivered to Byteasar’s house. Every house is to be supplied with a computer, and it is Byteasar’s task to distribute them. The citizens of Byteville have already agreed to play the most recent version of FarmCraft (the game) as soon as they have their computers. Byteasar has loaded all the computers on his pickup truck and is about to set out to deliver the goods. He has just the right amount of gasoline to drive each road twice. In each house, Byteasar leaves one computer, and immediately continues on his route. In each house, as soon as house dwellers get their computer, they turn it on and install FarmCraft. The time it takes to install and set up the game very much depends on one’s tech savviness, which is fortunately known for each household. After he delivers all the computers, Byteasar will come back to his house and install the game on his computer. The travel time along each road linking two houses is exactly 1 minute, and (due to citizens’ eagerness to play) the time to unload a computer is negligible. Help Byteasar in determining a delivery order that allows all Byteville’s citizens (including Byteasar) to start playing together as soon as possible. In other words, find an order that minimizes the time when everyone has FarmCraft installed. 输入The first line of the standard input contains a single integer N(2&lt;=N&lt;=5 00 000) that gives the number of houses in Byteville. The second line contains N integers C1,C2…Cn(1&lt;=Ci&lt;=10^9), separated by single spaces; Ci is the installation time (in minutes) for the dwellers of house no. i. The next N-1 lines specify the roads linking the houses. Each such line contains two positive integers a and b(1&lt;=a&lt;b&lt;=N) , separated by a single space. These indicate that there is a direct road between the houses no. a and b. 输出The first and only line of the standard output should contain a single integer: the (minimum) number of minutes after which all citizens will be able to play FarmCraft together. 样例输入6 1 8 9 6 3 2 1 3 2 3 3 4 4 5 4 6 样例输出11 HitsExplanation: Byteasar should deliver the computers to the houses in the following order: 3, 2, 4, 5, 6, and 1. The game will be installed after 11, 10, 10, 10, 8, and 9 minutes respectively, in the house number order. Thus everyone can play after 11 minutes. If Byteasar delivered the game in the following order: 3, 4, 5, 6, 2, and 1, then the game would be installed after: 11, 16, 10, 8, 6, and 7 minutes respectively. Hence, everyone could play only after 16 minutes. 题意zuhiul是镇长，住在1号房子，镇里的房子构成了一颗树，现在zuhiul要给镇里其他房子里的小姐姐送电脑，每经过一条路径，zuhiul都要花掉一分钟(才不是为了看小姐姐)。但是zuhiul只负责送不负责装，每个小姐姐的脑子都比较奇怪，有些装的快，有些装的慢，最后zuhiul会返回自己的家给自己装电脑，然后他就可以和小姐姐视频了，但是必须要等所有的小姐姐都装好了才行，现在问你zuhiul最早什么时候可以和所有的小姐姐视频。 分析显然是树上DP，我们考虑定义DP状态，则有 f[i]表示以 i 为根的子树里，花费总时间的最大值是多少 我们定义son_num表示这个节点对应子树的节点数量 然后我们考虑转移，我们首先考虑怎么搞两个子节点的时候，然后进行推广。 不妨假设这两个字节点分别是a和b，然后可以得到先遍历a再遍历b的最大时长为 max(f[a]+1,f[b]+son_num[a]*2+1) 同理，先遍历b的最大时常为max(f[b]+1,f[a]+son_num[b]*2+1) 所以如果有max(f[a]+1,f[b]+son_num[a]2+1)&lt;max(f[b]+1,f[a]+son_num[b]2+1) 因为f[a]+son_num[b]2+1&gt;f[a]+1并且f[b]+son_num[a]2+1&gt;f[b]+1 所以只需要得到 f[b]+son_num[a]2&lt;f[a]+son_num[b]2 也即 f[b]-son_num[b]2&lt;f[a]-son_num[a]2 同样，对于多个节点来说，我们同样只要对每个子节点按照 f[son]-son_num[son]*2降序排序，然后从前往后贪心选就行了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 7e5+10;struct p&#123; long long t,son_num;&#125; peo[maxm];long long len;vector&lt;int&gt;mat[maxm];long long f[maxm];int ind[maxm];bool cmp(int a,int b)&#123; return f[a]-peo[a].son_num*2&gt;f[b]-peo[b].son_num*2;&#125;void dfs(int a,int pre)&#123; peo[a].son_num = 1; if(a!=1) f[a] = peo[a].t; for(int i:mat[a])&#123; if(i==pre) continue; dfs(i,a); &#125; ind[0] = 0; for(int i:mat[a])&#123; if(i==pre) continue; ind[++ind[0]] = i; peo[a].son_num+=peo[i].son_num; &#125; sort(ind+1,ind+ind[0]+1,cmp); long long now = 0; for(int i = 1;i&amp;lt;=ind[0];i++)&#123; f[a] = max(f[a],f[ind[i]]+now+1); now+=peo[ind[i]].son_num*2; &#125;&#125;void solve()&#123; printf("%lld\n",max(f[1],len*2-2+peo[1].t));&#125;int main()&#123; scanf("%lld",&amp;len); for(int i = 1;i&amp;lt;=len;i++) scanf("%lld",&amp;peo[i].t); for(int i = 1,a,b;i&amp;lt;len;i++) &#123; scanf("%d%d",&amp;a,&amp;b); mat[a].push_back(b); mat[b].push_back(a); &#125; dfs(1,0); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191218]]></title>
    <url>%2F1019%2F12%2F18%2Fdiary%2F2019%2F12%2F20191218%2F</url>
    <content type="text"><![CDATA[这几天实在是太懒了。好多事都一拖再拖。实在不能拖了才去做。看了一下这两个月的日记更是少之又少，惭愧惭愧。 这几天基本都是上午不起床，中午午睡一会，或者直接开始看操作系统，然后看的差不多就玩一会手机和魔方，然后晚上开始打factorio。有点上瘾，第一次对一个游戏这么上瘾。感觉有点沉迷了，在昨天的时候卸载了。 重点说说factorio。毕竟好几周天天打到凌晨三四点。。。。 游戏模式很简单，目标也很简单：发射火箭。 期间最重要的几个问题是： 活下去（你是有敌人的）！ 不断的发展科技（科技是第一生产力）！ 合理的规划（前期一个垃圾的设计，会让你后期非常恼火，而且修改困难）！ 及时重构（在玩通关两次之前，很多时候你对完整的体系不清楚，不可能避免所有的糟糕设计，甚至前期会有很多临时方案，及时重构，保证系统的健壮性）！ 时刻进步（不要等待，有些时候我会陷入一种前面科技研究完了，下一种瓶子还没出来的尴尬局面。很多时候就是因为我在看着传送带发呆。。。。）。 其实我仔细思考了从中大体了解到的这几点，我发现这真的是很适合一个程序员或者一个设计师玩的游戏。从中真的能明白不少东西，最重要的一点是：很杀时间（不知不觉就天亮了）。 还有就是回家发现了我小学时候的玩具：魔方。已经忘得差不多了，用了大概两天时间捡了回来，还是挺有意思的。看操作系统视频的时候，没事就玩玩魔方。（然后就是回放。。。。完全不能同时干两件事）。 最后就是昨天去看了个电影，被光抓走的人，哇，真的挺好看的，强烈建议各种人去看。故事讲的挺好的。 (PS: 对了，我紫了，哈哈哈]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019半年总结(20190306-20191128)]]></title>
    <url>%2F1019%2F11%2F28%2Fdiary%2F2019%2F11%2F20191128%2F</url>
    <content type="text"><![CDATA[从今年三月六号到现在，一直在头条这边实习，已经过去大半年了，是时候写个总结了。 真的很感激头条给的这个机会，能在这里学到很多东西，真的感觉自己成长了很多。明白了自己不会的东西还有很多，还需要继续努力。了解了做工程和打比赛不一样的地方。 本来有很多话想说的，突然噎住了。。。。上次想了很多，突然忘了。。。。。 我觉得对我个人而言影响最大的就是老大说的一句话：任何时候，你都需要具备一种快速解决问题的能力，无论你最后是不是写代码的人，这种能力都会让你在各行各界混得开。这句话说的真的挺对的，我其实在相当长的时间里面陷入了一个误区，那就是我这辈子都干程序员了，然后我一直觉得代码写的好看就够了。现在回想起来这个想法其实很蠢的。更多的时候，公司需要的不仅仅是你打代码的能力，更多的是一种解决问题的素质。而公司里面的问题，可不仅仅包括写代码。 还有就是时机。其实我理解一个约成熟的公司，机会应该是越多，但是反而很多展示自我的机会都被我自己浪费了。我在相当长的一段时间里面，都认为我和公司是雇佣关系，所以我来这边只是为了帮公司解决问题的，所以很多时候解决问题就完事了，很多东西都没有深入思考，或者说没有自己的见解。后来渐渐明白一件事，我和公司更多的应该是一种合作关系，我在帮公司做事的同时，我其实可以接触到更多的东西，不仅对公司的收益是个正增长，而且对个人成长也是有很大帮助的。可惜的是，等我想明白这一点的时候，就基本到了我离开的时候了。 最后就是环境，头条这边给我的感觉是一种很舒心的感觉。虽然偶尔也会加班。但是这种东西就和打比赛一样一样的，也分两种，一种是你宁可加班也要搞好，而且搞好了很有成就感，另外一种就是宁愿给我钱我也不相干的，至少头条这边大多数时候加班时间是前者。虽然偶尔会觉得累，但是开心的时候会更多。 接下来一部分用来回顾我的大学。 其实我一直觉得，除了高考没考好这件事没法改变以外，我从出生到现在，一直觉得自己是一个很幸运的人，或者说是幸运的部分大于了我努力的部分。初中及其以前的事就不说了，从高中开始讲起。 因为家里管的比较严的缘故，所以高中时候基本没怎么出去浪，更多的时候都是老老实实的好好学习。（整个高中没去过一次网吧的98年学生，你敢信？）该好好玩的时候，高一高二好好玩了，用功还行，努力真说不上。该努力的时候我也真的是玩命了。想想自己每天晚上刷题到12点，挺感激那时候的自己。 高考没考好其实是一件塞翁失马的事。现在回头看，可能好的成分居多：来到了一个看得过去的学校，认识了一群和蔼可亲的老师，有一宿舍的哥们，取得了以前不敢想的比赛成绩，有几个关系贼好的队友。就差一个如花似玉的对象和一个所向披靡的学习成绩，哇，简直人赢有没有？ 这辈子为数不多的做过几件我觉得不算蠢的事就是，我会提前想自己要的是什么，然后做好规划，初中知道自己读理，高二知道自己学计算机，大一知道自己要打比赛，大三知道自己要找工作。其实也说不上规划，中间有一大部分的阴差阳错。所以很多时候还挺怕自己活在梦里。。。。 大学正儿八经在学校的时间可能也就三年不到，如果在上课才算在上大学的话，可能一年半？惭愧惭愧，读书实在是不行，怪我怪我。 不太清楚别人对努力的定义是什么，个人理解是：主动把事情推向更好的方向。所以高一高二按部就班的上课写作业考试，真的说不上努力，更多的是在被推着走，或者说过的浑浑噩噩更多一些。仔细回想一下，努力的时候应该只能算高三和大二，这两段时光真的是努力了。也只有那个时候我是真的清楚自己在做什么，为了什么而做，意义何在，结果如何。 如果说大学有什么遗憾的话，最大的遗憾应该是没有找个对象，其次就是没有好好打比赛，然后就是没有好好学习，剩下的，我觉得没有遗憾了。个人来说，我脾气其实很不好，到了大学收敛了很多，更多的时候是自己一个人生闷气，所以自问没有得罪别人，如果有，那我也不认！哈哈哈哈哈哈。 未来努力的方向：看更多的书吧，大学看的书有点少了，或者说很多东西没有钻透，书到用时方恨少啊。 就这样，下棋下棋！]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191024]]></title>
    <url>%2F1019%2F10%2F24%2Fdiary%2F2019%2F10%2F20191024%2F</url>
    <content type="text"><![CDATA[这段时间要拍类似于毕业证上的照片这种东西，然后我就去拍了一下，在高曝光下，看到了自己气色好差。这段时间熬夜实在太多了。感觉以后要早点休息了。然后这几天每天保证12点之前睡觉。可能是之前熬夜太多了，这段时间虽然睡的很足，但是精神头还是不是很好。感觉以后真的需要好好休息了。 然后学校的学习还是遥遥无期，这周末应该要抽空写一下学校的作业了。也该看看操作系统的书了。水平还是太菜了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191017]]></title>
    <url>%2F1019%2F10%2F17%2Fdiary%2F2019%2F10%2F20191017%2F</url>
    <content type="text"><![CDATA[明天提测，所以今天在赶进度，因为我的原因，导致几个问题的跟进都堆积在同组其他人手中。导致我们进度失衡。 反思了一下，大部分是我的原因，有时候不怎么想跟进问题，觉得和他人沟通是一件很麻烦的事。此外，技术问题也很关键，不能第一时间反应出问题的根源在哪。主要是之前做的那一套没有吃透。后面也没有花时间补。导致自己没有很快速的处理问题。 难受是有一点的，后面继续努力吧。 还有就是关于最后一门必修课的事，还是有点慌，老师不是很好说话，所以可能答辩完就想回学校养老了。看情况，这几周的面试都不是很理想，可以说基本都凉了。老老实实搬砖吧。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191011]]></title>
    <url>%2F1019%2F10%2F11%2Fdiary%2F2019%2F10%2F20191011%2F</url>
    <content type="text"><![CDATA[今天又被老大喷了，老大的意思是我效率太低了。其实这几天我认为是没有很重要的事，所以这几天我基本都是在摸鱼，大部分时间是在刷题，虽然mentor看到了，但是可能是他觉得这段时间确实没事，所以没管我，因为刚好三个方向，他们三个正式工吧。然后就没我啥事了。于是我也就心安理得的再摸鱼。结果被老大看出来了。自然是被喷了。 然后我仔细思考了一下，我为什么会变成这样，然后我突然醒悟过来，我的想法还停留在我有无限的可能的层面，因为我一直觉得我未来不一定属于这里，我可能会去任何一家公司，所以这段时间，尤其是在十一假期期间，什么事都没有放在心上。现在回想一下，其实挺愚蠢的。我忽略了一个重要的事，那就是我做事的时候，我也在成长。忽略了这个细节，导致我潜意识里始终觉得，做事是亏了。愚蠢至极！ 接下来一段时间要安安心心做事了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191010]]></title>
    <url>%2F1019%2F10%2F10%2Fdiary%2F2019%2F10%2F20191010%2F</url>
    <content type="text"><![CDATA[今天水到cf_784E，看到了熟悉的数字电路处理。但是最后还是模拟过的。想电路图化简来着，然而立马发现，自己啥都不会了。突然一种悲哀油然而生。自己的大学到底学了一坨什么东西？很多课程已经忘的干干净净了，这是自己想要的吗？]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191010]]></title>
    <url>%2F1019%2F10%2F10%2Fdiary%2F2019%2F10%2F20191031%2F</url>
    <content type="text"><![CDATA[今天有点难受，一个需求因为一些奇奇怪怪的原因没有达到预期效果。同事没有直接喷我，但是我从他的表情中读出了不情愿。 感觉是时候离开了，我的精力被分散的太厉害了，而我的能力并不足以支撑我去想太多东西。 或者说这一两个月以来，我过的并不开心，但是谁又会在意你开不开心呢？或许我该考虑一下，自己是否真的适合这份工作呢？我感觉现在的自己陷入了一个恶性循环。太多的时候过的浑浑噩噩了。每天非但没有进步，反而状态在不断的下滑。我也不知道自己是否真的哪一天就绷不住了。 其实我也知道，一直是我自己的问题导致现在很多，嗯，应该说是不是很好的结果。 很多时候是因为我似乎总是在逃避什么？大多数的时候给自己的借口是：我不会。我可能一直没想清楚一个问题是：别人不会给你太多时间让你成长。他们会不断的push你，让你做这做那。我又不好意思拒绝，以至于很多时候甚至压得我踹不过气。我从前一直劝解自己，没事，熬过这段就好了。但是有时候又感觉像是压死骆驼的最后一根稻草，不知道自己是不是某一天突然就绷不住了。 有时候又感觉生活挺难的。以前自己没有感受到生活的压力的时候还没什么，现在自己才一个人就有点顶不住了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190926]]></title>
    <url>%2F1019%2F09%2F26%2Fdiary%2F2019%2F09%2F20190926%2F</url>
    <content type="text"><![CDATA[今天突然想到一个问题，我这段时间是否太过于被动了，很多时候都是自我被动成长。居然已经很久都没有主动学习了。 很多时候都想着准备好了再上，但是仔细回想一下，很多时候都不会让你准备好了再上。所以更多的时候，我们应该做的是，努力准备，一旦发生，快速解决。 首先就是积累，没有积累，没有成长。其次是，认可自己，觉得自己可以。最后就是努力做好，不要想当然的觉得可行就ok。 对自己要求高一点，不要60分就满足，甚至50分就满足，追求更优解。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190925]]></title>
    <url>%2F1019%2F09%2F25%2Fdiary%2F2019%2F09%2F20190925%2F</url>
    <content type="text"><![CDATA[今天仔细想了想，我是否有我想象中的那么努力。很多时候，被别人吹捧了一下，难免会飘飘然。这个时候，很难冷静的思考一下。今天突然意识到这个问题。 我是否有自己想想的那么努力呢？显然没有，我仔细回忆了大学这几年，说实话，幸运的程度高于努力。 似乎自从高考失利之后，一直都比较幸运。幸运的参加了ACM，幸运的取得了比较理想的成绩，幸运的面试过了几家公司，幸运的遇到了一个比较好的老大。 然后看看自己的努力？ 算不上多努力罢了。因为自己懒，所以比赛也没有好好打。因为懒，每天空闲时间也没有学习，反而用来打游戏。因为懒，很多事情都被自己搁浅了。这种程度的努力，真的不值一提。 以后要更加努力啊。游戏小说什么的，还是适可而止吧。现在也一个人一个房间了，接下来的目标：早睡早起。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190923]]></title>
    <url>%2F1019%2F09%2F23%2Fdiary%2F2019%2F09%2F20190923%2F</url>
    <content type="text"><![CDATA[昨天被子送算是到了，算是彻底安顿下来了。 过生日，饭都没吃，还加班到晚上，第二天照常上班。 我居然会觉得很正常，可能这就是长大的代价？ 答辩的时间遥遥无期，想点的技能点太多，但是自己又太懒。这几天的状态不是很好，希望接下来的双月能调整好状态。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190919]]></title>
    <url>%2F1019%2F09%2F19%2Fdiary%2F2019%2F09%2F20190919%2F</url>
    <content type="text"><![CDATA[今天生日啊！ 昨天交完房租，今天就灰溜溜的来上班了。生活所迫，没办法啊。 刚来就需求评审。有点累。 找奇哥借了5000。手上有20000，但是房租18000，交完房租我基本就是个废人了。 这就是成年人的世界吗？手上小几万，一天就没了。啊，我死了。 加油加油！]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190915]]></title>
    <url>%2F1019%2F09%2F15%2Fdiary%2F2019%2F09%2F20190915%2F</url>
    <content type="text"><![CDATA[今天老妈非拉着我去给我买了两条裤子，我们在路上闲聊的时候，她又扯到我的小姐姐身上了，然后她就疯狂问我关于她的各种问题。我就各种说不知道。 我是真的不知道，她家里干什么的，她家里有几个孩子，她家里有一年挣多少，她家里父母文化水平是多少。 我是真的不知道，也不关心，我现在依然觉得，我喜欢的是她，不是吗？我自认为自己的水平还算不错，无论她家里什么情况，我都欣然接受，因为我觉得你要和她在一起的时候，无论她家里怎么样，你都至少可以改变自己不是吗？ 嗯，就酱紫，要和小姐姐谈一场甜甜的恋爱。]]></content>
      <tags>
        <tag>HER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190909]]></title>
    <url>%2F1019%2F09%2F09%2Fdiary%2F2019%2F09%2F20190909%2F</url>
    <content type="text"><![CDATA[这几天请假回学校玩了几天，感到很是堕落，每天的事都是今天拖明天，明天拖后天，感觉拖延症都上来了。不像以前的我。说实话这几天都不知道该干啥。当时回来之前给自己的定位是养老，但是真的养老的时候反而感觉到不适应。难道是因为真的不适合养老吗? 很多时候明明很慌，但是为什么又不想努力呢?到底说还是自己太懒了。然后实在是不想等下去了。明天处理完这边的事就准备回家了。 回家其实也没有太多事。不知道干啥。 其实我主要想说的是，我这段时间突然有点迷茫，不知道自己到底想要的是什么，很多时候我都会说想搞很多很多钱，但是我后来渐渐发现，我要的可能不是这个，因为这种想法往往禁不起后一步 推敲，比如进一步问我:搞了很多钱，然后呢?说实话我答不上来。我真的不知道自己想要的到底是什么。 我一直觉得，一个人又仔细想要的东西是一件很美好的事，他能让一个人有奋斗的目标，但是一旦你发现这个目标没有意义的时候，你就非常难受了。你会突然发现一切的努力没有了意义。 不说了，后天走的话，明天事还挺多的，先打游戏去了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190905]]></title>
    <url>%2F1019%2F09%2F05%2Fdiary%2F2019%2F09%2F20190905%2F</url>
    <content type="text"><![CDATA[从3.6到今天刚好半年时间，不知不觉已经来北京半年了，感慨挺多的。期间发生了很多事，下面一一总结。 首先就是比赛的事，虽然是上上个月就已经决定了，但是还是很多想说的。我之前一直觉得不回学校打比赛是因为父母的缘故，后来仔细想了想，可能不止于此吧。可能更多的是自己的想法。不怪队友，真的是自己没有了当年的激情了，或许真像水先生说的那样，自己已经被温水煮青蛙了。可能几年后再来回想这件事可能会有不同的看法吧。 其次就是自己在头条这边的成长，说句公道话，我没去过别的地方，所以暂时不做对比，单说头条。首先对于一个刚毕业或者说还没毕业的人来说，头条还算是比较肝的了，但是我始终觉得这种肝对于一个没有任何工程能力的人来说是非常有意义的。其次，头条这边的环境真的很好，尤其给我最深的一点体会就是，大家都是想把某个东西做好，且不说每个人出力多少，但是所有人朝着一个方向迈进，总会有所成就不是吗？最后就是：头条的伙食真的很好，我已经胖了10斤了。俨然是一个看起来20多，实际上刚20的中年油腻大叔，哈哈哈哈。 然后就是自己的脾气，真的是好了很多，可能是因为工程能力太菜了的缘故，很多时候都是陈述自己的意见，那种强迫奇哥接受我的想法的日子，一去不复返了。哈哈哈哈哈。对不起奇哥。 还有就是挺感谢头条给我的六个月，尤其是老大。初入职的第一个老大真的是非常重要了。我眼里一个完美老大的样子，不是他技术有多牛（当然，我老大也很厉害），而是他现在的样子，是否是你追求的样子，或者说，你想成为他那样的人吗？如果你“不幸”遇到了，那真的是能爽一辈子的事。真不巧，我老大就是这样。哈哈哈哈。 然后就是见了相见的小姐姐。还是挺爽的。没怎么出门玩过的人，可能稍显木讷，感觉被嫌弃了。orz。 还有108天，等着呗，很快的。 还没答辩就溜了，实在是太累了，没时间写ppt 啊啊啊。 昨天收拾东西的时候第一次感受到了六个月时间有多长，大概就是，刚来北京的时候我穿的是羽绒服，厚外套。昨天收拾东西的时候，我一个大男人的衣服硬生生有两个箱子+一书包？]]></content>
      <tags>
        <tag>个人总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190901]]></title>
    <url>%2F1019%2F09%2F01%2Fdiary%2F2019%2F09%2F20190901%2F</url>
    <content type="text"><![CDATA[这几周实在是忙昏了头，周报都没写，实在是有点懒了。 这几周有点迷茫了，很多东西都想学，但是还是一如既往的懒，好多东西都是想学的，但是因为懒，还用了没有时间作为了借口，实在是不应该啊。 然后这周四可能要回学校养老了，实在是需要时间来整理整理自己的东西了。 每天忙忙忙也不是个事。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190825]]></title>
    <url>%2F1019%2F08%2F25%2Fdiary%2F2019%2F08%2F20190825%2F</url>
    <content type="text"><![CDATA[今天看到一个人，虽然我从来没有和他说过话，但是我对他很反感，我突然间想到一件事，为什么我会对一个从来没有交流过的人，没有任何交集的人感到反感？ 仔细的思考了一下，大概原因是我是通过了我比较信任的人的描述，而产生了我脑补自己对他印象的现象。无论这个印象是否真实，但是一旦产生几乎不可更改。导致了我后来对他产生的反感。 想明白这一点之后，突然就感觉到可怕。人言可畏啊，很多时候都不用众口铄金，很多时候听了一个人的意见，就足以产生很大的印象。感觉以后很多事情需要有更多自己的思考。记录于此，引以为戒。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190816]]></title>
    <url>%2F1019%2F08%2F16%2Fdiary%2F2019%2F08%2F20190816%2F</url>
    <content type="text"><![CDATA[昨天晚上和大哥哥打了个电话，他和我说了很多事，我突然明白一个道理，一个人的无心之失真的会对一个人造成那么大的影响。 都是自己当时太年轻了，居然会犯那么傻屌的错误，还渐渐的遗忘了，实在是罪过。最近找个时间弥补一下吧。不然真的会后悔一辈子吧。 明确未来要做的三件事 1.等待 2.事业 3.毕业 加油吧，努力成长，静待怒放。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190812]]></title>
    <url>%2F1019%2F08%2F12%2Fdiary%2F2019%2F08%2F20190812%2F</url>
    <content type="text"><![CDATA[今天在清理历史消息的时候，突然发现一个事，那就是HR，5月份的时候拉了个群，意思是这个群里都是有实力转正的，但是没有我，直到7月底的时候才把我拉进去，这样我就不开心了。 不是，我就不懂了，这个意思是我不行呗？反正很不爽，突然就不想干活了，真的想一走了之，管他什么呢。 然后就直接找老大聊了一下，老大说他知道这个事，和我解释说，老大们没有对齐标准导致的。 好吧，我勉强能接受这个解释，但是说实话，我真的略失望。反正这样做搞的人很不爽。不开心，不开心，不开心！ 就这样吧。 可能有一天，等我攒够了失望就会离开。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190807]]></title>
    <url>%2F1019%2F08%2F07%2Fdiary%2F2019%2F08%2F20190807%2F</url>
    <content type="text"><![CDATA[听说今天是七夕，所以说也是我老爸的生日。 公司这边实在是太忙了，暂时没有时间想对象的事。刚刚给爸爸打了个电话，谁知道他已经睡了。确实有点晚了。 然后就是这个月底如果转正顺利的话，可能就要考虑回家一趟了。确实是好久没有回家了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190803]]></title>
    <url>%2F1019%2F08%2F03%2Fdiary%2F2019%2F08%2F20190803%2F</url>
    <content type="text"><![CDATA[今天刚看完了《哪吒之魔童降世》，颇有感触。 实际上最打动我的那一幕就是哪吒白化前的那一幕，哪吒的父亲，愿意和哪吒换命。一个二十好几的大老爷们真的是在影院无声的哭了。真的是挺打动我的。突然间就想到了我的父亲。我仔细的思索了一番，如果换做是我的父亲，他会怎么做，我感觉他同样不会犹豫。当时想到这个就哭了出来。为人父母真的是挺不容易的。 和哪吒一样，我从小一直很蠢。可能认识我的人都不会想到我曾经语文+数学都考不到60分。但是我小时候就是这个尿性。因为父母都是老师，同事的孩子也和我一般大。所以经常拿来做比较，因为父母很敬业，所以没有时间管教我，导致我小时候一直很差，不难想到父母因为我而失望过多少次。但是他们有放弃过我吗？没有，他们总是很有耐心的教育我。 再后来，我开始渐渐明白人事。也就是那个叛逆的年纪，开始不懂事。总是有意无意的气父母，着实很不该。现在回想起来，真的是很后悔当初的所作所为。可能在父母眼里，我永远是一个长不大的孩子吧。 想起来上周给家里打了个电话，我能明显感觉到母亲接到电话时那种欣喜的语气，反而让我感觉甚为羞愧。实在是想象不到，父母这个角色忍受了多少不该忍受的东西。那种不求回报的给予，真的很让人感到敬佩。 其实我一直以来都算不上听话，想起来上次我母亲用个软件，弄了半天还是没有弄好，给我整着急了，我就很不耐烦了。后来有一天我母亲和我说，让我对她有点耐心，毕竟他们渐渐的老了，不像以前那样灵光了。就像他们小时候对我一样，多给他们一些耐心。听完这个之后，我就很难受了。我一直觉得我已经长大很多了，但是实际上呢？还是动不动就惹父母生气，实在是罪过。 再回想一下，我是真的对父母的耐心很差了，他们也确实老了，而我呢？正处于上升期，很多时候都不太愿意听父母的建议。很多时候希望自己能拿主意，甚至很抵触父母的建议。但是大多数时候会发现他们的建议是对的，他们毕竟经历的比我们多多了。但是还是碍于面子，自己做决定了，现在回想一下还是真傻。在父母面前是最不用面子的。他们何曾求过我有一天能大富大贵呢？他们无非就是祈祷我能多回家看看罢了。然而这个愿望我在后面不知道还有多少日子的日子里，还能圆他们几次愿望呢？ 上次回家还是过年吧。总说自己忙忙忙，但是自己是真的忙吗？每天还有一个小时的时间用来打游戏，哪能算得上真忙呢？无非就是觉得他们很烦罢了吧？现在想想着实不该啊。为什么总是有这种幼稚、无聊的想法呢？ 不早了，先睡了。明天给家里打个电话吧。就这样，晚安。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190714]]></title>
    <url>%2F1019%2F07%2F14%2Fdiary%2F2019%2F07%2F20190714%2F</url>
    <content type="text"><![CDATA[昨天晚上给家里打了个电话，说了关于回学校继续比赛的事，实在是没想到家里人的反应会那么大，母亲的意思是，坚决反对我回学校打比赛。导致我昨天晚上想了很久关于是否回学校的事。 然后我回想了一下当时我们三个人讨论的事情，毫无疑问，我是主张不回去打比赛的，那么为什么让我动摇了呢？是因为他们两个都要回去吗？我一向自诩为遵从内心，自由生长。为何此刻就一直摇摆不定？ 我现在无非担心的两件事就是：我没有回去，他们打金了；我回去了，结果和去年一样。 毫无疑问，我其实更担心后者。 昨天问了一下奇哥，关于金牌和sp的把握，分别是75%和80%，其实在我心里分别是50%,60%，说真的，我不知道从那一刻开始，对很多东西不抱有希望了，很多时候都没有当初入学的那种激情了。正是这种激情的缺失，导致我一度不想回学校打比赛。奇哥的意思是，为什么不去尝试更多可能？可能我回学校发现那种激情又回来了？我对这种想法持怀疑态度。我感觉还是过早接触了不该接触的东西，导致我现在心思已经完全不在这上面了。就像淌过的时间之水，一去不返了。 然后奇哥说，如果我不回去，他还是有可能会去打比赛。我仔细思考了一下母亲说的，我是学校最厉害的人吗？虽然我一度这么觉得，但是结果是显然的——我不是。那么在三个人六个月没训练的情况下，他们完全足够和任何人进行磨合，而且结果不会太差。如此说来，我不回去其实没有我想的那么愧疚。哎，这糟心事。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190702]]></title>
    <url>%2F1019%2F07%2F02%2Fdiary%2F2019%2F07%2F20190702%2F</url>
    <content type="text"><![CDATA[今天上午已知在忙学校的事，真的被学校的事折磨死了，带我们小学期的老师感觉还不好说话。 我就不懂了，为什么每次好不容易被工作搞的有一点激情了，紧接着就被学校的破事消耗殆尽，甚至搞的身心俱疲。 学校那些死板的规定，天知道是哪一天定下来的，这么长时间没有被修改过了，恐怕已经被无数人诟病了，为什么就不能修改一下呢？我至今任不明白，学校到底是在培养什么样的人？从前的我一直以为是对社会有用的人，后来想想恐怕不是。为什么社会都承认的人，在学校还因为一些傻屌规定频频受阻？教育的病态性已经不容多说了，一直很好奇这种涉及到国家未来的事会一拖再拖？现在还提不出一个有效的方案？算了，无力吐槽了，毕竟这么多年来，都是我这样无病呻吟，没有权力导致碌碌无为的人，毕业了之后就没精力去改变什么了，说到底我也是作恶者罢了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190626]]></title>
    <url>%2F1019%2F06%2F26%2Fdiary%2F2019%2F06%2F20190626%2F</url>
    <content type="text"><![CDATA[今天早上5.30就起了，好久都没有起这么早过了。 除了周五的最后一个考试，这学期就算是结束了。 这两天因为天天在学校玩，所以有很多时间想一些自己的事。这里索性总结一下吧。 首先就是大学的日子，仔细想想，自己的大学貌似从大二毕业就已经死掉了。或者说从大一下半学期就已经死掉了。已经记不清自己逃了多少课，每次考试都是划水划过去的。大三上逃的课比上的都多。大三下直接就出来工作了。整个大学除了舍友和少数几个朋友，其他人真的只是点头之交。这其实和我刚入大学的想法还是很不一样的。曾经的我不是没有想过做一个学霸，但是出于种种原因，渐渐放弃了这个想法，不是天资不够，实在是努力不够，或者说努力的方向不一样。当时还是太喜欢打比赛了。说到底还是太想证明自己了。回头想了想，当时应该是因为高考成绩太差了，所以对成绩失望了，想找到一个方向，告诉自己我还行，不是那么差，所以找了一条人迹罕至的路。现在回头想想，没有后悔和失落，也没有欣喜和狂欢，只有默默的努力和玩乐。直到后来在这条路上渐行渐远的时候，我已经开始迷失了。其实大三上还是太颓废了，很多该学的东西都没有学好。现在就是各种踩坑啊啊啊啊。 还有就是工作的事，今天得知比我晚来的实习生要走了，问了一下，他的想法是在这边学不到什么东西，而且时间实在是太紧了，让他抽不出时间来学习。这个问题其实我上个月就已经意识到了，然后找15级几个学长问了下，他们的意见是，大部分互联网公司都一个逼样，所以不用太过忧愁，毕竟是没有去过其他公司，所以暂时不知道具体现象是什么样。暂时就先留在这里吧，转正再说。 然后就是考研的问题，现在时间上已经不足6个月了，我算是彻底放弃了，这个时间太不凑巧了，时间卡的太不好了，很多事都需要在这六个月里面完成，所以显然是来不及了。而且当时想考医学研究生显然是一时心血来潮，毕竟想和小姐姐再玩两年。后来想想还是算了，惹人厌烦。总给人一种逼宫的感觉，而且自己水平实在是不太够，虽然舍友每天都奶我，说我考必中，其实我知道无非是大家平时开玩笑之类的话罢了。随着年龄的增大，越来越不会嫉妒别人，因为我清楚的知道，每个人的努力和回报成正比，没有人能随随便便成功。虽然我不否认有些天才，但是没有不用付出的天才，不是吗？ 最后就是比赛了。因为和工作冲突的缘故，公司这边说是要8月底才能转正。但是如果9月才开始训练的话，三个月可能还是来不及，很可能还是和去年一个水平，那么我觉得浪费这三个月时间没有任何意义了。暂时还是没想好，看队友想法吧。我的话，自我感觉已经没有了大一刷题的激情了，还是老了，再也刷不动夜了，很多问题甚至是不想深究了，甚至是轻易的放过去了，导致大二结束到现在反而是水平跌落很多了。 算了不说了，继续搬砖去了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190626]]></title>
    <url>%2F1019%2F06%2F26%2Fdiary%2F2019%2F08%2F20190802%2F</url>
    <content type="text"><![CDATA[今天终于是周五了，这周不知道为什么感觉特别的累，真的是由身到心的累。没有原因的那种。而且我感觉这周应该是7月最摸鱼的一周了，但是还是感觉很忙的感觉。 然后昨天写了一下周报，看了一下我写的东西，看起来是挺多的，但是仔细想想其实都是杂货，没什么技术含量，主要就是各方沟通吧。 其实应该在每个技术宅的眼里，默默写完自己的代码，然后run的很健壮，应该是一件很爽的事吧。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[就怕我感动了自己，却没有感动你]]></title>
    <url>%2F1019%2F05%2F01%2Fstory%2F</url>
    <content type="text"><![CDATA[我爱你，像蚁溃洪堤，一泻千里。 2019052019050120190501 09:00 AM update今天开始我想记录下和她的所有故事。 20190501 06:15 PM update今天终于见到了心仪的小姐姐了，然后在天津逛了一大圈，刚下高铁，吃了个饭，然后逛了会街，然后就去听相声，然后逛了逛他们学校，在图书馆坐了一会就这样，哈哈哈哈哈哈哈，巨开心 20190501 11:52 PM update下午的时候和她一起去吃了个饭。然后我回宾馆把东西放下后就拉着她各种溜达，但是感觉她兴致不高。可能是她要考研的缘故。确实，感觉拉着一个想考研的人也挺罪恶的。但是我是真的很开心，哇，真的是只要想到和她一起，真的是压马路都巨开心^_^ 2019050220190502 00:31 AM update君子爱玉如将帅熬鹰，我不急，对你我有无限的耐心。 20190502 09:56 AM update看来你昨天是真的累了，以至于你现在才醒，我倒是挺担心的，7点半就醒了，然后给你发消息没回，就知道你是累着了。哎，心疼。准备去找你的，被你拒绝了。非说你来找我，也行吧。 有时候我还挺惶恐的，万一就是南柯一梦就尴尬了，不过我现在是真的开心呀呀呀呀呀呀。 20190502 11:26 PM update晚上约你吃晚饭，然后顺其自然的表白了？说实话是准备留到明天说的，但是一不小心漏嘴了，天真以为会挺顺利的。自认为还是不错的？但是好像有点出乎意料？巨难受？ 2019050320190503 00:42 AM update还是没想明白到底是哪个环节出问题了？而且我都明说了不逼你？我可以等234天啊啊啊啊啊啊啊啊啊啊，难受！ 20190503 10:04 AM update混进了你们学校，然后又混进了你们图书馆，哈哈哈哈，当时门卫看了我一眼我都有一种做贼的感觉，真刺激。坐在图书馆写下这一段文字，还是略难受？反正还没缓过来？其实吧，你之前拒绝我的时候我都安慰自己，我还不够优秀啊，我要更优秀一点，所以我之前一直很怂啊，这段时间才敢和你说话，但是好像啊，你还是这样啊，说明啊，我还得努力啊，冲鸭。 20190503 10:26 AM update还记得昨天去失恋博物展，记得当时我两感受都相同，别人的故事始终是别人的故事，打动不了自己，现在想来就是这种感受，一直都是我的一厢情愿，还奢望你的回应，说到底还是自己感动了自己，却没有感动你。 20190503 06:52 PM update你去上厕所去了，我偷偷码一点。 每每想到你连一点妄想都不给我就巨难受，看着你画了一下午的画，你认真画画的样子真的很美。但是我还是不知道你到底是啥意思，还是单纯的难过。 20190503 09:08 PM update09:05开的高铁，我们8:55还没看到车站，我估计是赶不上了，当时我们两一起在大马路上跑，我真的有一种私奔的感觉。当时过安检的时候，我真的好难受，感觉自己像失去了你一样，但是都没有得到过何谈失去呢？ 我当时就想啊，如果我还能赶上车，那就是老天真的不帮我了，如果赶不上我就赖上你了，但是好死不活晚点了？真的是气哭了。看来还是我心急了，贼老天都不帮我了，所以爱情这东西啊，还得时间沉淀，所以啊，我不急啊，所以啊，我可以等啊，所以啊，我唯一怕的就是你不见了啊。 就这样吧，再见了。 2019050420190504 00:54 AM update估计你睡了，写好的东西最后还是发给你了，也不管你看不看了，反正肺腑之言，不吐不快。 果然你没睡着，和你说了两句，看你没兴趣我就溜了。 20190504 1:37 AM update看了你是真的了，今天就不等了，毕竟我又不是你的谁，劳累你三天了，本来就挺过意不去的，就这样也好，是你说的，好歹还能保存美好的回忆不是？ 让你填志愿和考完研和我说一声，不知道你会不会说，232天，会有多少变数呢？谁都不知道，我现在唯一能做的就是更努力吧。 20190504 01:00 PM update队友看我实在是太难受了，拉着我去打球了，打了一个小时，我实在是不想动了。就拉着他回公司了，码下这一段了，你猜我想开需要多久？估计你不敢和我打赌了？ 20190504 05:44 PM update我现在突然挺后悔当时没有定三晚上酒店，那样的话，我们至少还能多待一起一天不是吗？虽然可能没那么开心，但是至少还能看到你不是吗？我现在真的是啥都不想干了。 20190504 10:45 PM update我现在挺想和你打个赌的，你猜232天能否冲淡我对你的想法呢？我赌不会。如果真的淡了，我也不知道该说好还是不好，ok，我现在就数日子等我赢，刚刚给你发了日报，没有别的意思，只是希望你每天能整理整理，希望你好，（可能也有不甘心作祟？），不知道啦，我也很茫然的好伐。 2019050520190505 10:24 AM update劝自己暂时放下，安心搬砖，好好学习。唯一能让我安慰的就是我们组另外一个人表白也被拒绝了，但是我还是很难受，我果然是个loser，连同组的人都和我一样惨，哭了。 20190505 12:13 AM updateemmmm,前几天，天天中午吃饭很早，以至于我现在饿了，但是还有半个小时才吃饭，饿得不行。哇，我还想和你一起吃饭。231天，我要是约饭，你不来，打你呦。 20190505 12:57 AM update刚刚和老大他们聊了一下，他们的意思都是劝我放弃，说我还年轻，不值得，同样的人还会遇到很多，但是我目前还不这样想，有时间确实需要好好整理一下，并不知道自己到底想要的是什么，这不像我，我一直以为自己想要的东西很明确，但是这件事上，确实还有疑惑的地方。让我想到了以前看到的一句话： “无论是朋友，工作还是恋爱，如果你感到与对方特别契合，沟通愉悦甚至时时让你灵光乍现，你知道这说明什么吗？ 99%的可能是你遇到了阅历智商情商都在你之上的人，而且对方因为什么目的在向下兼容而已，只要TA愿意，TA可以和每个跟你一样级别的人，打到这种心有灵犀， 剩下的1%就是你遇到了SOULMATE。” 我并不知道我遇到的到底是什么，按照你前几天的意思是：我对你了解太多了，所以你的意思是我是你的99%？可能吧，可能只有我觉得我们是那1%，我一直以为我们不需要言语的交流是默契，现在看来可能不是？可能只是大家见的多了，就明白了，懂得察言观色？我并不知道，但是我很习惯这种感觉。 他们都说，人这个东西啊，很奇怪，可能你现在看到的人，喜欢的人，愿意放弃一切为了的人，可能过几年再看就不过如此了。我不知道，但是我现在确实很放不下。我一直觉得，这种人，可能十年都遇不到一个，放弃太难了。我想过几次，到底是为啥，你会拒绝，我暂时的理解是，我还不够优秀，所以我还要努力。他们说，等你变的优秀了，你就会明白，什么才是你想要的人。说真的，我不懂，不知道谁说的是对的。所以我选择让时间筛选，没有什么是时间搞不定的。231天后，一切都会有答案，如果你真的讨厌我，我就离开了，就当做是一场年少无知的梦。 20190505 04:47 PM update他们说让我忙起来，忙起来就不会想你了，但是我现在好闲啊，也不想忙起来，今天有比赛，但是已经没心情打了，怪只怪自己太年轻了，以前居然会觉得比赛比你有意思。老大说，错过了就是错过了，有些时候不能强求，我不知道，不知道该怎么做，不敢强求。 20190505 09:36 PM update开发的东西很快就做完了，所以今天一直很闲，然后复习的事也就随便搞了搞，反正也不怎么想搞学习了，然后和队友商量了一下考研的事，他们建议不要冲动读医，说是时间可能耽误不起，不太清楚，感觉涉及到他们的利益问题了，所以谁都说不清楚。然后下午到现在都在杂七杂八的看，配了配博客，看了看latex，看了看vim，学了学haskell，反而是感觉啥都没干，其实我还挺怕这种感觉的，挺怕时间真的将我们冲淡了，很奇怪的是，我今天很平静，异常平静，没有难受也没有开心，我不知道这是不是变淡的原因，反正时间真的在一点点冲淡吧，然后后天有考试，索性把明天的假也给请了，明天好好休息一下，有些东西也确实需要理一理。 emmmm，但是说自己对医学感兴趣是骗你的，是因为我对你感兴趣罢了，但是我确实是真的耐着性子读了一半的卫生统计学，无论是简单还是难，我都耐着性子读了。在你拒绝我两次之后，那本书就放在角落接灰了。确实提不起兴趣读下去。偶尔想想自己目的性其实也很强的，emmmm，可能是功利性很强，没有用的事情就不做了。暂时还不清楚，可能等着这三周考完试之后会重新捡起来接着读？然后整理整理笔记？然后假装很早之前整理的，然后发给你？然后试图感动你？呵呵，渣男！反正现在暂时是这么想的吧。妈呀，从来没想过为了哄一个女孩子开心，我居然这么有心机，太恐怖了。 哎，反正这两天想的挺多的，暂时也不知道自己在想啥，很多时候都是没想明白搞得错，反正以后三思而行吧，也不敢太打扰你了，日报今天还是决定接着发，发21天就溜了，能对你造成多少好的坏的影响我也不知道，我也不敢说这一套在你这是否是对的，只求心安罢了。 2019050620190506 10:44 AM update今天虽然请假了，还是来公司玩了会，刚喝了口水，现在开始码这段文字。 这几天睡眠质量特别不好，应该是从5.1晚上开始的，可能是担心你身体状态，我应该和你说过，当时第二天我六点就行了，怎么也睡不着，也不敢给你发消息，怕你还在休息，我以为只是这个原因，现在看来不是，已经三天没见你了，但是还是基本六点多就醒了，然后也不怎么睡得着，因为队友还在睡觉也不敢起床，偶尔躺在床上会背背单词，偶尔也会想想你，偶尔也不知道自己在干啥。 五点钟的票回学校，暂时还没定下来啥时候走，我应该和你说过，我不想赶路，所以一般会有预留，地铁大概是一个小时，所以我打算提前两个小时走，就算走错了，好歹还有挽回的余地。 哎，其实一个人赶路还挺无聊的，还是两个人在一起比较好玩，旅途寂寞鸭。昨天给你发日报了，你还是没回我，可能是把我拉黑了？不知道，没有别的意思，只是想让你养成一个（我也不知道是好是坏的）习惯罢了。别太敏感啊。 20190506 03:53 PM update现在闲下来了，就等高铁了，然后就想了想之前几天发生的事，其实我还是觉得挺玄学的，首先就是失恋博物展的那个球，说好都是脱单呢，怎么就咱两是单身了，不过说的也对，12.23才考完研，今年是不指望脱单了。 还有就是单车那个事，都10点四十了，还有四十分钟的路程，显然是赶不回去的啊，怎们回事啊，居然还能遇到各种单车，还有就是我为啥骑车那么慢，你真的不知道？怎么可能是因为累了，还不是不像你回学校吗。这样好歹有一晚上的时间，哪怕是纯聊聊天也行啊，你咋回事啊，看不出来？哇，就两三分钟就进不去了，你可真的赶啊，话说我还真不知道你是不懂还是装不懂，可能二者兼有，不清楚啊。但是我宁愿是前者吧。 230天，我离你又进了一步，但是你退后了多少呢？ 20190506 10:05 PM update马上就要到学校了，想到了当时去你们学校的时候，当时在你们图书馆歇息的时候，你应该是真的困了，都怪我当时不知道关心，让你受累了。现在想想当时怎么着也得让你休息休息啊。真的是迂腐之极。哇，不行了，想起的细节越多，越觉得自己是真的蠢。 今天一天都在赶路，所以整个人的状态不是很好。而且也不太喜欢这种放松的感觉，但是还是不想学习。话说现在心态真的是变了好多了，今天我队友还在劝我放弃，我不知道，可能还是当局者迷的缘故，但是还是没和你说，今天还是照旧把日报发给你了，今天是第三天，还剩18天，然后就应该不会给你发消息了，让你安心考研了，考完研有的是时间不是吗？ 2019050720190507 10:35 AM update229天了，今天突然有一种报复心理，我一定要让你后悔。 突然想到当时和你一起听相声的时候那个哥说了一句“我对于这种人，没有羡慕没有嫉妒，只有恨”，哈哈哈，说实话，这就是传说中的由爱生恨吗？反正我现在挺难受的，突然也想让你难受一下，哈哈哈，开个玩笑。 最后悔莫过于因为年少无能而放下。我拼命成长不过是为了你回眸一笑。他们说等你以后长大了会遇到不一样的人，不一样的景，而我只想记住每一个不一样的你。 2019050820190508 10:38 AM update228天。 昨天晚上的时候，你终于是回复我了，说是怕我考试有影响，这件事怎么说呢，你要是早点回复我的话，我可能还会开心一点。但是还是挺开心的，好歹回复我了。 昨天晚上聊了一下，应该再不会打扰你了，然后以后真有啥想说的，就更新到这里了，确实不该打扰你的，扰菇凉良久，菇凉莫怪啊。 昨天你和我说，哎，算了不评价，怎么说呢，大家都在慢慢成长吧。 不过有句话你说的还是挺对的，等待会让东西变质，或许应该换句话说：时间会让东西变质。没有什么可以敌得过时间。我深知我也不行，但是我觉得200+天还是不难的吧。 还有就是你说的对，拒绝就应该拒绝到底，你做的很好，但是我还是很难过，毕竟当一个人真正拒绝你的帮助的时候就是真的想和你断了吧。至少没有钓着你的心思，或许我应该开心？ 后来仔细思考了这段时间的经历，感觉确实有些自作多情了，很多时候都是自己一厢情愿罢了。 emmmm，大概就是这样了，可能真的是告一段落了，也不会找你聊天了，大家都松口气，如果真的是有缘，再见吧。 当我码下这段文字，无悲无喜，甚至有一种完成任务的感觉，轻松？算不上吧。只是觉得暂时放下了一些东西，可以安心前行了。 可能也和我老大说的对，他说我纯粹是大学时候没干什么，然后大学快结束了想干点什么，我不知道，当然也可能是自己飘了，觉得世界尽在掌握中，所以开始有恃无恐了。还好，你让我明白，自己还有很多的努力方向，还是不够优秀啊。所以继续努力吧。 现在也不敢随便立flag了，但是还是想说一下，如果你真的准备二战的话，我就准备考研了，和你一起，哪怕你不理我，我也要强求一把。当然如果你真的考上了的话，我也要准备跳槽了，反正能近一点就近一点吧。真的是怕了。 20190508 12:55 PM update刚刚吃饭聊了一下，反正我感觉我还好啊，没有你说的那种腼腆的感觉，可能很多时候在想事情所以没怎么说话，或者说是很多话不太好意思说，或者是感觉说出来不好，可能你觉得我在欲言又止？或者说是“腼腆”。不太清楚，哇，第一天我可是嗓子都说哑了，你居然会觉得我腼腆。不过说真的，刚见到你的一瞬间真的是有好多话想说但是真的是，虽有千万肺腑之言，却又无语凌噎。emmmm，刚见到你的时候是在瓷房子门口，当时还挺想抱你一下的，但是当时咱们前面有一个围栏，不知道你注意了没有，然后就放弃了。哎，还是太怂了。 昨天你给我发消息之后真的是好晚才睡着，本来12点钟就放下手机啦，硬是拉着舍友聊天，聊我和你，硬拉这聊到了一点半。哎，回想这几天发生的事，还是有些地方没有做好。还是有很多事挺后悔的，用我队友的话来说就是我太怂了。很多时候都过于胆怯。 我脑子里突然蹦出一个词来——自卑，其实仔细回想一下，很多时候我大概都是自卑心作祟。你也说了，你觉得我很优秀，其实我一直不这么觉得，反正每次觉得自己还行的时候总能遇到一些吊人，然后看看他们的经历，然后就觉得自己还有很多地方需要努力。 还有就是你觉得我把你美化了，这个不好评价，自古有云：情人眼里出西施。我不知道是不是因为某些奇奇怪怪的原因导致的。所以暂不做评价。但是真的是觉得你是个挺好的菇凉啊，一直觉得你值得世间上最美好的东西。有时候，看着你皱眉头真的是还略有难受？反正感觉你要是真能无忧无虑的生活还是挺好的。这段时间你应该是为我烦了，我也就暂时不打扰你了，等你安心考完研吧。反正这个事不急，咱们还年轻，有大把时间可以挥霍。哈哈哈哈哈。 还有就是这段时间准备开始锻炼了，主要是当时第一天我们都走累了，我想了一下，要不要公主抱你，后来估计了一下自己的身体状态，还是觉得太虚了，所以这段时间准备好好锻炼一下。还有就是学习的事，这段时间我考试实在是太多了，工作时间也压得很紧，所以暂时不考虑接着读卫统了，先把考试糊弄过去再说，之前看过的一半也没有整理笔记，题目也是杂七杂八做了，没有系统的整理，还是准备从头开始读，然后顺便整理整理笔记，题目也暂时不做了。先读完再说。感觉东西不是很难，所以希望你不要着急，慢慢复习就行。现在时间虽说不多了，但是也不用太着急，估计你这几天都没有在12点之前睡过觉，还是要早些歇息为好。 对了，你画的那幅画，我暂时还没有挂起来，因为房间里的那幅画是竖的，你画的是横的，不太好弄，所以准备抽时间去买个钉子，重新钉一下，然后再挂起来，不过你也别担心会弄坏了，我保存的老好了。偶尔学习累了会看看那幅画，你画的真好看，当然，你也好看。 还有就是那天我真的没有占你便宜啊，我说的都是心里话，你不是也没反驳吗？我就当你默许了。反正等你考完研我就非要缠着你，和你一起准备复试。至于我考研？暂时还没定，等省赛结束之后再说吧。看省赛情况，其实吧，我还挺想省赛打的不太好的，这样就能安心学习了。感觉比赛真的已经没有了当年的激情了。 还有就是舍友昨天晚上和我聊了关于感情会随着时间的延长而降低。他说如果你真是我对象，可能两个月我就没有了现在的感觉了。我不知道，但是你看你，就做的很好啊，直接拒绝了我，让我有时间去思考和解释这件事，等我想的差不多了，咱们就在一起了？ 说到底还是得抽时间想一想这件事，下周就省赛了，省赛结束应该会有时间思考这个问题，就这样。 20190508 06:22 PM update今天活干完了，现在算是比较闲了，不知道干啥了。 所以就过来bb两句。这两天的状态不是很好，一部分是舟车劳顿的缘故，另外一部分原因就是突然有了迷茫的感觉：突然不知道了自己真正想要的是什么。是工作？是考研？是恋爱？我不知道，一直以来都很讨厌这种感觉，不知道自己想要什么可能是一种病态的迷茫，也很容易变成空洞的人。其实我还挺羡慕你的目的性的，能知道自己想要什么真的是一种很好的状态。它会至少让你有个目标，然后剩下要做的就很简单了，细化目标，完成目标。 好像说这些在这里不合适，说一点和你有关的。 你说我很多时候能一眼看穿你，emmm，这件事怎么说呢，我的解释是，咱两有天然的默契，这种默契与生俱来，不用培养，不用磨合。我最爱的就是这种状态。我一直以为这种情况是天作之合，很少有人能这样默契吧？这辈子能遇到一个真的很不容易，或许没了这份默契就不那么喜欢你了？我不知道，但是我是真的喜欢这种默契，你也知道，我情商很低，说明咱两都没耍心眼，所以这种与生俱来的默契难道不值得被珍惜吗？反正我是不打算就这么错过了。他们说这种默契，一个人一辈子会遇到很多，我不信，真的不信。反正这一次，我一定要抓住。 20190508 7:24 PM update他们说的其实挺对的，人啊一旦忙起来什么都忘了，所以当时他们劝我忙起来就好了，这几天确实渐渐忙起来了。但是偶尔还是做事做到一半被打断，然后就神游太虚了。。。当然也可能是还不够忙。就是偶尔闲下来连个聊天的人都没有，还是挺难受的，之前还能和你聊聊天，现在都不敢给你发消息了。就这样吧。真有啥想说的，我就写这里了。 其实我一直都没想好 自己到底为啥要写这个东西，或者说写这个东西的目的是什么，虽然不怎么花时间，一天大概也就半小时，但是确实不明白写这个的目的是啥，写给50年后的自己看？那也太矫情了。还是写给228天后的你看？那也太无耻了。暂时没想好，只是单纯的觉得，能遇见你还是一件挺幸运的事，挺值得怀恋和回忆的事，所以就这样记录下来了，就算以后真的不能在一起了，想到以前喜欢过这么可爱一个菇凉，也是一件随时回忆起来都能让人开心的事吧？ 20190508 11:30 PM update还好当时没有公主抱你，突然感觉自己好虚啊，不行了，接下来一段时间准备好好锻炼一下了，等下一次见面给你一个惊喜，到时候抱你没跑。 2019050920190509 09:19 AM update今天早起了，背了会单词，然后就来公司学习了，复习时间就剩下今天和明天了。 早上的时候看到公交车让了一个老人过马路，不禁想起了我从天津回来的时候，当时晚上11点多了，我其实还挺累的，当时我后面是一对夫妻，带着两个孩子，两个孩子都睡着了，当时因为你拒绝我，我真的挺难受的，犹豫了一段时间还是让他们排在我前面，当时我想了好长时间，我都这么惨了，为啥还要对世界抱有善意？再后来，也就是上周考完试了，我回北京的时候，当时我身上还有一点现金，北京地铁现在好像还不让用微信？反正一个人在那干着急，想了想还是帮助了一下。我真的不清楚，为啥自己还要对陌生人抱有善意，真的是，自己过的就已经够惨了。后来想想还是为自己积福吧。所以我就想啊，我都以德报怨了，你总不能拒绝一个商量的小男孩吧。 今天北京天气很好，早上八点钟就已经有了太阳，真的很想出去逛逛，后来想想一个人还是挺无聊的。突然想到了当时给你打伞的日子，哈哈，我记得当时有一段时间，当时人流拥挤，你头都不回就往前冲，哇，当时还是太怂了，当时就应该拉住你，让你等等我的，后来好像因为打伞不及时被你吐槽了？哈哈，感觉你当时委屈的抱怨的时候的样子真的很可爱。哎，当时太直男了。 20190509 07:22 PM update今天和一个考研的神仙聊了一下，他说我不该五一的时候去找你玩的，他说这个时候大家都开始准备考研了，我这样做，非但没有帮你解决问题，反而是抛给你一个问题，让你困惑更多，尤其是我那些若有若无的帮助更是显得愚蠢至极。我其实觉得他说的挺有道理的，我并不知道考研原来压力那么大，我其实一直觉得考研和期末考试没啥区别，看来是我年轻了，很多时候都把事情想简单了，尤其是想得到你的回应这件事上，真的是蠢了。 仔细想了想确实不该这个时候去打扰你的，我还天真以为这对你不会有啥影响，今天才明白过来确实是副作用更大一下。但是我还是希望你压力不要那么大，还是要放轻松一些的，这段时间感觉你睡觉都挺晚的，一点钟还没睡觉，感觉这样还是对身体不太好，建议你每天早睡一点，毕竟晚睡了早上精神会不好，你们又都是需要背书的课，晚睡学习不如早起学习。 其实每天都有好多有意思的事情分享给你，但是实在是不忍心打扰你，很多东西又不太好记在这里，所以很多都写成了日记，等你有机会了，到时候咱两可以一起读读？ 还有就是，我其实不怎么想告诉别人咱两之间的事，没有别的意思，一是咱两毕竟还没成不是，还有就是很多人问起来给我一种听故事的感觉，不像是帮我分析问题的样子，让我有一种”我有这种经历，我是不是很厉害“的炫耀的感觉，这种感觉让我很反感，不知道为啥，这种感觉会让我觉得，这份感情变得不那么纯粹了，就像一个小孩在炫耀自己的经历一样，幼稚而无趣。 20190509 07:57 PM update刚刚吃完饭，突然想到一件事，突然就难过起来了。 就是五一期间的时候我们吃饭都特别早，所以刚回北京的时候我六点钟就饿了，但是这才六天过去了，我的作息又和公司一样了，可能这就是人们常说的时间会磨平一切？慢慢的，你给我造成的影响会渐渐的淡化？真的还是挺难受的，就像你留给我的东西，被别人抢走了一样。偏偏我还不知道能做什么才能留下你留给我的东西。真的很怕，有一天再听到你的名字，没有了现在这种心慌或者说是心动，反倒是无悲也无喜。 2019051020190510 08:45 AM update今天还是这个点起床了，昨天锻炼有点过猛了，现在浑身酸痛。。。。早上六点多醒了一次，一度怀疑自己手断了。现在就像被人揍了一顿一样。。。。 早上刚醒的时候仔细思考了一下，目前知道的人有：我两个现任队友，一个前队友，父母。果然是每个人注意点都是自己的利益问题，现队友给的意见是，别浪费时间，不值得。前队友给的意见比较中肯，让我想好，想好了就别放弃了。父母啥都没说，他们也没说啥，就是怕我想不开。同样的道理，我也听取了对自己有利的方向而忽视了现队友的意见。 还记得我和你说的吗？一旦有些东西涉及到了利益问题，就会少很多人情味，尤其是工作以后，感觉大家看待问题的方向都很不一样了。昨天前队友和我聊了一下，他的意思是，他从来没有为自己而活过，都是按照别人的想法来做事。然后我就发现，我还是挺幸福的，我一直以来都是啥开心做啥，暂时还没人约束过我。以前觉得读书有意思就好好读书，不怎么玩。大学觉得比赛有意思就不怎么学习，学习很差。真的想不到，自己有一天会需要顾及方方面面而变得畏畏缩缩的时候，该是何种可怕模样。 20190510 05:31 PM update突然发现，说我变腼腆了，好像不止你说过，虽然我很不想承认这一点，但是好像很多之前的同学都这么说，让我不得不思考这个问题，可能这几年过的过于漫长了，让我已经不记得我高中时候的样子了。或者说我高中的时候很膨胀？记不清了，可能是自己的感受，自己的成长，自己的变化反而自己不太了解吧。话说我高中的时候确实很膨胀，感觉一切都在自己手中。可能是大学时候认识了太多神仙了，就已经不敢过于高调了，很多时候反而是低调再低调。感觉自己还有很多不会的东西，所以一直在努力学习吧。 还有就是我把你画的画拍成了照片挂在公司内部聊天软件的头像上，他们都说挺好看的，那是，不看是谁画的。。。。其实准备换成qq或者微信头像的，想想还是算了，你能看到，不想影响你的心绪了。给你时间吧。 还有关于你说我说话风格很像山东人，这件事怎么说呢，感觉与其说是山东对我的影响很大，不如说是山东学长对我的影响很大，因为很多时候都是待在实验室，待在实验室的时间应该不少于在宿舍的时间，这还是算上睡觉的时间的情况下，所以我说话的风格应该是更偏向于实验室学长的风格。至于这点滴的潜移默化的变化，我还真感觉不出来。反正感觉自己一直都是这样。 20190510 10:02 PM update明天就溜了，要回学校打省赛了，希望好运吧，还记得去年的时候省赛冠军，当时老膨胀了，总感觉世界在我手上，没有我搞不定的事，后来就慢慢放弃了这个无知的想法。突然想到了我之前和老大说的一句话，有异曲同工之妙–”世间上任何问题都可以转化成数学问题”。直到你拒绝了我好多次，我才渐渐明白过来，很多东西并不是那么简单的问题，不是我能掌控的，也不能转换成数学问题，他没有固定的公式，更没有通用的解法。因人而定，因事而转。 嘿，说真的，我一直以为，我会悲伤好长时间，但是不知道为啥，我就这么快想开了，突然就不难过了？反正这几天还是挺开心的，偶尔搞搞问题，偶尔和组里人开开玩笑，但是偶尔沉寂下来的时候才会感到悲伤。这可能就是我喜欢晚上而非闹市的原因？“黑夜给了所有人黑色的眼睛，他们用来寻找光明，而我用来寻找你的美”。现在唯一感到遗憾的就是当时你画画的时候没有偷拍你。让我只能在回忆里寻找你。 226天，此去经年，应是良辰好景虚设。 2019051220190512 11:14 PM update今天是母亲节，刚打完省赛，刚到学校，估计老妈已经睡了，不敢打扰，就偷偷来更新一点。 今年省赛，果然还是没有打冠军，最后第五了，不行了，老了老了，精力不敌当年了。说到底还是缺少一点锐气，很多时候还是考虑太多，或者说是顾虑太多了。不过也从侧面说明了一件事，世界不是掌握在我手中，很多东西暂时还是不能掌控的。然后认真考虑了一下关于考研的事，这件事听的意见有点多了，反而自己没有搞清楚，然后你说想上中山大学医学院，然后了解了一下，感觉中山大学计算机学院还是挺强的，现在唯一的难点就是初试了，感觉只要初试过了，复试不是问题。大多数时候还是感觉自己很菜，但是好像是在一个不怎么激烈的范围里面，好像有点安逸了。温水煮青蛙，最坏莫过如此。说到底还是很多东西没有勇气舍弃罢了，工作也好，比赛也好，搞钱也好，很多东西让我迷醉了，尤其是在一个自我感觉良好的氛围里，感觉好多时候甚至不想努力了。还是很危险的。 感觉还是要安心下来正儿八经搞件事，这学期算是废了，肯定是要搞到正式offer的。然后就差不多到了暑假了，然后看情况暑假是回学校比赛还是安心准备考研了。主要是还没想清楚，自己读研到底是为了学知识，还是为了接近你？感觉这个事情还是需要想明白，不然很多时候感觉可能会努力错了方向。反正学习这种事来说，感觉还是欠缺很多，很多东西都没有系统的学好，现在想捡起来又感觉时间不太够，感觉还是自制力不够，是像我说你的一样：执行力不足。当时我和你说的是真的，没有人的执行力很强，执行力强的人都遇不到，说到底人还是一个很懒的动物。毕竟懒是第一生产力嘛。 224天，一念起，万水千山。 2019051320190513 07:54 PM update今天早晨起床，差点没反应过来，恍如隔世的感觉，真的有那种黄粱一梦的感觉，感觉一切都是假的，去北京市假的，去找你也是假的，只是做了一个很真实又很虚妄的梦。 其实大多数时候应该是，觉得自己实力还行，但是没有得到预期的结果的一种心有不甘吧。尤其是大家都是优秀的人，都觉得自己是掌控世界的一群人，如果真的违背预期的话，总会有点失落或者不甘心的感觉吧。只是这种期望长时间得不到满足的话，往往只有两种结果？对心爱之人的刻意美化或者恶意丑化？哇，不行了，感觉可以抽时间拜读一下弗洛伊德的巨作了，总感觉会受到启发。 总感觉这几天心太浮躁了，对事也好，对你也好。总感觉不够冷静和理智，容易冲动。不太清楚是不是这两周堆的事情太多的缘故。其实仔细想想，自己还挺自私的，很多事情自己都没有想清楚，然后就说了，总感觉是不吐不快，但是很多时候都是自己爽完了，然后就不管了，总感觉自己能收拾好自己处理的烂摊子，但是想想到现在都还是总用事情很多这种破借口，没有时间理清这件事。不知道是怕想清楚之后拿到了自己不想要的结果的不甘心，因此一直在逃避结果，还是自己真的很忙，所以找不到时间。可能前者居多？ 溜了溜了，这两天身心俱疲，不想多说了。就这样，希望远方的你遇事不急，早睡早起。 223天，世间有两苦，一是得不到之苦，二是钟情之苦。 2019051520190515 00:20 AM update已经是第二天了，晚上11点多的时候才陪舍友吃完饭。 昨天这个时候和我妈妈聊了一下，我妈妈对你还是挺满意的，我就和她说，你对别人菇凉满意没用啊，别人菇凉不中意你儿子啊。不过说真的，我妈妈好像真对你挺感兴趣的，你要不考虑一下今年过年和我一起回家？ 然后今天晚上准备给你电话的，然后尝试给你发了个消息，大不了你再拒绝我，我明天就以喝多了为借口呗。但是你好像直接没鸟我了。。。emmmmm，想说的话就被憋回去了。其实也没有啥大不了的事，就是这段时间很多问题没有想清楚，所以想问问你的意见，但是你好像不怎么给面子啊。不知道，估计以你的个性，明天可能也不会回我？其实有时候感觉你还是挺好的，至少没有掉着我啊。 然后我妈妈好像还是挺激动的，反正一直催我去撩你，说什么，有时间就关心关心人家，给人家尽可能的帮助啥的，反正给我的感觉就是，你要是来了，你就真是她闺女了，但是我是不是真儿子，那可不一定。然后我爸爸的话，不用考虑，我们家里人都挺好说话的，再说了，有我罩着你呢。不对，按照我妈妈这个态度，应该是你罩着我才对，哈哈哈哈哈。 突然想到我的耳机到了，但是明天才能用到，然后今天去网易云音乐上去看了一下，《空空如也》这首歌，不知不觉已经听了500多遍了，还是略恐怖的。人生寂寞如雪啊。 对了，今天不想学习主要是有一个比较奇怪的原因。从我读大学到现在，我一共有三件事让我可以奋不顾身，宁愿抛弃一切都要做，第一就是我想做一个特效爆炸的游戏，不好玩也无所谓。这个想法是大二的时候，真的是让我魂牵梦绕，让我想了好长时间，第二就是想去见你，那是来了北京之后的想法，让我很多时候都不能集中精力搞正事，直到五一，我和你说的都是真的，我是真的觉得一切都值得。无论是你想做什么，我都愿意陪着你。然后今天突然有了第三件事，我想来一次说走就走的旅行，今天看了一天地图，一直在想去哪去哪，但是具体的旅行地点还没定下来，不过抱歉的事是：这个计划没有你，本来想完之后说要不要计划加上你，后来想想太矫情了。这个计划没有你，我只想一个人看最美的景，当然如果那个时候你能在我身边的话，我会更开心。计划还没计划好，估计应该是12月份左右开始执行，应该是11月之前会规划好，到时候做两份计划吧，看你愿不愿意。 20190515 07:53 PM update上午就是纯赶路了。大概中午到宿舍，洗了个澡就去公司了。今天一整天都不是很舒服。 昨天晚上的时候，我和你说过了，我陪舍友吃饭了，当时喝了点酒，当然没醉，尝试着给你发了个消息，但是你没回复我，今天早上你说你是睡着了。其实吧，昨天没有啥别的意思，就是想问你点事，让你给个意见而已，但是你好像兴趣不高，所以就没打扰你了。其实就是想问问你，觉得我到底是考研好，还是找工作好，还是打比赛好，自己现在没什么主见，问了问老妈，好像也没改出啥建设性意见，所以准备问问你，但是你好像是睡了。就算了。估计你八成是想我读研，所以想问问你读研的话啥时候开始准备比较好，因为目前一段时间还是比较忙，暂时是没时间开始准备，舍友的意见是不急，暑假开始准备就行了，反正他们对我的信心比他们对自己的信心都足，不知道是为啥。 还有就是今天发工资了，准备换个手机了，但是还有点舍不得，微信暂时没有不同设备登录，聊天记录同步的功能（还是说我没找到？），所以换了手机之后可能聊天记录都没了？所以我今天翻完了我们所有的聊天记录，然后截图了，看今天晚上拷贝一下，感觉还是一个挺美好的回忆的。然后觉得比较过分的就是为啥聊天记录都是我一个人在发言呢？反正基本都是一片绿，然后见着一点白。哇，难受。可能是我手速比较快的缘故，感觉不见得，你好像挺不想和我分享每天发生了啥一样。我这个人就这样，闲不下来，反正只要是有趣的事都喜欢分享给你，但是你很多时候好像是不感兴趣，所以没怎么回复我，假装你是忙吧。也只能这样安慰自己了。 221天，万物皆有其时，耐心等待。 2019051620190516 10:00 PM update今天头疼了一天，应该还是没有休息好的缘故。 昨天开始渐渐开始给你发消息了，不然我是真的怕有一天把你忘了。说心里话，我不知道我到底是需要一个倾诉的对象还是对象。可能是前者居多？因为我很少主动开启一个话题，所以不怎么喜欢找人聊天，所以很多时候有些事都不知道找谁说，所以个人觉得还是更缺少一个倾诉的对象？不过我觉得现在的状态挺好的，每天和你分享一点或开心或难过的事，也不算太打扰你？但是还是和以前一样吧，都是我输出较多，你还是很少回我，但是我还是很开心啊啊啊啊啊，真的很怕你不理我了。 今天看了一下，如果你决定读研读中山的话，我就准备考虑华南理工了，感觉考上不是很难，而且看了一下知乎，都说华南理工的就业氛围很好，所以可以考虑读一下，然后我们组的一个人说，读中山啊，中山妹子多，可以给你压力，哈哈哈哈哈，不知道啊，问了一下舍友，他们说这两个学校的考试难度几乎相当，所以暂时还没决定，应该是今年暑假就开始准备了，暑假感觉可以回一波家，感觉还是更倾向于考研吧，暂时还是不知道队友之间的态度，感觉大概率会玩完，所以更倾向于读研。今天和组里人聊了一下搞钱的事，他们都说读研好，搞钱不急，而且前几年基本是搞不了多少钱，就算搞到钱了也存不下来，所以暂时不考虑这个，但是如果能转正的话，不是不可以考虑一波，但是看老大对我的态度，大概率不会成功，所以暂时更倾向于考研，但是还没定下来，这周六感觉可以考虑一下具体的想法。或者这周二考完试，下午的时候好好想想。 这周开始就继续锻炼了，对了，看了一下前两天你的体测报告，感觉很厉害啊，不行了，我也要好好锻炼了，话说5.1那段时间去玩的时候我脚上磨了一个泡，前两天才消下去，太虚了。还是缺乏锻炼了，还是因为怎么吃都不胖的缘故，这段时间就疯狂的偷懒，感觉最近越来越虚了。反正现在要好好锻炼了，怎么说也得公主抱吧，不能太虚了。下学期应该是回学校了，有时间锻炼，但是我健身教练的舍友好像要全身心考研了，感觉不会带我，到时候看情况是拉队友过去，还是自己锻炼，其实我觉得吧，做事这种东西，一个人做永远是最无聊的，虽然多个人效率不一定高，但是一定是不容易累的，老话怎么说来着？男女搭配，干活不累。说真的，五一那几天我是真的不累，3号的时候其实就是想故意气气你，我生气了，哈哈哈哈哈。你都看出来了还不哄哄我，难受，居然还让我去买水？居然想支开我，你也太坏了。 还有就是那天晚饭的时候，我一直叫你“小老弟”，你好像挺反感的，没有别的意思，只是觉得这个称呼很有意思而已，而且那个时候感觉叫你啥都不好啊。总不能继续叫你“小姐姐”吧？ 220天，既然不好意思说晚安，那就祝你晚不安，最好今夜有梦，梦里有我。 2019051720190517 10:30 AM update刚刚去水了一发日记，感觉还是挺惭愧的，日记是真的一天不落全都有，但是这个故事还断了几天，看了一下，大概是省赛少了，还有就是那天准备复习和陪舍友喝酒少了。现在日记被彻底拆成了三部分：工作日报，这个故事，生活琐事。等离职之后可能工作日报和生活琐事并一下，但是这个故事还是单独成为一个故事吧，以为觉得这个是真正值得回忆的事，而不是记流水账。 其实这两天仔细考虑了一下，你其实应该不是没有看懂暗示，而是假装没看懂暗示。更多的时候你应该是不想看懂，假装看不懂，然后就可以搪塞我?还是说你觉得我脸皮不够厚，不敢瞎说话？可能让你失算了，我最后还是捅开了，但是好像努力错了方向，最后搞得大家都不怎么愉快了。emmmm，其实我觉得这样还挺好的，至少比你看破不说破好一点，这样大家长痛不如短痛啊。我也没有一下乱七八糟的小心思，你也可以安心考研了。就这样独自安好了。 20190517 07:52 PM update不行了，今天晚上实在忍不住了，想和你商量一下关于明年的安排。emmm，用自己不知道未来的想法去寻求你的帮助应该不算过分吧。感觉还是不甘心在作祟。还是想挣扎一下？因为这两天实在是太忙了，所以今天想早点走了，因为明天就放假了。所以现在开始动心思准备出去玩了。明天看情况出去逛逛。 这段时间渐渐忙起来了，主要是因为现在考试也告一段落，剩下的时间比较多，以前的时候有时间就摸鱼，现在不怎么想摸鱼了，一来是感谢老大的栽培，二来是想让自己忙一点，别天天去想一些乱七八糟的东西。你看，现在随着时间的推移，我对你忘得越来越多了不是？很多东西都想不起来了。还是说不想想起来？ 话说第一天的时候，当时逛瓷房子的时候我还是挺不开心的，这种时候难道不是应该两个人找一个幽静的咖啡厅，然后一起老朋友叙叙旧吗？说真的，当时逛的时候直接把我准备好的好多话憋回去了。。。。本来想找个地方聊会天的。。。。然后以为中午有机会，结果你也知道了，中午的时候不止两个人，说真的吃饭那个地方环境还挺好的，多适合说心里话啊。不过我当时想啊，我有的是时间不是吗？所以不急。结果不急不急就真的没机会急了。 219天，愿你贪吃不胖，愿你懒惰不丑。愿我的深情不被辜负，愿我的余生都有你陪。 2019051820190518 04:49 PM update昨天晚上给你打了个电话，咨询了一下关于下半年到底是考研，工作还是打比赛的问题。但是你好像兴致不高，其实吧，你要是明确给出一个意见，我一定会去做吧。我是真的不知道到底怎么选，不是故意找个由头和你打电话的。你最后好像也只是帮我干掉了一个选择：就是不要去工作。然后你好像是更倾向于比赛，其实你这样说我反而是更倾向于考研了。如果你中山大学定下来的话，我就可以着手准备考西南理工大学。然后就问了你一下中山定下来了没有，但是你好像还是在动摇，所以这件事就暂一搁浅了。 我还是那句话，感觉很多事情还是早早定下来比较好，我这段时间就因为思考各种利弊关系搞得我很焦虑，很多时候甚至不能安心思考了。但是我现在应该没有资格去给你出主意了，毕竟我自己都没有想好到底选什么，甚至去你那里问想法了。 今天又刷了一遍大鱼海棠，我以为我会有啥感同身受的感觉呢，结果还是那样，别人的故事毕竟是别人的故事吧。不过有句话还是挺打动我的： “生命是一场旅程。我们等了多少个轮回，才有机会去享受这一次旅程。短短的一生，我们最终都会失去，你不妨大胆一些，爱一个人，攀一座山，追一个梦。” 这种事怎么说呢，其实大多数人是没机会追寻自己的梦的，很多时候还是不得不屈服于现实不是吗？更多的时候是人力不可抗的因素，就像你现在不喜欢我一样，可能越努力越反感了？或许现在唯一能做的就是偶尔找你聊聊天，听听你最近一段时间的吐槽，给你出一两个狗头军师的意见。但是你好像不怎么有兴趣找我聊天，一般都是我主动的多。可能还是对我戒心比较大？ 218天，命里有时终须有，命里无时莫强求。 2019051920190519 09:33 PM update今天和你聊了一下关于晚睡的问题，其实一直以来都想说，你好像睡觉一直挺不规律的，我是真的觉得作息不规律对身体很不好，虽然我也没有每天早睡，但是基本都是12点之前睡觉了，太晚睡真的是对身体不好，不仅是休息不好的缘故，反正整个人的精力都不好了，一天都会没有精神。还有就是这个年龄段，尤其是在学校的日子，没有什么事是值得你为之熬夜的。至少我目前还没发现什么事是非要我晚上之前搞定的，第二天干就会出问题了？ 还有就是你说你在学校发现了一个地方写有你的名字，我居然没有吃醋鸭，只是觉得挺有趣的，因为有一个人暗恋着你，还不敢偷偷告诉你，还居然是舍友先发现的，这就太尴尬了，当然不排除有个男生写了告诉你舍友了。然后试探试探你的态度，但是我是真的觉得很有意思，反而没有吃醋的感觉，可能是对自己有足够的自信？当然还是挺羡慕你的，其实有一个人在背后默默祝福你的感觉真的挺好的。 然后你就开玩笑说下次去青岛给我写满，我是真的当真了，就像我说的，虽然下一次不知道是什么时候，但是只要有下一次，多久都值得不是吗？到时候你可别赖账啊，不写满不准你离开我了。 217天，我们都足够成熟，也足够理智，没有人愿意用自己的感情和青春去赌个不确定的未来。但因为那个人是你，所以我愿意。 2019052020190520 10:40 AM update今天出门的时候，阳光正好，微风不热，一切正如刚见你时候的样子，真的很美。我刚去的时候，我是真的有说不完的话想和你说，但是啊，你真的是没有怎么回应我，导致我阻塞了。所以啊，想念这种东西，还真不能是单向的，不然啊，就像负重前行，总该是会累的吧。 20190520 11:05 PM update明天考试，我还没开始复习，但是我还是更想和你说话，不想复习。 今天是520鸭，真的很想和你说话啊，但是又怕你戒心太重了，就没怎么和你说话，就是吐槽了一下今天网易云给我推荐了一堆情歌，评论全是别人的甜美爱情故事。你好像只是单纯的同情我，哇，这个时候不应该是咱们偷偷做一天情侣吗？你要是真的这样说，我说不定真的会把票退了不考试了，直接去找你玩，算了，还是自己想想就好了，别想多了。这段时间咋回事啊，天天做白日梦啊。不过真的想和你谈恋爱啊啊啊，哪怕一天也好啊。你想做什么都行，我都可以陪着你，想到只要可以静静看着你，就很开心了。 还有就是那天画画的时候，我不是觉得无聊了，而是我困了，那天睡的挺晚的，没睡好，但是又不好意思睡觉，早上又很早就醒了，然后睡不着，一直在想前一天晚饭的事，所以下午的时候很困了，真的不是无聊了。哇，我当时累的不行了，就想休息一下，但是还是想和你说话，结果你居然让我去买水。当时真的是被你蠢哭了。但是莫名觉得你还挺可爱的？这段时间没见你了，也没有理由找你要照片，所以更多的时间就去看那幅画，不管怎么说，也是你几个小时的战果啊。最后我还是没给他挂起来，我怕弄坏了，万一不小心刮花了我心都会碎的。 216天，深深的话要浅浅的说，长长的路要挥霍的走，大大的世界要率真的感受。 2019052220190522 10:48 AM update昨天和前天都找你聊了会天还挺满足的？今天好像是我妈生日？感觉今天该打个电话回去了。 214天，网易云里面的评论有999+，我也不敢打出你的名字。 2019052320190523 12:30 PM update今天突然听到了《好久不见》，感觉真的好久不见了，甚是想念，现在学校的事情算是终于搞定了，现在可以安心搞其他的事了。这段时间算是真正忙起来了，每天都是干不完的活。 对了，关于上次你说高考考完数学后我对你说了什么话，我是真的忘了，你说的对，只有自己会记得自己说过什么，我去问了李思慧一下，她也不记得了，看来这彻底成了你一个人的秘密了。我这几天都在努力的回忆，如果有这件事的话，我大概想起来了一部分，当时我们是在一中考试的？而非孟宗，然后我们都是从小学那个门口出来的，然后你是在那个上坡的时候哭了？然后我无非就是可能说了两种话：要么是嘲讽你了，要么是安慰你了，以我高中的尿性，应该是带了嘲讽的安慰，多半是会说：没事我考的比你还差，我都没哭，你怕啥啊？类似的话。因为我记得我语文考的更差，所以可能说了一句我作文都跑题了，你怂啥啊。应该就是类似的话吧。反正感觉顶多是用让你很不爽的话怼你了，让你暂时忘却了考的不好的悲痛？其实回头来看，你都比我考的好多了。 而且你看，当初我们拼命挣扎，痛的撕心裂肺的事现在看来还不是淡然了吗？你现在回忆起来还是有意思居多吧？反正我觉得吧，考试这种东西，努力了就好啊，别太心急。 然后就是这段时间考研的事了。我舍友这段时间又吵架了，反正我不在就闹腾起来了。其实在我看来九成九是因为考研的事，我才渐渐知道，考研的人压力是真的大，所以这段时间我都只敢和你分享有意思的事，看出你有心情不好的时候就安慰你一下。 还有就是关于你刷微博的事，你说你是喜欢做一个倾听者，实际上我觉得是因为你已经是个消费者，而懒得去做生产者，以至于很多时候你甚至不能好好的表达自己，但是没时间去改正，所以你现在都是喜欢听别人的故事。所以啊，我得配合你啊，我就老老实实给你说我发生了啥啊，至少这样我们两个人之间没那么无聊啊。 213天，这一生，我会遇到一切比你都好的，但我已经没有精力，不顾一切去再爱一次了。 2019052420190524 10:19 AM update今天早上奇哥和我说他失恋了，这次是真的，这让我不得不开始思考一个问题，我是不是恋爱绝缘体啊。为啥我周围的人都失恋了呢？巨难受。其实我想的更多的是他失恋的原因：他对象想要结婚了，但是他现在处于上升期，至少是两年之内不可能结婚的。说到底就是我给不了你想要的，所以不如就此别过了。当他说完这个事实的时候，我也跟着挺难受的，让我想起了我初恋，当时是同样的情况，我给不了她想要的，所以大家就此别过了。现在回头来看，只能说是挺可惜的。 其实，当时犹豫了很久才去见你是同样的问题，就是怕自己没有放弃一些东西的勇气，所以一直不敢见你，当我下定决心了之后，还是被你拒绝了，其实，无论是比赛还是考研还是找工作，我都拿得起，为你我也确信自己放得下，但是你都没有给我机会去证明这一点，还是有点难受的。他们说：这辈子最后悔的一件事就是，在错的时间遇上了对的人，但是却没有能力或者说没有勇气去抓住。我们应该就是这种情况，说到底我其实还是没有准备好吧。自认为自己掌控着一切，可以随便牺牲，在哪个方向都能做到很出色，但是实际上却不是这样，很多时候还是太怂了，很多东西不是说放下就能放下的。 我后来才渐渐明白，我身上承载的不仅有我的梦，还有很多人的期许。虽然说我做不到背叛全世界，但是我真的愿意去争取听从你的意见，所以大多数时候我还是挺想听听你的意见的，但是从上次就可以看出来，你不怎么想给我意见。其实我还挺倾向于考研的，但是队友失恋了，很可能就能安心打比赛了，所以又陷入了一个个不确定中。就这样了，上次说过了，这种问题得不到答案的时候，反复思索只会陷入焦虑。今天和队友聊一下，倒时候再决定吧。 20190524 04:51 PM update刚刚和你聊了一下，关于谈恋爱和结婚的事，我们好像持有一部分不同的观点，可能是我经历稍多一点的缘故吧。 不过让我真正感兴趣的事是你发给我的表情包，哇，真的想不到，你会用这种表情包，简直人设崩塌啊，是真的，哇，你可是小仙女啊，怎么能用哪种表情包呢？然后就奶了你一句，然后就赶紧跑了，哇，说真的，现在突然有了一种恋爱的感觉，彻底不想干活了，翻来覆去看了两三遍记录才平静下来。啧啧啧，不得了不得了。 20190524 05:24 PM update不过话说回来，恋爱这件事对于20出头的年轻人来说真的是一件很奢靡的事，但是对于女生来说是一件不得不考虑的事，现在回想起来还是挺残酷的。但是我还是没办法给你承诺不是吗？毕竟我自己对自己都没有多大的把握，谁知道未来会发生什么呢？可能真正让我着迷的是那一瞬间的欢乐？但是你知道这种欢乐是不能过一辈子的不是吗？我觉得如果不考虑清楚自己喜欢的到底是什么就草草的说喜欢，草草的给承诺会显得很可笑。 其实吧，让你和自己谈恋爱，何尝不是我自私了呢？何尝不是为了怕你有一天累了，却没有找到我，被别人乘虚而入了，所以让你自己一个人罢了。哇，太有心急了。但是我是真的想：当你想恋爱的时候，想到的是我。 212天，“归属感”是你强烈地想和他在一起。 “安全感”是你觉得他强烈地想和你在一起。 “幸福感”是彼此都强烈的想在一起而最终走在了一起。 我想要“幸福感”呢，对，和你！ 2019052620190526 10:15 PM update好吧，昨天看来是太累了，又没有更新。我还挺怕我现在的状态和写日记一样，马上就没有动力了，甚至是没有感觉了。你看，我现在开始都为自己找借口不写这个玩意了。你说再过两百天，我回头看这个东西实际上只更新了十来天，会不会嘲笑自己当初的想法呢？我不知道。 对了，在偷偷懒了好几天之后，我今天终于下定决心去健身了，但是我真的是太虚了，跑了大概五公里就不行了，啊啊啊啊，好难受啊，说好到时候见你的时候一定要公主抱你，感觉离目标还有好远啊啊啊啊。不行了，以后每周我要保证运动量了。 对了，我想起来了上周的时候，我舍友和我说，让我这段时间学一个技能，为了你学个技能，无论什么都好，最好是乐器什么之类的，说到时候表白的时候一定会用到，我想了想不是不可以整一个，到时候看一下，感觉可以安排一下，然后突然就想到了吉他，这段时间考虑整一个了，手机什么的去他妈，暂时没时间想了，然后，你不是说你学过一段时间放弃了吗？我感觉我学会了也可以教你啊，但是不知道时间成本如何，因为毕竟还是拿不出来整块的时间，尤其是拿不出正常时间的整块时间，毕竟我不能10点下班，11点洗完澡之后开始学，你说是吧？早上的话实在是太懒了，感觉后续可以利用一下。 还有就是，当初买耳机说是为了早上背单词，不吵舍友，结果后来就忘了，感觉还是自控力不够啊。而且这几个月接触的东西有点多了，感觉心有点杂了。还有就是上次说的端午节的事，当时的想法是端午节回一次家，就是湖北，但是看了一下路线，时间点都不是很好，然后票价也不是很便宜，所以暂时不考虑回家了，但是显然是不能找你玩了，所以暂时还不知道干啥。看情况约一下呗，然后现在在北京的四小只应该除了我都可能回家，所以暂时还没有安排那几天干啥。 从下周开始应该就是独立干活了，可能还要自己去和pm吵架，所以可能会更加焦头烂额，不知道会不会以此为借口不更新了。感觉这段时间工作还是挺煎熬的，每天都不知道自己干啥，反正只想搞一些自己感兴趣的东西。哎，必然是没有和你一起玩开心啊。 然后这两天回想了一下，好像当时和你一起出去玩的时候，你好像并不开心，还是说你在学校都是这个样子？不怎么爱笑？感觉都是我一个人在那里傻开心。哎，还是太矫情了，可能以后我看到这段会删掉吧，暂时先加个删除线。好了，没啥想说的了。就这样，晚安。 今天又听了一遍《风花雪月》，自己写了一段。 风是你的头发抚摸我的脸庞的痒，花是我初见你时惊为天人的笑靥，雪是我进不去的你洁白无瑕的心，月是不曾一起走过的世间的美景。 210天，风花雪月，就是我想和你谈个恋爱。 2019052720190527 05:30 PM update今天看到了一句话，我不知道说的对不对：当一个女孩拒绝一个男孩后，通常男孩会更加难以放弃，不为别的，只是单纯的不甘心。 嘿，别说，我感觉我还是不甘心作祟多一点。我是真的很喜欢你吗？是真的那种寻死觅活的喜欢吗？没有吧。所以说到底应该是不甘心作祟多一点喽。 209天，愿你有高跟鞋也有跑鞋，喝茶也喝酒。愿你有勇敢的朋友，牛逼的对手。愿你对过往的一切情深意重，但从不回头。愿你特别美丽，特别平静，特别凶狠，也特别温柔。 2019052820190528 10:04 AM update不行了，这几天实在是太忙了，忙的我甚至都没时间写日记了。 今天看到一句话，人难免天生有自怜的情绪。大部分人看似的努力，不过是愚蠢导致的。 觉得这句话说的挺对的，然后就仔细思考了一下，这段时间确实漂了。甚至都觉得自己还行了，可怕啊。 208天，我嫉妒你身边每一个无关紧要的人，能够轻而易举的见到我朝思暮想的你。 2019053020190530 06:56 PM update昨天让你把网易云ID发给我，但是你拒绝了。然后我就想到了，当分享歌曲的时候后缀有一个uid=xxxxxxxxxx，然后在好奇心之下我把这个后缀删掉了，但是还是能打开，而且是同一个网页，我瞬间就明白了，这个是userID，既然userID会暴露出来，那么显然是可以利用的，然后就用浏览器打开了个人网页，后缀上就是uid=xxxxxxxxxx，然后随便换了一个uid，果然能打开别人的个人主页。然后自然就是用打赌来刺激你让你分享一首歌给我喽。哈哈哈哈哈，我好坏啊。 开始的时候我还以为你不会吃我这一套，没想到你居然还真的分享了，哈哈哈哈，你居然还不信。你刚刚发我的时候我还在开会，当时真的是好久都没有感受过那种心砰砰砰跳的感觉了。哇，当时真的是激动的不行，会都不想开了，直接开始瞎搞了，然后就自然搜到了你的个人主页了。哈哈哈。哇，不行了，我现在还平静不了。真的是，好久都没这么爽过了，怎么说呢，就像小孩子耍赖皮拿到了自己心爱的玩具，这种感觉你知道吧。真的是好爽啊啊啊啊啊。 20190530 09:19 PM update我就猜准了你会来问我怎么几分钟搞出来你的账号的。本来想告诉你的，忍住了。然后就调侃你，让我端午节去找你玩，必然会被你拒绝啊，就是随便调侃一下。 突然想起来你上次提到，为啥我每次都是很了解你的样子，其实我想说的是，如果你想了解一个人，总是有各种各样的方式去了解他（她），你说是吧？无非就是把拿来想自己事情的时间拿来想另外一个人而已，然后站在一个旁观者的角度，总能看清楚很多事情不是吗？但是很多时候还是不够冷静，所以大多数时候都是猜错罢了。其实，哪存在一个人把一个人猜准这种情况呢？可不都是我想了解你，然后尝试去接触你罢了。如果对你不感兴趣的话 ，又怎么会去想了解你呢？ 哇，当你发给我“哼”的时候，真的是整个人都化了。哇，我都能想象到你假装生气的样子，真的是想当面哄你一下啊啊啊啊。算了算了，自己还是太怂了，如果真的下一次见到你的话，真的是不想分开了。一定要黏着你。哇，不行了，真的想坐最后一趟火车过去了，我查一下。 206天，嘻嘻，有没有觉得我敲级好？让我们一起牵手走完整个宇宙吧~~ 2019062019060820190608 05:37 PM update昨天你突然和我说了，高考结束的事，也就是考完数学的时候，我和你说的话，还是蛮意外的。emmmmm，说实话是无心之言，不知道对你造成成了何种影响。而且但是是真的没有别的意思，也不是习惯你想和你有什么关系之类的。只是单纯的询问。可能是觉得好看的小姐姐不能那么难过是吧。 其实当你昨天和我说完这件事的时候，我就有一种预感，你好像看到这篇算不上日记的东西？不太清楚是否是这样，可能就是一种单纯的直觉吧。就像上次。 197天，你是一场无关风月的红尘， 成全了我一厢情愿的认真。 2019072019071720190717 10:37 AM update昨天晚上做梦梦到你了，梦到你来找我玩，你不排斥我了，我们一起压马路，然后你说饿了，我们就去吃东西，开心到冒泡。点完餐，你在那安安静静的做着，我看着你，你问我“看啥”（傲娇脸）， 然后我就笑了。再后来，我去取餐，让你在这乖乖等我，等我回来的时候，看到一个小哥在搭讪你，我就很气，然后，然后，然后就和那个小哥打起来了。然后我就醒了。气死我了，都怪那个小哥，不然好歹我能看你吃碗面不是？ 2019102019102920191029 2:34 PM update表达爱意最好的时机是，三年前到现在的陪伴，其次是现在。 Her199808062050 另外一部分原因是，我想和你报考一个学校，在你考完的那个时候，能第一时间看到你。]]></content>
      <tags>
        <tag>story</tag>
      </tags>
  </entry>
</search>
