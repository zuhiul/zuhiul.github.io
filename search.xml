<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Project Euler 405 A rectangular tiling]]></title>
    <url>%2F2020%2F03%2F26%2FPE%2FPE405_todo%2FPE405%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 We wish to tile a rectangle whose length is twice its width.Let $T(0)$ be the tiling consisting of a single rectangle.For $n &gt; 0$, let $T(n)$ be obtained from $T(n-1)$ by replacing all tiles in the following manner: The following animation demonstrates the tilings $T(n)$ for $n$ from $0$ to $5$: Let $f(n)$ be the number of points where four tiles meet in $T(n)$.For example, $f(1) = 0$, $f(4) = 82$ and $f(10^9)$ mod $17^7 = 126897180$. Find $f(10^k)$ for $k = 10^{18}$, give your answer modulo $17^7$. 题意就和上面的动图一样，让你数出当 $n = 10^{10^{18}}$ 的时候，有多少个四岔点。 分析吐槽一句，这个题的数据范围有点大也有点小。因为大，所以第一时间就想到了欧拉降幂，这样数据范围就很小了。所以这题才40%难度。 比较容易想到的就是答案分为三部分。 一拆为四，那么显然有一部分答案为 $4*f(n-1)$. 然后就考虑四块之间的部分，首先是两个躺着的，不妨设答案为 $a(n)$ 最后就是左边，右边和中间的交叉点，不妨设答案为 $b(n)$ 所以答案就可以表示为 $f(n) = 4f(n-1) + a(n-1) + 4b(n-1) $ 。 如下图所示（以$n=3$为例）： 剩下的问题就是考虑怎么计算 $a(n)$ 和 $b(n)$ 。还是以上面的例子为例。我们有 所以我们有： $f(n) = 4f(n-1) + a(n-1) + 4b(n-1)$ $a(n) = a(n-1) + 2*a(n-2) + 2$ $b(n) = b(n-1) + 2*b(n-2) + 1$ 其中边界条件是 $a(1) = 0,\ \ a(2) = 2$ $b(1) = 0,\ \ b(2) = 1$ 于是可以转成快速幂的方式，如下： 至于题目中的数据范围，显然是需要欧拉降幂来搞。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 704 Factors of Two in Binomial Coefficients]]></title>
    <url>%2F2020%2F03%2F18%2FPE%2FPE704%2FPE704%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Define $g(n,m)$ to be the largest integer k such that $2^k$ divides $(_m^n)$. For example, $(_5^{12})=792=2^3⋅3^2⋅11$, hence $g(12,5)=3$. Then define $F(n)=max{g(n,m):0\leq m\leq n}$. $F(10)=3$ and $F(100)=6$. Let $S(N) = \sum_{n=1}^N F(n)$. You are given that $S(100)=389$ and $S(107)=203222840$. Find $S(10^{16})$. 题意定义 $g(n,m)$ 表示组合数 $C_n^m$ 唯一分解后，素因子 $2$ 的指数。 定义 $F(n)$ 为 $max{g(n,m):0\leq m\leq n}$ 定义 $S(n)$ 为 $\sum_{n=1}^N F(n)$ 求 $S(10^{16})$ 分析打个表可以很容易得到 $F(n)$ 对应的 $m$ 的关系为：$n+1-upperbit(n+1) = m$ 其中 $upperbit(x)$ 表示 $x$ 二进制下的最高位。 然后就是分块随便搞一搞就行了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const long long upper = 1e16;//const long long upper = 1e7;long long cal(long long a) &#123; // 1! * 2! * ... * a! 有多少个2&#123;&#123;&#123; long long ans = 0; long long buf = a; long long len = 1; while (a &gt;&gt; 1) &#123; a &gt;&gt;= 1; len &lt;&lt;= 1; long long x = buf - (len - 1); // 1..1 2..2 3..3 long long pre = x / len; ans += pre * (pre + 1) / 2 * len; if (x % len) &#123; ans += (pre + 1) * (x % len); &#125; &#125; return ans;&#125;/*&#125;&#125;&#125;*/long long cal2(long long a) &#123; // a! 有多少个2&#123;&#123;&#123; long long ans = 0; while (a) &#123; a &gt;&gt;= 1; ans += a; &#125; return ans;&#125;/*&#125;&#125;&#125;*/int main() &#123; long long n = 0; long long ans = cal(upper); long long base; for (base = 2; n + base &lt;= upper; base &lt;&lt;= 1) &#123; n += base; ans -= cal(base - 1); ans -= cal2(n - base + 1) * base; &#125; ans -= cal(upper - n - 1); ans -= cal2(n + 1) * (upper - n); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport "fmt"const ( upper = int64(10000 * 10000 * 10000 * 10000))func cal(a int64) int64 &#123; ans := int64(0) buf := int64(a) len := int64(1) for ; a/2 &gt; 0; &#123; a &gt;&gt;= 1 len &lt;&lt;= 1 x := buf - (len - 1) pre := x / len ans += pre * (pre + 1) / 2 * len ans += (pre + 1) * (x % len) &#125; return ans&#125;func cal2(a int64) int64 &#123; ans := int64(0) for ; a &gt; 0; &#123; a &gt;&gt;= 1 ans += a &#125; return ans&#125;func main() &#123; n := int64(0) ans := cal(upper) base := int64(2) for ; n+base &lt;= upper; base &lt;&lt;= 1 &#123; n += base ans -= cal(base - 1) ans -= cal2(n-base+1) * base &#125; ans -= cal(upper - n - 1) ans -= cal2(n+1) * (upper - n) fmt.Printf("%d", ans)&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 698 123 Numbers]]></title>
    <url>%2F2020%2F01%2F22%2FPE%2FPE698%2FPE698%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 We define 123-numbers as follows: 1 is the smallest 123-number. When written in base 10 the only digits that can be present are “1”, “2” and “3” and if present the number of times they each occur is also a 123-number. So 2 is a 123-number, since it consists of one digit “2” and 1 is a 123-number. Therefore, 33 is a 123-number as well since it consists of two digits “3” and 2 is a 123-number.On the other hand, 1111 is not a 123-number, since it contains 4 digits “1” and 4 is not a 123-number. In ascending order, the first 123-numbers are:$1,2,3,11,12,13,21,22,23,31,32,33,111,112,113,121,122,123,131,\dots$ Let $F(n)$ be the $n-th$ 123-number. For example $F(4)=11$, $F(10)=31$, $F(40)=1112$, $F(1000)=1223321$ and $F(6000)=2333333333323$. Find $F(111111111111222333)$. Give your answer modulo $123123123$. 题意定义一种数字： 1是这种数字 如果一个数字在10进制下只包含1，2，3，并且这些数字出现的次数也是这种数字，那么这个数字也是这种数字。 将这种数字从小到大排序后得到一个序列，问你这个序列的第 $111111111111222333$ 项 % $123123123$。 分析一个简单的想法是，对于每个固定长度的数字，我们可以得到所有可行的答案数。基于这个想法我们能很快定出答案的长度。 然后现在已经知道答案的长度了，我们可以枚举每一位答案，看当前位应该是几。 然后答案就很明显了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758num = [0,1,2,3,11,12,13,21,22,23,31,32,33,111,112,113,121,122,123,131]upper = 111111111111222333def check(a): for i in range(0, 20): if num[i] == a: return True return Falsedef fac(a): if a == 0: return 1 return a*fac(a-1) def C(a, b): return fac(a)/fac(b)/fac(a-b)def real_get(a, b, c, length): ret = 0 for i in range(0, 20): if num[i] &gt; length: break if num[i] &lt; a: continue for j in range(0, 20): if num[i] + num[j] &gt; length or length - num[i] - num[j] &lt; c: break if num[j] &lt; b or check(length - num[i] - num[j]) == False: continue ret = ret + C(length-a-b-c, num[i]-a) * C(length-b-c-num[i], num[j]-b) return ret def equal(a, b): if a==b: return 1 return 0index = 0for index in range(1,50): buf = real_get(0,0,0,index) if upper &gt;= buf: upper = upper - buf else: print index, upper breaka = [0, 0, 0]ans = 0for i in range(0, index): for j in range(0, 3): buf = real_get(a[0] + equal(j, 0), a[1] + equal(j, 1), a[2] + equal(j, 2), index) if upper &gt; buf: upper = upper - buf else: a[j] = a[j] + 1 ans = ans * 10 + j + 1 breakprint ans % 123123123]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 317 Firecracker]]></title>
    <url>%2F2020%2F01%2F13%2FPE%2FPE317%2FPE317%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 A firecracker explodes at a height of $100$ m above level ground. It breaks into a large number of very small fragments, which move in every direction; all of them have the same initial velocity of $20 m/s$. We assume that the fragments move without air resistance, in a uniform gravitational field with $g=9.81 m/s^2$. Find the volume (in $m^3$) of the region through which the fragments move before reaching the ground. Give your answer rounded to four decimal places. 题意一个爆竹在 $100$ 米的高度上爆炸了，碎片以 $20m/s$ 的速度往四面八方迸射。假设当地有 $g = 9.81m/s^2$ 的均匀重力加速度。问你所有碎片经过的体积。 分析其实我刚拿到题就意识到可能是一个我不会的知识。 然后队友想都没想来了句，抛物线的包络线。。。orz 如果知道包络线这种东西就很简单了。推导过程如下： $ x = u \cdot cos\theta \cdot t$ $ y = u \cdot sin\theta \cdot t - \frac{1}{2} g \cdot t^2 + 100$ 联立后消去 $t$ : $y = tan\theta \cdot x - \frac{g \cdot sec^2\theta}{2u^2} \cdot x^2 + 100$ 对 $\theta$ 求导有： $\frac{dy}{d\theta} = sec^2\theta \cdot x - \frac{g \cdot x^2}{u^2} tan\theta \cdot sec^2\theta$ 令上式等于 $0$ 有： $tan\theta = \frac{u^2}{gx}$ 带到原式有： $y = \frac{u^2}{2g} - \frac{g \cdot x^2}{2u^2} + 100$ $\therefore y_{max} = \frac{u^2}{2g} + 100$ $\therefore x^2 = \frac{u^4}{g^2} - \frac{2u^2Y}{g} + \frac{200u^2}{g}$ 然后对每个圆积分，有 $answer = \big(\int_{0}^{100+\frac{u^2}{2g}} \frac{u^4}{g^2} - \frac{2u^2Y}{g} + \frac{200u^2}{g}dY\big)\pi = \frac{u^4Y}{g^2} - \frac{u^2Y^2}{g} + \frac{200u^2Y}{g}\big|_0^{100+\frac{u^2}{2g}}*\pi$ 代码这题我是手算的 (/ω＼)]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 292 Pythagorean Polygons]]></title>
    <url>%2F2020%2F01%2F10%2FPE%2FPE292%2FPE292%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 We shall define a pythagorean polygon to be a convex polygon with the following properties: there are at least three vertices, no three vertices are aligned, each vertex has integer coordinates, each edge has integer length. For a given integer $n$, define $P(n)$ as the number of distinct pythagorean polygons for which the perimeter is $≤ n$. Pythagorean polygons should be considered distinct as long as none is a translation of another. You are given that $P(4) = 1$, $P(30) = 3655$ and $P(60) = 891045$.Find $P(120)$. 题意我们定义满足以下条件的凸包是一个毕达哥拉斯多边形： 至少包含三个点 不存在三点共线 所有点的横纵坐标都是整数 所有边长都是整数 对于给定的 $n$，我们定义 $P(n)$ 是周长 $\leq n$ 的不同的毕达哥拉斯多边形的数量。 分析显然可以记忆化搜索。 首先我们可以暴搜出所有可行的方向。可以发现可行的方向并不多。因为要求点和长度都是整数，意味着要么是平行x轴，要么是平行y轴，要么是一个两边长都是整数的直角三角形的斜边，而且斜边长是整数，例如 $(3,4,5)$ 。 然后为了保证是凸包，我们按照方向逆时针进行枚举，每次枚举出一个方向后，判断一下可以往这个方向延伸多少，然后check一下剩下的距离足够到原点嘛。稍微剪剪枝，就可以了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int max_coordinate = 85;long long ans[max_coordinate &lt;&lt; 1][max_coordinate &lt;&lt; 1][130][140];inline int gcd(int a, int b) &#123;/*&#123;&#123;&#123;*/ if (a == 0) return b; return gcd(b % a, a);&#125;/*&#125;&#125;&#125;*/int check(int x, int y) &#123;/*&#123;&#123;&#123;*/ if (gcd(x, y) != 1) return false; int buf = x * x + y * y; int sqrt_buf = sqrt(buf); if(sqrt_buf*sqrt_buf==buf) return sqrt_buf; return 0;&#125;/*&#125;&#125;&#125;*/inline int dis(int a, int b) &#123;/*&#123;&#123;&#123;*/ return sqrt(a * a + b * b);&#125;/*&#125;&#125;&#125;*/struct dir &#123;/*&#123;&#123;&#123;*/ int x, y, dis; dir() &#123;&#125;; dir(int _x, int _y, int _dis) &#123; x = _x, y = _y, dis = _dis; &#125;&#125;;/*&#125;&#125;&#125;*/dir all_dir[150];int len_all_dir = 0;bool cmp(dir a, dir b) &#123;/*&#123;&#123;&#123;*/ return a.y * b.x &lt; a.x * b.y;&#125;/*&#125;&#125;&#125;*/void init_all_dir() &#123;/*&#123;&#123;&#123;*/ // domain 1 for (int i = 0; i &lt;= 85; i++) for (int j = 0; j &lt;= 85; j++) if (check(i, j)) all_dir[len_all_dir++] = dir(i, j, check(i, j)); sort(all_dir, all_dir + len_all_dir, cmp); // domain 2 int len = len_all_dir; for (int i = len - 2; i &gt;= 0; i--) all_dir[len_all_dir++] = dir(-all_dir[i].x, all_dir[i].y, all_dir[i].dis); // domain 3, 4 len = len_all_dir; for (int i = len - 2; i &gt; 0; i--) all_dir[len_all_dir++] = dir(all_dir[i].x, -all_dir[i].y, all_dir[i].dis);&#125;/*&#125;&#125;&#125;*/long long gao(int x, int y, int len, int ind) &#123; if (ans[x][y][len][ind] != -1) return ans[x][y][len][ind]; if (x == max_coordinate &amp;&amp; y == max_coordinate &amp;&amp; len == 0) return ans[max_coordinate][max_coordinate][0][ind] = 1; ans[x][y][len][ind] = 0; for (int i = ind; i &lt; len_all_dir; i++) &#123; if (ind &amp;&amp; all_dir[i].x == -all_dir[ind - 1].x &amp;&amp; all_dir[i].y == -all_dir[ind - 1].y) continue; int upper = len / all_dir[i].dis; for (int j = 1; j &lt;= upper; j++) &#123; int new_x = x + all_dir[i].x * j; int new_y = y + all_dir[i].y * j; int new_len = len - all_dir[i].dis * j; int new_ind = i + 1; if (dis(new_x - max_coordinate, new_y - max_coordinate) &gt; new_len) continue; ans[x][y][len][ind] += gao(new_x, new_y, new_len, new_ind); &#125; &#125; return ans[x][y][len][ind];&#125;const int upper = 120;int main() &#123; init_all_dir(); for (int i = 0; i &lt; max_coordinate &lt;&lt; 1; i++) for (int j = 0; j &lt; max_coordinate &lt;&lt; 1; j++) for (int k = 0; k &lt; 130; k++)for (int l = 0; l &lt; 140; l++) ans[i][j][k][l] = -1; long long ans = 0; for (int i = 4; i &lt;= upper; i += 2) &#123; long long buf = gao(max_coordinate, max_coordinate, i, 0); ans += buf; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; buf &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 684 Inverse Digit Sum]]></title>
    <url>%2F2019%2F12%2F03%2FPE%2FPE684%2FPE684%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Define $s(n)$ to be the smallest number that has a digit sum of $n$. For example $s(10)=19$. Let $S(k)=\sum_{n=1}^k s(n)$. You are given $S(20)=1074$. Further let $f_i$ be the Fibonacci sequence defined by $f_0=0,f_1=1$ and $f_i=f_{i−2}+f_{i−1}$ for all $i≥2$. Find $\sum_{i=2}^{90} S(f_i)$. Give your answer modulo $1\ 000\ 000\ 007$. 题意定义 $s(n)$ 表示最小的数位和为 $n$ 的整数，例如 $s(10) = 19$。 并定义 $S(k) = \sum_{n=1}^k s(n)$ ，例如 $S(20) = 1074$ 。 此外定义 $f_i$ 为fibonacci第 $n$ 项。 求 $\sum_{i=2}^{90} S(f_i) % 1\ 000\ 000\ 007$ 。 分析首先我们有，$s(n)$ 的后缀显然是一串 $9$ ，前缀是某一个数字或者空。这样为最大。 然后一个简单的想法是，我们诸位统计答案，对于每一位来说，显然是存在 $1\rightarrow 9$ 。然后剩下的这个位置一定全是 $9$ 。这样可以统计出答案，但是我们发现，数据量太大了。$o(n)$ 的显然不太够。 我的做法是，我把每个数字都 $+1$ ，这样做的好处是，每一位一定是$1\rightarrow9$ 。然后后面的位数就是一个等比数列，然后稍微处理一下前面几位就可以了。 简单画个示意图，假设 $n = 20$。 老做法是这样： 百位 十位 个位 $0$ $0$ $1\rightarrow9$ $0$ $1\rightarrow 9$ $9$ $1\rightarrow 2$ $9$ $9$ 然后我们诸位统计，答案的计算表达式大概是这样：${\sum_{i=1}^9 1 + 9(n-9)} + {\sum_{i=1}^9 + 9(n-18)}10 + {\sum_{i=1}^2}*100$ 新做法是每个数 $+1$ ，然后补一个 $1$ 然后总答案 $-(n+1)$ 。补 $1$ 后： 百位 十位 个位 $0$ $0$ $1\rightarrow9$ $0$ $1\rightarrow 9$ $0$ $1\rightarrow 3$ $0$ $0$ 然后对于后缀是一个公比为 $10$ 的等比数列。可以直接统计： $45(1+10) + \sum_{i=1}^{3}100 - (20+1)$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9+7;inline int add(long long a,long long b) &#123;a%=mod, b%=mod;return (a+b+mod)%mod;&#125;inline int mul(long long a,long long b) &#123;return a*b%mod;&#125;inline int qpow(long long a, long long b) &#123;/*&#123;&#123;&#123;*/ int ret = 1; while(b) &#123; if(b&amp;1) ret = mul(ret, a); a = mul(a,a); b&gt;&gt;=1; &#125; return ret;&#125;/*&#125;&#125;&#125;*/inline int inv(long long a) &#123; return qpow(a, mod-2); &#125;long long num[100];long long S(long long a) &#123; long long ret = 0; ret = add(ret, mul(45, mul(inv(9), add(qpow(10, a/9), -1)))); long long buf = a%9+1; ret = add(ret, mul(mul(buf, buf+1), mul(inv(2), qpow(10, a/9)))); ret = add(ret, -a-1); return ret;&#125;void init_num() &#123;/*&#123;&#123;&#123;*/ num[1] = 1; cout&lt;&lt;"f_1 = "&lt;&lt;num[1]&lt;&lt;endl; for(int i = 2;i&lt;=90;i++) &#123; num[i] = num[i-1] + num[i-2]; cout&lt;&lt;"f_"&lt;&lt;i&lt;&lt;" = "&lt;&lt;num[i]&lt;&lt;endl; &#125;&#125;/*&#125;&#125;&#125;*/long long ans[100];int main() &#123; init_num(); for(int i = 2;i&lt;=90;i++) &#123; ans[i] = add(ans[i-1],S(num[i])); cout&lt;&lt;"sum of S(f_"&lt;&lt;i&lt;&lt;") = "&lt;&lt;ans[i]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 847 I]]></title>
    <url>%2F2019%2F09%2F23%2FCF%2FCF_847_I%2F</url>
    <content type="text"><![CDATA[I. Noise Level开启传送门 题目描述The Berland’s capital has the form of a rectangle with sizes $n × m$ quarters. All quarters are divided into three types: regular (labeled with the character ‘.’) — such quarters do not produce the noise but are not obstacles to the propagation of the noise; sources of noise (labeled with an uppercase Latin letter from ‘$A$’ to ‘$Z$’) — such quarters are noise sources and are not obstacles to the propagation of the noise; heavily built-up (labeled with the character ‘$*$’) — such quarters are soundproofed, the noise does not penetrate into them and they themselves are obstacles to the propagation of noise. A quarter labeled with letter ‘A’ produces $q$ units of noise. A quarter labeled with letter ‘B’ produces $2\cdot q$ units of noise. And so on, up to a quarter labeled with letter ‘Z’, which produces $26\cdot q$ units of noise. There can be any number of quarters labeled with each letter in the city. When propagating from the source of the noise, the noise level is halved when moving from one quarter to a quarter that shares a side with it (when an odd number is to be halved, it’s rounded down). The noise spreads along the chain. For example, if some quarter is located at a distance $2$ from the noise source, then the value of noise which will reach the quarter is divided by $4$. So the noise level that comes from the source to the quarter is determined solely by the length of the shortest path between them. Heavily built-up quarters are obstacles, the noise does not penetrate into them. The values in the cells of the table on the right show the total noise level in the respective quarters for q = 100, the first term in each sum is the noise from the quarter ‘A’, the second — the noise from the quarter ‘B’.The noise level in quarter is defined as the sum of the noise from all sources. To assess the quality of life of the population of the capital of Berland, it is required to find the number of quarters whose noise level exceeds the allowed level $p$. InputThe first line contains four integers $n, m, q$ and $p$ ($1 ≤ n, m ≤ 250, 1 ≤ q, p ≤ 10^6$) — the sizes of Berland’s capital, the number of noise units that a quarter ‘$A$’ produces, and the allowable noise level. Each of the following $n$ lines contains m characters — the description of the capital quarters, in the format that was described in the statement above. It is possible that in the Berland’s capital there are no quarters of any type. OutputPrint the number of quarters, in which the noise level exceeds the allowed level $p$. Examplesinput13 3 100 140 … A*. .B. output13 input23 3 2 8 B*. BB* BBB output24 input33 4 5 4 ..*B ..** D… output37 NoteThe illustration to the first example is in the main part of the statement. 题意zuhiul家里有很多妹子，但是有一天，妹子们对他都很不满，所以妹子们都在呼叫他，如你所见，妹子在一些点中，并且每个妹子的音量都是他的倍数，其中 A 表示一倍，B表示两倍，最厉害的妹子甚至可以喊出他 26 倍音量（也即 Z ），但是好处是，每个妹子的音量都会随着哈密顿距离指数级减半。zuhiul的耳朵有个承受上线，如果太多杂音，他会受不了。现在问，有多少个位置的音量是zuhiul可接受的。注意，他不能和妹子一个位置。也不能在*上。 分析一个显然的做法是，我们可以直接把每个有音量的地方传播下去，就可以得到一个比较完美的图。然后把音量叠加后枚举每个位置，判断当前音量是否超过阈值即可。 可以发现的是，因为每次音量都是倍减的，所以可以得到，最多倍减log次，所以对于一个音量来说，最大的传播范围是O($log(p_{max})log(p_{max})$) ，所以复杂度是O($nmlog(p_{max})log(p_{max})$) 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;const int maxm = 300;int n, m;long long a, b;char mat[maxm][maxm];long long ans[maxm][maxm];struct p &#123; int x,y,val;&#125;;int dirx[] = &#123;0,0,1,-1&#125;;int diry[] = &#123;1,-1,0,0&#125;;bool vis[maxm][maxm];vector&lt;p&gt; vis_buf;void gao(int a,int b, int val) &#123; queue&lt;p&gt; q; vis_buf.resize(0); q.push(p&#123;a,b,val&#125;); vis_buf.push_back(p&#123;a,b,val&#125;); vis[a][b] = true; ans[a][b] += val; while(!q.empty()) &#123; p buf = q.front(); q.pop(); if(buf.val==0) continue; for(int dir = 0;dir&lt;4;dir++) &#123; int x = buf.x + dirx[dir]; int y = buf.y + diry[dir]; if(x&lt;0||y&lt;0||x&gt;=n||y&gt;=m) continue; if(mat[x][y]=='*') continue; if(vis[x][y]) continue; vis[x][y] = true; vis_buf.push_back(p&#123;x,y,0&#125;); ans[x][y] += buf.val&gt;&gt;1; q.push(p&#123;x,y,buf.val&gt;&gt;1&#125;); &#125; &#125; for(auto i:vis_buf) &#123; vis[i.x][i.y] = false; &#125;&#125;int main() &#123; scanf("%d%d%lld%lld", &amp;n, &amp;m, &amp;a, &amp;b); for (int i = 0; i &lt; n; i++) scanf("%s", mat[i]); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (mat[i][j] == '*') continue; int val = mat[i][j] == '.' ? 0 : (mat[i][j] - 'A' + 1) * a; if(val==0) continue; gao(i,j,val); &#125; &#125; int rans = 0; for(int i = 0;i&lt;n;i++) for(int j = 0;j&lt;m;j++) if(ans[i][j]&gt;b) rans++; printf("%d\n", rans); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1187 E]]></title>
    <url>%2F2019%2F09%2F20%2FCF%2FCF_1187_E%2F</url>
    <content type="text"><![CDATA[E. Tree Painting开启传送门 题目描述You are given a tree (an undirected connected acyclic graph) consisting of $n$ vertices. You are playing a game on this tree. Initially all vertices are white. On the first turn of the game you choose one vertex and paint it black. Then on each turn you choose a white vertex adjacent (connected by an edge) to any black vertex and paint it black. Each time when you choose a vertex (even during the first turn), you gain the number of points equal to the size of the connected component consisting only of white vertices that contains the chosen vertex. The game ends when all vertices are painted black. Let’s see the following example: Vertices $1$ and $4$ are painted black already. If you choose the vertex $2$, you will gain $4$ points for the connected component consisting of vertices $2,3,5$ and $6$. If you choose the vertex $9$, you will gain $3$ points for the connected component consisting of vertices $7,8$ and $9$. Your task is to maximize the number of points you gain. InputThe first line contains an integer $n$ — the number of vertices in the tree ($2≤n≤2⋅10^5$). Each of the next $n−1$ lines describes an edge of the tree. Edge $i$ is denoted by two integers $u_i$ and $v_i$, the indices of vertices it connects ($1≤u_i,v_i≤n$, $u_i\neq v_i$). It is guaranteed that the given edges form a tree. OutputPrint one integer — the maximum number of points you gain if you will play optimally. Examplesinput19 1 2 2 3 2 5 2 6 1 4 4 9 9 7 9 8 output136 input25 1 2 1 3 2 4 2 5 output214 NoteThe first example tree is shown in the problem statement. 题意zuhiul认识很多妹子（不超过$2\cdot 10^5$个），妹子之间是个树形关系。他决定每天聊一个妹子，但是他是个强迫症，第一天他可以随便聊任何一个妹子，但是之后每一天，他只能聊和之前聊过的妹子有关系的妹子。每次聊一个妹子之前，他会数一下这个妹子所在的未聊过的连通块的大小，当然，连通块越大他越开心（连通块为 $n$ ，他会得到 $n$ 开心度），现在问你，他聊完所有妹子后，开心度求和后为多少。 分析如果我们强制第一次聊编号为 $1$ 的妹子， 我们考虑怎么统计答案。 一个很直观的想法是，我们可以一次dfs出所有子树的大小，然后对于每棵子树大小求和就是答案。 那么现在问题就转化成了，如何对于每个根求答案。 显然换根可解，但是如何统计换根后的答案呢？ 我们考虑一下，我们以 $1$ 为根的时候怎么算的答案呢？ 每棵子树的大小求和。但是我们可以换个角度看问题，我们不看子树的贡献，我们考虑每个节点的贡献，可以显然的发现，每个节点的贡献就是每个节点到 $1$ 的距离。 所以换根就很直观了。我们定义 $ans[i]$ 表示以 $i$ 为根的答案，$cnt[i]$ 表示以 $1$ 为根的时候，$i$ 子树的大小。所以换根相对于当前节点的父亲的代价就是 $i$ 子树深度-1，其他节点深度+1。所以当前节点相对于父亲的答案是，减少了 $cnt[i]$，增加了 $n-cnt[i]$。也即 $$ans[ind] = ans[pre] - cnt[ind] + (n-cnt[ind]) $$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 2e5+10;int n;vector&lt;int&gt; mat[maxm];long long size[maxm];long long ans[maxm];void dfs(int ind = 1, int pre = 0) &#123; size[ind] = 1; for(auto i:mat[ind]) &#123; if(i==pre) continue; dfs(i, ind); size[ind] += size[i]; &#125; ans[1] += size[ind];&#125;void dfs2(int ind, int pre) &#123; ans[ind] = ans[pre] - size[ind] + (n-size[ind]); for(auto i:mat[ind]) &#123; if(i==pre) continue; dfs2(i, ind); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1, from, to;i&lt;n;i++) &#123; scanf("%d%d",&amp;from,&amp;to); mat[from].push_back(to); mat[to].push_back(from); &#125; dfs(); for(auto i:mat[1]) dfs2(i, 1); long long rans = 0; for(int i = 1;i&lt;=n;i++) rans = max(rans, ans[i]); printf("%lld\n", rans); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1187 E]]></title>
    <url>%2F2019%2F09%2F20%2FCF%2FCF_226_B%2F</url>
    <content type="text"><![CDATA[E. Tree Painting开启传送门 题目描述There are $n$ piles of stones of sizes $a_1,a_2,\dots,a_n$ lying on the table in front of you. During one move you can take one pile and add it to the other. As you add pile $i$ to pile $j$, the size of pile $j$ increases by the current size of pile $i$, and pile $i$ stops existing. The cost of the adding operation equals the size of the added pile. Your task is to determine the minimum cost at which you can gather all stones in one pile. To add some challenge, the stone piles built up conspiracy and decided that each pile will let you add to it not more than $k$ times (after that it can only be added to another pile). Moreover, the piles decided to puzzle you completely and told you $q$ variants (not necessarily distinct) of what $k$ might equal. Your task is to find the minimum cost for each of $q$ variants. InputThe first line contains integer $n$ ($1 \leq n \leq 10^5$) — the number of stone piles. The second line contains $n$ space-separated integers: $a_1,a_2,\dots,a_n$ ($1 \leq a_i \leq 10^9$) — the initial sizes of the stone piles. The third line contains integer $q$ ($1 \leq q \leq 10^5$) — the number of queries. The last line contains $q$ space-separated integers $k_1,k_2,\dots,k_q$ ($1 \leq k_i \leq 10^5$) — the values of number $k$ for distinct queries. Note that numbers $k_i$ can repeat. OutputPrint $q$ whitespace-separated integers — the answers to the queries in the order, in which the queries are given in the input. Please, do not use the $\%lld$ specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the $\%I64d$ specifier. Examplesinput15 2 3 4 1 1 2 2 3 output19 8 NoteIn the first sample one way to get the optimal answer goes like this: we add in turns the $4$-th and the $5$-th piles to the $2$-nd one; then we add the $1$-st pile to the $3$-rd one; we add the $2$-nd pile to the $3$-rd one. The first two operations cost $1$ each; the third one costs $2$, the fourth one costs $5$ (the size of the $2$-nd pile after the first two operations is not $3$, it already is $5$). In the second sample you can add the $2$-nd pile to the $3$-rd one (the operations costs $3$); then the $1$-st one to the $3$-th one (the cost is $2$); then the $5$-th one to the $4$-th one (the costs is $1$); and at last, the $4$-th one to the $3$-rd one (the cost is $2$). 题意这有 $n$ 堆石子，每堆分别有 $a_1,a_2,\dots,a_n$ 个石子放在你面前的桌子上。 在每次移动中，你可以选择一堆石子，并把它合并到其他的堆上。如果你把第 $i$ 堆加到第 $j$ 堆上，那么第 $j$ 堆会增加当前第 $i$ 堆拥有的石子数，并且第 $i$ 堆将不会继续存在。这样操作的代价是第 $i$ 堆的石子数。 你的任务是考虑把这些石子合成一堆的最小代价。 为了增加一些难度，我们规定，合并的石头堆最多被合并 $k$ 次（在这之后，你只能把这一堆合并到其他堆上）。 此外，你将会被询问 $q$ 次，每次给你可能相同的 $k$ 。 你的任务是对于这 $q$ 个询问，给出最小花费。 分析我们首先考虑如果只有一次询问我们怎么做。 假设当前每一堆最多被合并 $k$ 次。 假设当前只有 $k+1$ 堆，我们的做法显然是，排序，把最小的 $k$ 堆合并到最大堆上。 假设当前只有 $k+2$ 堆，那么我们可以得到的是，我们需要合并 $k+1$ 次，所以必然有一堆被合并了两次，除了最大堆之外，其他堆合并了一次。要让代价最小，我们需要让最小堆被合并两次。所以操作是，我们把最小堆合并到除最大堆的某一堆，然后其他堆合并到最大堆。 $\dots$ 假设当前有 $k*k + k + 1$ 堆，我们怎么操作呢？ 首先我们可以确定的是，需要合并 $kk+k$ 次，因为一堆最多被合并 $k$ 次，所以我们可以得到，这 $kk+k$ 次合并中，必定会有 $k$ 次合并，实际上是将两堆及以上合并到了某一堆中，也即：有 $k*k$ 堆被合并了两次， 有 $k$ 堆被合并了一次。所以一个显而易见的贪心策略就出来了。 每次我们倍增 $k$ 挑出这么多堆出来，合并次数增加。为了保证答案最小，显然是，最后合并的是大堆，也就是合并次数最少。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e5+10;int n, q;long long a[maxm];void input() &#123; cin&gt;&gt;n; for(int i = 0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); reverse(a,a+n); for(int i = 1;i&lt;n;i++) a[i] += a[i-1];&#125;long long get_ans(int len) &#123; long long ans = 0; long long rlen = len, cnt = 1; for(int i = 1;i&lt;n;) &#123; int r = min(n-1ll,i+rlen-1); ans += (a[r] - a[i-1])*cnt; cnt++; i = r+1; rlen *= len; &#125; return ans;&#125;long long ans[maxm];void solve() &#123; cin&gt;&gt;q; while(q--) &#123; int len; cin&gt;&gt;len; if(ans[len]) cout&lt;&lt;ans[len]&lt;&lt;' '; else &#123; ans[len] = get_ans(len); cout&lt;&lt;ans[len]&lt;&lt;' '; &#125; &#125; cout&lt;&lt;endl;&#125;int main()&#123; cin.tie(0); ios::sync_with_stdio(false); input(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1215 E]]></title>
    <url>%2F2019%2F09%2F16%2FCF%2FCF_1215_E%2F</url>
    <content type="text"><![CDATA[E. Marbles开启传送门 题目描述Monocarp has arranged $n$ colored marbles in a row. The color of the $i$-th marble is $a_i$. Monocarp likes ordered things, so he wants to rearrange marbles in such a way that all marbles of the same color form a contiguos segment (and there is only one such segment for each color). In other words, Monocarp wants to rearrange marbles so that, for every color $j$, if the leftmost marble of color $j$ is $l$-th in the row, and the rightmost marble of this color has position $r$ in the row, then every marble from $l$ to $r$ has color $j$. To achieve his goal, Monocarp can do the following operation any number of times: choose two neighbouring marbles, and swap them. You have to calculate the minimum number of operations Monocarp has to perform to rearrange the marbles. Note that the order of segments of marbles having equal color does not matter, it is only required that, for every color, all the marbles of this color form exactly one contiguous segment. InputThe first line contains one integer $n$ ($2≤n≤4\cdot10^5$) — the number of marbles. The second line contains an integer sequence $a_1, a_2, \dots, a_n$($1≤a_i≤20$), where $a_i$ is the color of the $i$-th marble. OutputPrint the minimum number of operations Monocarp has to perform to achieve his goal. Examplesinput17 3 4 2 3 4 2 2 output13 input25 20 1 14 10 2 output20 input313 5 5 4 4 3 5 7 6 5 4 4 6 5 output321 NoteIn the first example three operations are enough. Firstly, Monocarp should swap the third and the fourth marbles, so the sequence of colors is $[3,4,3,2,4,2,2]$. Then Monocarp should swap the second and the third marbles, so the sequence is $[3,3,4,2,4,2,2]$. And finally, Monocarp should swap the fourth and the fifth marbles, so the sequence is $[3,3,4,4,2,2,2]$. In the second example there’s no need to perform any operations. 题意zuhiul认识很多妹子，显然不同的妹子有不同的颜值（颜值最高为20，最小为1），有一天他把他认识的所有妹子召集在一起（不超过$4\cdot 10^5$个），她们站成一排。现在zuhiul想把颜值相同的妹子放在一起，但是妹子们都在玩手机，所以他只能每次叫两个相邻的妹子配合一下交换。现在问你最小交换次数，使得所有颜值相同的妹子坐在一起。 分析当时没做出来，看的题解（orz）， 所以先给官方题解，强烈建议先看官方题解。 The main fact is that the number of colors is less than $20$, which allows us to use exponential solutions. For each pair of colors $(i,j)$, we can calculate $cnt[i][j]$ — the number of swaps required to place all marbles of color $i$ before all marbles of color $j$ (if we consider only marbles of these two colors). We can store a sorted vector for each color, and calculate this information for a fixed pair with two pointers. Then let’s use subset DP to fix the order of colors. Let $d[mask]$ be the minimum number of operations to correctly order all marbles from the $mask$ of colors. Let’s iterate on the next color we consider — it should be a position in binary representation of $mask$ with $0$ in it. We will place all marbles of this color after all marbles we already placed. If we fix a new color $i$, let’s calculate the $sum$ (the additional number of swaps we have to make) by iterating on the bit $j$ equal to $1$ in the $mask$, and increasing 𝑠𝑢𝑚 by $cnt[j][i]$ for every such bit. The new state of DP can be calculated as $nmask=mask|(1&lt;&lt;i)$. So the transition can be implemented as $d[nmask]=min(d[nmask],d[mask]+sum)$. The answer is the minimum number of swaps required to place all the colors, and that is $d[2^{20}-1]$. 因为看的题解，所以没想出第二种解法，用我的话复述一下。 因为不同的颜值数量很少（$&lt;=20$)，所以我们可以在这个方向上下文章。 如果考虑只有两种颜色，我们可以很轻易的知道答案是多少（通过枚举每个不同的位置算贡献）。 于是考虑可以用状压DP来搞，$dp[i]$表示状态为 $i$ 的时候的代价。那么答案显然是$d[2^{20}-1]$. 考虑转移，枚举每个已知答案的子集。我们怎么推算下一个状态的答案呢？ 显然是往里面加了一个之前没有的值。我们不妨设当前状态为$mask$，当前新加的是 $i$ ， $i$ 加进来的代价是 $sum$ 。那么新状态显然就是$nmask=mask|(1&lt;&lt;i)$。并且我们有$ans[nmask] = min(ans[nmask], ans[mask]+sum)$。 剩下的就是考虑怎么算 $sum$。 记得我们刚刚说的吗？对于两种颜值我们怎么计算的？利用两种颜值的计算方法，我们可以预处理处一个代价矩阵$cnt[i][j]$,表示只考虑 $i$ 和 $j$ 两种颜值，我们把这两堆人排好序（ $i$ 在前，$j$ 在后）的代价。 然后可以得到 $ sum = \sum_{j\in mask}^{} cnt[i][j]$ over. 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int n;const int maxm = 1e6;const long long inf = 1e18;vector&lt;long long&gt; mat[22];long long value[22][22];long long ans[1&lt;&lt;21];int main()&#123; scanf("%d",&amp;n); for(int i = 0, a;i&lt;n;i++) &#123; scanf("%d",&amp;a); mat[a].push_back(i); &#125; for(int i = 0;i&lt;=20;i++) mat[i].push_back(maxm&lt;&lt;1); for(int i = 1;i&lt;=20;i++) &#123; if(mat[i].size()==0) continue; for(int j = 1;j&lt;=20;j++) &#123; if(mat[j].size()==0||i==j) continue; long long ind1 = 0; for(auto ind : mat[j]) &#123; if(ind &gt; maxm) continue; while(ind &gt; mat[i][ind1]) ind1++; value[i-1][j-1] += ind1; &#125; &#125; &#125; for(int i = 0;i&lt;(1&lt;&lt;20);i++) ans[i] = inf; ans[0] = 0; for(int mask = 0;mask&lt;(1&lt;&lt;20);mask++) &#123; vector&lt;int&gt; has_bit; for(int i = 0;i&lt;20;i++) if(mask&amp;(1&lt;&lt;i)) has_bit.push_back(i); for(int i = 0;i&lt;20;i++)&#123; if(mask&amp;(1&lt;&lt;i)) continue; long long sum = 0; for(int j = 0;j&lt;has_bit.size();j++) sum+=value[i][has_bit[j]]; int nmask = mask|(1&lt;&lt;i); ans[nmask] = min(ans[nmask], ans[mask]+sum); &#125; &#125; printf("%lld\n", ans[(1&lt;&lt;20)-1]); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 761 E]]></title>
    <url>%2F2019%2F09%2F14%2FCF%2FCF_761_E%2F</url>
    <content type="text"><![CDATA[E. Dasha and Puzzle开启传送门 题目描述Dasha decided to have a rest after solving the problem. She had been ready to start her favourite activity — origami, but remembered the puzzle that she could not solve. The tree is a non-oriented connected graph without cycles. In particular, there always are $n - 1$ edges in a tree with $n$ vertices. The puzzle is to position the vertices at the points of the Cartesian plane with integral coordinates, so that the segments between the vertices connected by edges are parallel to the coordinate axes. Also, the intersection of segments is allowed only at their ends. Distinct vertices should be placed at different points. Help Dasha to find any suitable way to position the tree vertices on the plane. It is guaranteed that if it is possible to position the tree vertices on the plane without violating the condition which is given above, then you can do it by using points with integral coordinates which don’t exceed $10^{18}$ in absolute value. InputThe first line contains single integer $n$ ($1 ≤ n ≤ 30$) — the number of vertices in the tree. Each of next $n - 1$ lines contains two integers $u_i, v_i$ ($1 ≤ u_i, v_i ≤ n$) that mean that the $i$-th edge of the tree connects vertices $u_i$ and $v_i$. It is guaranteed that the described graph is a tree. OutputIf the puzzle doesn’t have a solution then in the only line print “NO”. Otherwise, the first line should contain “YES”. The next n lines should contain the pair of integers $x_i$, $y_i$ (|$x_i$|, |$y_i$| ≤ $10^{18}$) — the coordinates of the point which corresponds to the $i$-th vertex of the tree. If there are several solutions, print any of them. Examplesinput17 1 2 1 3 2 4 2 5 3 6 3 7 output1YES 0 0 1 0 0 1 2 0 1 -1 -1 1 0 2 input26 1 2 2 3 2 4 2 5 2 6 output2NO input34 1 2 2 3 3 4 output3YES 3 3 4 3 5 3 6 3 NoteIn the first sample one of the possible positions of tree is: 题意zuhiul认识很多妹子（不超过30个），妹子之间是个树形关系。zuhiul家很大，所以他想把所有妹子放家里，因为zuhiul比较喜欢整点，所以他希望妹子都在整点上，并且有关系的妹子，他们之间的连线平行于坐标轴，并且关系不能相交，也不能重合（贵圈真乱！）。虽然zuhiul很有钱，但是他家也不是无限大，也即：所有妹子的坐标的绝对值不能超过$10^{18}$。 分析显然的构造题。 首先因为妹子的关系不能相交，并且要平行于坐标轴，所以可以得到如果一个妹子和四个以上的妹子有关系，那么显然就不能构造出来。首先处理这种非法情况。 剩下的显然是一个dfs搞一下，因为无根，直接取$1$为根。 然后显然是找一个比较好的展开方式就行了。一个直观的做法就是按层次展开就行了。但是为了保证关系不交。我们考虑用下面两个规则展开。 1.每层的距离至多为前一层的$\frac{1}{2}$。 2.同层的节点的距离不同。 这样可以保证所有的点在四相扩展的时候不交。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int n;vector&lt;int&gt; son[100];long long dirx[] = &#123;1,-1,0,0&#125;;long long diry[] = &#123;0,0,1,-1&#125;;bool has_position[100];long long ansx[100],ansy[100];void lay(int ind, int pre, long long x,long long y, int dir, int floor) &#123; has_position[ind] = true; ansx[ind] = x; ansy[ind] = y; long long rdis = 1ll&lt;&lt;floor; int dir_ind = 0; for(int i:son[ind]) &#123; if(i==pre) continue; if(dir_ind==(dir^1)) dir_ind++; if(dir_ind&gt;3) &#123; printf("NO"); exit(0); &#125; lay(i, ind, x+dirx[dir_ind]*rdis, y+diry[dir_ind]*rdis, dir_ind, floor-1); rdis--; dir_ind ++ ; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1, from ,to;i&lt;n;i++) &#123; scanf("%d%d",&amp;from,&amp;to); son[from].push_back(to); son[to].push_back(from); &#125; lay(1,0,0,0,-1,50); for(int i = 1;i&lt;=n;i++) if(!has_position[i]) &#123; printf("NO\n"); return 0; &#125; printf("YES\n"); for(int i = 1;i&lt;=n;i++) printf("%lld %lld\n", ansx[i], ansy[i]); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下监听全局键盘输入]]></title>
    <url>%2F2019%2F08%2F04%2Fskill%2Fmac_keyboard_monitor%2F</url>
    <content type="text"><![CDATA[因为这段时间终于狠下心来买了把键盘。然后这两天脑子里面全是如何统计键盘敲击次数，在我踩了几个坑之后，终于搞定了，这里总结一下。 首先就是mac下不支持pyhook，貌似，所以只能用pynput来瞎搞。安装各种依赖就不说了。 首先一个坑点就是，mac为了安全考虑，拒绝一般的程序监听键盘和鼠标等外设的输入。 然后我就想办法给python权限，“系统偏好设置-&gt;安全性与隐私-&gt;完全磁盘访问权限”，给权限整上了，但是我发现一个比较尴尬的事是：依然是跑不起来。然后就各种寻求帮助。 后来发现是要在sudo下运行，我试了一下，还是不行。 最后才发现，需要的权限名字不叫“完全磁盘访问权限”，而是“辅助功能”，服了。我的理解是：你丫都有完全的磁盘访问权限了，还没有辅助功能？开玩笑呢？ 啊，我死了。 这里贴上我抄的代码 123456789101112131415161718192021from pynput import keyboarddef on_press(key): with open('out', 'a+') as f: try: f.write(str(key.char) + '\n') except AttributeError: f.write(str(key) + '\n') f.close()def on_release(key): pass# Collect events until releasedwith keyboard.Listener( on_press=on_press, on_release=on_release) as listener: listener.join()]]></content>
      <tags>
        <tag>体验优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Problems in Set Theory]]></title>
    <url>%2F2019%2F07%2F29%2Fknowledge%2FSet%20Theory%2F</url>
    <content type="text"><![CDATA[$\text{1.Prove Theorem 1 (show that $x$ is in the left-hand set iff it is in the right-hand set).For example,for (d),}$ \begin{eqnarray}x \in(A \cup B) \cap C &amp;\Longleftrightarrow&amp; [x \in(A \cup B) \text { and } x \in C] \\&amp;\Longleftrightarrow&amp; [(x \in A \text { or } x \in B), \text { and } x \in C] \\&amp;\Longleftrightarrow&amp; [(x \in A, x \in C) \text { or }(x \in B, x \in C)]\end{eqnarray} $ A \cup A = A ; A \cap A = A$ \begin{eqnarray}A \cup A &amp;=&amp; \{ x|x \in A \} \cup \{ x|x \in A \}\\&amp;=&amp; \{ x|x \in A \}\\&amp;=&amp;A\\A \cap A &amp;=&amp; \{ x| x \in A \} \cup \{ x|x \in A \}\\&amp;=&amp; \{ x|x \in A \}\\&amp;=&amp;A\\\end{eqnarray} $ A \cup B = B \cup A , A \cap B = B \cap A $ \begin{eqnarray}A \cup B &amp;=&amp; \{ x| x \in A \} \cup \{ x|x \in B \} \\&amp;=&amp; \{ x|x \in A\ or\ x \in B \}\\&amp;=&amp; \{ x|x \in B \} \cup \{ x|x \in A \}\\&amp;=&amp; B \cup A\end{eqnarray}]]></content>
      <tags>
        <tag>Mathematical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Curse of Knowledge]]></title>
    <url>%2F2019%2F07%2F22%2Fknowledge%2FThe_Curse_of_Knowledge%2F</url>
    <content type="text"><![CDATA[知识的诅咒今天看到这个很有意思的词，记录一下。 先扔链接。 英文链接 wiki 用自己的一句话理解来说这件事就是：双方知识的不对等，导致告知者理解不了被告知者因为不清楚某些信息而造成的错误。 因为告知者很难理解在他看来很“常识”的东西，被告知者却不知道。 很多时候，我们描述一个东西，通常会省略我们都认为大家默认如此的东西，但是往往这些我们漏掉的关键信息反而是对方不清楚的。 一个很常见的例子是：我上周要做一个merge数据的操作，老大让我搞一下，当时他的原话是“有时间把这个merge做一下，这个拖了好久了”，然后我就吭哧吭哧开始做了，当我写完设计文档之后，他看完说了句“我说的不是这个merge”。 事实是这样：我们有两部分数据需要做merge。第一部分是上周没做，留下来的，第二部分是一天前没时间做的，我的理解是“拖了很久”，意思应该是第一个，而老大的意思是第二个，因为他觉得第二个是比较紧急的。 这种信息的不对等，导致了我们理解的不一致，如果我继续做的话，必然是有问题的。但是显然大家的理解都没问题，只是知识不对等而已。 知识的诅咒，描述的就是这种现象：当一个人知道一件事后，他就无法想象自己是不知道这件事的。 或许我们可以通过这看懂另一句话：门当户对。 我其实一直不理解为什么要门当户对，后来我渐渐明白一件事：两个环境相似的家庭诞生的两个孩子，可能思维观点一致的可能性更高，稳定的婚姻就越容易。成长环境其实很能限制一个人的发展，每个人的想法很大程度基于自己的成长过程。 同理，我们也很好解释，为啥会产生“知识的诅咒”这种现象。]]></content>
      <tags>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 大数]]></title>
    <url>%2F2019%2F06%2F03%2Fknowledge%2FBigInt%2F</url>
    <content type="text"><![CDATA[闲来无事写了一发玩玩。。。 不保证正确性。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;using namespace std;const int mod = 10000;char for_cin[mod&lt;&lt;8];struct bigInt &#123;/*&#123;&#123;&#123;*/ bool neg; vector&lt;int&gt; num; bigInt() &#123; neg = false; &#125; bigInt(int len) &#123; neg = false; num.resize(len); for(int i = 0;i&lt;len;i++) num[i] = 0; &#125;&#125;;/*&#125;&#125;&#125;*/void relen(bigInt&amp;a) &#123;/*&#123;&#123;&#123;*/ int len = a.num.size(); for(int i = len-1;i&gt;0;i--) &#123; if(a.num[i] &amp;&amp; a.num[i-1]&lt;0) &#123; a.num[i]--; a.num[i-1] += mod; &#125; &#125; while(a.num.size()&gt;=1&amp;&amp;a.num[a.num.size()-1]==0) a.num.resize(a.num.size()-1); if(a.num.size()==0) a.num.push_back(0);&#125;/*&#125;&#125;&#125;*/void show(bigInt a,char b = '\n')&#123;/*&#123;&#123;&#123;*/ if(a.neg) putchar('-'); int len = a.num.size(); printf("%d",a.num[len-1]); for(int i = len-2;i&gt;=0;i--)&#123; printf("%04d",a.num[i]); &#125; cout&lt;&lt;b;&#125;/*&#125;&#125;&#125;*/bool input(bigInt &amp; ret)&#123;/*&#123;&#123;&#123;*/ if(scanf("%s",for_cin)==EOF) return false; ret.num.resize(0); int startInd = 0; int len = strlen(for_cin); if(for_cin[0]=='-') &#123; startInd = 1; ret.neg = true; &#125; int i; for(i = len-4;i&gt;=startInd;i-=4)&#123; ret.num.push_back(atoi(for_cin+i)); for_cin[i] = '\0'; &#125; if(i!=startInd) ret.num.push_back(atoi(for_cin+startInd)); relen(ret); return true;&#125;/*&#125;&#125;&#125;*/bigInt trans(int a)&#123;/*&#123;&#123;&#123;*/ bigInt ret(0); if(a&lt;0) ret.neg = true,a = -a; while(a)&#123; ret.num.resize(ret.num.size()+1); ret.num[ret.num.size()-1] = a%mod; a/=mod; &#125; relen(ret); return ret;&#125;/*&#125;&#125;&#125;*/bigInt trans(long long a)&#123;/*&#123;&#123;&#123;*/ bigInt ret(0); if(a&lt;0) ret.neg = true,a = -a; while(a)&#123; ret.num.resize(ret.num.size()+1); ret.num[ret.num.size()-1] = a%mod; a/=mod; &#125; relen(ret); return ret;&#125;/*&#125;&#125;&#125;*/bool equal(bigInt a,bigInt b)&#123;/*&#123;&#123;&#123;*/ if(a.neg!=b.neg) return false; if(a.num.size()!=b.num.size()) return false; int len = a.num.size(); for(int i = 0;i&lt;len;i++) if(a.num[i]!=b.num[i]) return false; return true;&#125;/*&#125;&#125;&#125;*/bool bigger(bigInt a,bigInt b) &#123;/*&#123;&#123;&#123;*/ if(a.neg&amp;&amp;!b.neg) return false; if(!a.neg&amp;&amp;b.neg) return true; if(a.neg&amp;&amp;b.neg) &#123; a.neg = b.neg = false; bool ret = bigger(b,a); a.neg = b.neg = true; return ret; &#125; if(a.num.size()&gt;b.num.size()) return true; if(a.num.size()&lt;b.num.size()) return false; int len = a.num.size(); for(int i = len-1;i&gt;=0;i--)&#123; if(a.num[i]!=b.num[i]) return a.num[i]&gt;b.num[i]; &#125; return false;&#125;/*&#125;&#125;&#125;*/bigInt add(bigInt a,bigInt b) &#123;/*&#123;&#123;&#123;*/ bigInt ret(max(a.num.size(),b.num.size())+1); if(a.neg&amp;&amp;b.neg)&#123; a.neg = b.neg = false; ret = add(a,b); ret.neg = true; return ret; &#125; if(a.neg)&#123;/*&#123;&#123;&#123;*/ a.neg = false; if(bigger(a,b)) &#123; for(int i = b.num.size()-1;i&gt;=0;i--)&#123; a.num[i]-=b.num[i]; if(a.num[i]&lt;0) &#123; a.num[i]+=mod; a.num[i+1]--; &#125; &#125; relen(a); a.neg = true; return a; &#125;else&#123; for(int i = a.num.size()-1;i&gt;=0;i--)&#123; b.num[i]-=a.num[i]; if(b.num[i]&lt;0)&#123; b.num[i]+=mod; b.num[i+1]--; &#125; &#125; relen(b); return b; &#125; &#125;/*&#125;&#125;&#125;*/ if(b.neg) return add(b,a); int maxlen = max(a.num.size(),b.num.size()); a.num.resize(maxlen+1); int minlen = min(a.num.size(),b.num.size()); for(int i = 0;i&lt;minlen;i++)&#123; a.num[i]+=b.num[i]; if(a.num[i]&gt;=mod) &#123; a.num[i]-=mod; a.num[i+1]++; &#125; b.num[i] = 0; &#125; relen(a); return a;&#125;/*&#125;&#125;&#125;*/bigInt sub(bigInt a,bigInt b)&#123;/*&#123;&#123;&#123;*/ b.neg = ~b.neg; return add(a,b);&#125;/*&#125;&#125;&#125;*/bigInt mul(bigInt a,bigInt b)&#123;/*&#123;&#123;&#123;*/ int lena = a.num.size(); int lenb = b.num.size(); int len = lena+lenb; bigInt ret(len); long long add = 0; for(int i = 0;i&lt;len;i++)&#123; long long buf = add; for(int j = max(0,i-lenb+1);j&lt;=i&amp;&amp;j&lt;lena;j++) buf = buf+a.num[j]*b.num[i-j]; add = buf/mod; ret.num[i] = buf%mod; &#125; ret.neg = (a.neg!=b.neg); relen(ret); return ret;&#125;/*&#125;&#125;&#125;*/bigInt exec(bigInt a,int b)&#123;/*&#123;&#123;&#123;*/ bool neg = (b&lt;0); bigInt ret(a.num.size()); ret.neg = (a.neg!=neg); a.neg = false; int buf = 0; for(int i = a.num.size()-1;i&gt;=0;i--)&#123; buf = buf*mod+a.num[i]; ret.num[i] = buf/b; buf%=b; &#125; relen(ret); return ret;&#125;/*&#125;&#125;&#125;*/bigInt exec(bigInt a,bigInt b)&#123;/*&#123;&#123;&#123;*/ bigInt base = trans(1); bigInt big10 = trans(10); bigInt big0 = trans(0); bigInt ans = trans(0); bool neg = (a.neg!=b.neg); a.neg = b.neg = false; while(bigger(a,mul(b,big10))) &#123; base = mul(base,big10); b = mul(b,big10); &#125; while(!equal(base,big0)) &#123; while(bigger(a,b)) &#123; ans = add(ans,base); a = sub(a,b); &#125; b = exec(b,10); base = exec(base,10); &#125; ans.neg = neg; return ans;&#125;/*&#125;&#125;&#125;*/int Mod(bigInt a,int b)&#123; int ret = 0; for(int i = a.num.size()-1;i&gt;=0;i--)&#123; ret = ret*mod+a.num[i]; ret%=b; &#125; return ret;&#125;bigInt table[mod];int main()&#123; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序对拍器]]></title>
    <url>%2F2019%2F05%2F29%2Fskill%2Fprogram_beat%2F</url>
    <content type="text"><![CDATA[对拍器123456789101112131415g++ -std=c++11 my.cpp -o myg++ -std=c++11 data.cpp -o datag++ -std=c++11 ac.cpp -o acwhile true; do ./data &gt; in ./my &lt; in &gt; my.out ./ac &lt; in &gt; ac.out if diff my.out ac.out; then ((var++)) echo $var else printf "WA\n" exit 0 fidone]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 63]]></title>
    <url>%2F2019%2F04%2F28%2FCF%2FEducational%20Codeforces%20Round%2063%2F</url>
    <content type="text"><![CDATA[F. Delivery Oligopoly开启传送门 题目描述The whole delivery market of Berland is controlled by two rival companies: BerEx and BerPS. They both provide fast and reliable delivery services across all the cities of Berland. The map of Berland can be represented as an undirected graph. The cities are vertices and the roads are edges between them. Each pair of cities has no more than one road between them. Each road connects different cities. BerEx and BerPS are so competitive that for each pair of cities $(v,u)$ they have set up their paths from $v$ to $u$ in such a way that these two paths don’t share a single road. It is guaranteed that it was possible. Now Berland government decided to cut down the road maintenance cost by abandoning some roads. Obviously, they want to maintain as little roads as possible. However, they don’t want to break the entire delivery system. So BerEx and BerPS should still be able to have their paths between every pair of cities non-intersecting. What is the minimal number of roads Berland government can maintain? More formally, given a 2-edge connected undirected graph, what is the minimum number of edges that can be left in it so that the resulting graph is also 2-edge connected? InputThe first line contains two integers $n$ and $m$ ($3\leq n\leq14$, $n\leq m\leq \frac{n(n-1)}{2}$) — the number of cities and the number of roads between them. Each of the next 𝑚 lines contains two integers $v$ and $u$ ($1\leq v,u\leq n,v\neq u$) — the cities connected by the next road. It is guaranteed that each pair of cities has no more than one road between them. It is guaranteed that each pair of cities have at least two paths between them that don’t share a single road. OutputThe first line should contain a single integer $k$ — the minimum number of roads Berland government can maintain so that BerEx and BerPS are still able to have their paths between every pair of cities non-intersecting. The next $k$ lines should contain the list of roads which are being maintained. Each line of form “$v\ u$”, where $v$ and $u$ are cities connected by the next road. If there are multiple lists of minimum size, print any of them. The order of roads in the list doesn’t matter. Examplesinput13 31 22 33 1 output131 33 21 2 input24 51 21 42 34 31 3 output241 44 33 21 2 input36 101 22 33 13 44 55 64 62 51 63 5 output361 66 55 44 33 21 2 NoteHere are graphs from the examples, red edges are the maintained ones. 题意给你一个不超过14个节点的无向图，让你找到满足一下条件的一个子图： 包含所有点 包含尽可能少的边 子图中任意两个点存在两条完全不交的路径 让你输出一个任意符合题意的子图。 分析当时没做出来，看题解才做出来的。建议先看原题解。如下： Let’s use dynamic programming to solve this problem. We will start with a single biconnected component consisting of vertex $0$, and connect other vertices to it. So, the state of our dynamic programming will be a $mask$ of vertices that are in the same biconnected component with $0$. How can we extend a biconnected component in such a way that some other vertices are added into it, but it is still biconnected? We will add a path (possibly cyclic) that starts in some vertex $x$ belonging to the $mask$, goes through some vertices not belonging to the $mask$, and ends in some vertex $y$ belonging to the $mask$ (possibly $x=y$). If for every triple ($x,y,addmask$) we precalculate some path that starts in $x$, goes through vertices from $addmask$ and ends in $y$ (and $addmask$ does not contain neither $x$ nor $y$), then we can solve the problem in $O(3^nn^2)$: there will be $2^n$ states, for every state we will iterate on two vertices $x$ and $y$ belonging to the $mask$, and the number of possible pairs of non-intersecting masks $mask$ and $addmask$ is $O(3^n)$. The only thing that’s left is precalculating the paths for triples ($x,y,addmask$). That can be done with auxiliary dynamic programming $dp2[x][y][addmask]$ which will denote whether such a path exists. For every edge ($u,v$) of the original graph, $dp2[u][v][0]$ is true, and we can go from $dp2[x][y][addmask]$ to some state $dp2[x][z][addmask^{‘}]$, where $addmask^{‘}$ will contain all vertices from $addmask$ and vertex $y$ (and we should ensure that there is an edge ($y,z$) in the graph and the $addmask$ didn’t contain vertex $y$ earlier). We should also somehow be able to restore the paths from this dp, and we also should be careful not to choose the same edge twice (for example, if we start a path by edge ($x,y$), we should not use the same edge to return to $x$) — both these things can be done, for example, by storing next-to-last vertex in the path. 我基本是看完题解才有想法的，和题解写的一模一样，（其实不一样，我写的比标程丑）。 大体思路还是很清晰的。 首先，我们可以很轻松的发现，答案一定是很多环交在了一起构成了答案对应的子图，然后对于任何一个存在很多环相交的图来说，我们可以拆成一个环和很多很多边构成的，如下图： 同样的我们可以很轻松的得到，任何一个环都可以作为拆分后唯一的环。剩下的问题就是我们怎么找到所有的边了。也即怎么找到我们需要的所有路径。我们做以下定义。 我们找到一条从$a$到$b$的路径，并且其中包括$mask$对应的其他点，我们假设$dp2[a][b][mask]$表示是否存在一条从$a$到$b$的路径，并且还包含了$mask$点，例如： $dp2[1][3][1] = 1$表示存在一条$1-0-3$的路径 $dp2[3][5][3] = 1$表示存在一条从$3$到$5$的路径，其中包含$0$号点和$1$号点，路径可能是$3-0-1-5$，也可能是$3-1-0-5$。 对于他的转移显然比较好想，直接枚举下一个点是谁就行了。 然后我们取出任意一个节点表示当前符合答案的子图的子图。因为一个点的时候显然符合答案（因为一对都没有）。然后我们在这个子图的子图中不断的添加边构成环，最后判断得到的全图是否满足答案就行了。。。。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 14;const int maxm = 1&lt;&lt;maxn;int n,m,upper;int dp[maxm|10];//记录答案是否存在，也即当前子图是否满足条件（子图中任意两个点存在两条完全不交的路径）bool dp2[maxn][maxn][maxm];//表示是否存在一条从i到j，包含mask对应点的路径int last[maxn][maxn][maxm];//用来记录i到j中上一个点是谁，用来输出路径vector&lt;int&gt; bit[maxm|10];//表示mask中对应的点的编号vector&lt;int&gt; mat[maxm|10];//存输入的图pair&lt;int,int&gt; con[maxm|10];//表示mask对应的两个外部点，也就是路径的起点终点int addmask[maxm|10];//mask对应的外部边对应的maskvoid show_bit(int a)&#123; if(a) show_bit(a&gt;&gt;1); else return ; if(a&amp;1) cout&lt;&lt;1; else cout&lt;&lt;0;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; upper = 1&lt;&lt;n; for(int i = 0,a,b;i&lt;m;i++)&#123; cin&gt;&gt;a&gt;&gt;b; a--,b--; mat[a].push_back(b); mat[b].push_back(a); &#125; memset(dp,0x3f,sizeof dp); memset(dp2,false,sizeof dp2); for(int i = 0;i&lt;n;i++) for(auto j: mat[i])&#123; dp2[i][j][0] = 1; last[i][j][0] = i; &#125; for(int mask = 0;mask&lt;upper;mask++) for(int j = 0;j&lt;n;j++) if(mask&amp;(1&lt;&lt;j)) bit[mask].push_back(j); for(int mask = 0;mask&lt;upper;mask++)&#123; for(int i = 0;i&lt;n;i++)&#123; if(mask&amp;(1&lt;&lt;i)) continue; for(int j = 0;j&lt;n;j++)&#123; if(mask&amp;(1&lt;&lt;j)) continue; if(i==j||dp2[i][j][mask]==false) continue; for(auto z:mat[j])&#123; if(mask&amp;(1&lt;&lt;z)) continue; if(z==last[i][j][mask]) continue; if(dp2[i][z][mask|(1&lt;&lt;j)]==false)&#123; last[i][z][mask|(1&lt;&lt;j)] = j; dp2[i][z][mask|(1&lt;&lt;j)] = true; &#125; &#125; &#125; &#125; &#125; dp[1] = 0; for(int mask = 0;mask &lt; upper;mask++) &#123; for(int add = mask;add;add = (add-1)&amp;mask)&#123; int pre = add^mask; int cnt = __builtin_popcount(add)+1; if(dp[pre]+cnt&gt;=dp[mask]) continue; bool flag = false; for(auto x:bit[pre])&#123; for(auto y: bit[pre])&#123; if(dp2[x][y][add])&#123; dp[mask] = dp[pre]+cnt; con[mask] = make_pair(x,y); addmask[mask] = add; &#125; &#125; &#125; &#125; &#125; if(dp[(1&lt;&lt;n)-1]==inf) cout&lt;&lt;-1&lt;&lt;endl; else &#123; cout&lt;&lt;dp[(1&lt;&lt;n)-1]&lt;&lt;endl; int cur = (1&lt;&lt;n) - 1; while(cur!=1)&#123; int add = addmask[cur]; int x = con[cur].first; int y = con[cur].second; cur^=add; while(add)&#123; int ny = last[x][y][add]; cout&lt;&lt;y+1&lt;&lt;' '&lt;&lt;ny+1&lt;&lt;endl; y = ny; add^=(1&lt;&lt;ny); &#125; cout&lt;&lt;x+1&lt;&lt;' '&lt;&lt;y+1&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 553]]></title>
    <url>%2F2019%2F04%2F19%2FCF%2FCodeforces_Round_553%2F</url>
    <content type="text"><![CDATA[F. Sonya and Informatics开启传送门 题目描述A girl named Sonya is studying in the scientific lyceum of the Kingdom of Kremland. The teacher of computer science (Sonya’s favorite subject!) invented a task for her. Given an array $a$ of length $n$, consisting only of the numbers $0$ and $1$, and the number $k$. Exactly $k$ times the following happens: Two numbers $i$ and $j$ are chosen equiprobable such that ($1\leq i&lt;j\leq n$). The numbers in the $i$ and $j$ positions are swapped. Sonya’s task is to find the probability that after all the operations are completed, the $a$ array will be sorted in non-decreasing order. She turned to you for help. Help Sonya solve this problem. It can be shown that the desired probability is either $0$ or it can be represented as $\frac{P}{Q}$, where $P$ and $Q$ are coprime integers and $Q\not\equiv0(mod\ 10^9+7)\textscA$. InputThe first line contains two integers $n$ and $k$ ($2\leq n\leq 100,1\leq k\leq 10^9$) — the length of the array $a$ and the number of operations. The second line contains $n$ integers $a_1,a_2,\dots,a_n$ ($0\leq a_i\leq 1$) — the description of the array $a$. OutputIf the desired probability is $0$, print $0$, otherwise print the value $P\cdot Q^{-1}$ ($mod\ 10^9+7$), where $P$ and $Q$ are defined above. Examplesinpus13 2 0 1 0 output1333333336 input25 1 1 1 1 0 0 output20 input36 4 1 0 0 1 1 0 output3968493834 NoteIn the first example, all possible variants of the final array $a$, after applying exactly two operations: $(0,1,0)$, $(0,0,1)$, $(1,0,0)$, $(1,0,0)$, $(0,1,0)$, $(0,0,1)$, $(0,0,1)$, $(1,0,0)$, $(0,1,0)$. Therefore, the answer is $\frac{3}{9}=\frac{1}{3}$. In the second example, the array will not be sorted in non-decreasing order after one operation, therefore the answer is 0. 题意给你一个长度为n的01序列，每次随机从中选择两个出来，交换一下，一共这样操作k次，问你经过k次交换之后，序列变成不降($00\dots 0011\dots 11$)的概率是？ 分析首先序列里面的$0$和$1$的数量是固定的，不妨设分别有$len_a$和$len_b$个。 也就是说在交换$k$次之后要保证前$len_a$个为$0$，后$len_b$个为$1$,如下$$\underbrace{00\dots 00}_{len_a} \underbrace{11\dots 11}_{len_b}$$ 然后我们分别统计前半段后半段$0$和$1$的数量，分别定义为$a_0,a_1,b_0,b_1$。例如$$\underbrace{\underbrace{\overbrace{01010000101110100}^{a_1=7}}_{a_0=10}}_{len_a=17}\underbrace{\underbrace{\overbrace{000101111101010}^{b_1=8}}_{b_0=7}}_{len_b=15}\tag{3}$$ 然后考虑一次交换产生的效果： $b_1$增加：$a_1$和$b_0$交换，使得后半段多了一个1，例如$$\underbrace{\underbrace{\overbrace{01010000101110000}^{a_1=6}}_{a_0=11}}_{len_a=17}\underbrace{\underbrace{\overbrace{010101111101010}^{b_1=9}}_{b_0=6}}_{len_b=15}\tag{2}$$ $b_1$减少：$a_0$和$b_1$交换，使得后半段少了一个1，例如$$\underbrace{\underbrace{\overbrace{01010000101110101}^{a_1=8}}_{a_0=9}}_{len_a=17}\underbrace{\underbrace{\overbrace{000101111101000}^{b_1=7}}_{b_0=8}}_{len_b=15}\tag{1}$$ 其他情况不影响$0$和$1$的数量。 然后多次操作和一次操作怎么联系起来呢？ 看到这个数据量$n = 100$，一次变多次，一个自然的想法就是快速幂啊啊啊啊啊啊啊啊啊啊。 然后就用上面的式子构造转移矩阵，然后快速幂，就能得到有解的方案数，然后除掉总方案数就行了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9+7;long long add(long long a,long long b)&#123;return (a+b)%mod;&#125;long long mul(long long a,long long b)&#123;return a*b%mod;&#125;long long qpow(long long a,long long b = mod-2)&#123;/*&#123;&#123;&#123;*/ long long ret = 1; while(b)&#123; if(b&amp;1) ret = mul(ret,a); a = mul(a,a); b&gt;&gt;=1; &#125; return ret;&#125;/*&#125;&#125;&#125;*/const int maxm = 105,inv_2 = qpow(2);long long C(long long a)&#123; return mul(inv_2,mul(a,add(a,mod-1)));&#125;int n,k,len_a,len_b;int num[maxm];struct matrix&#123; long long num[maxm][maxm];&#125;;matrix mul(matrix a,matrix b)&#123;/*&#123;&#123;&#123;*/ matrix c; memset(c.num,0,sizeof(c.num)); for(int i = 0;i&lt;=len_b;i++) for(int j = 0;j&lt;=len_b;j++) if(a.num[i][j]) for(int k = 0;k&lt;=len_b;k++) c.num[i][k] = add(c.num[i][k],mul(a.num[i][j],b.num[j][k])); return c;&#125;/*&#125;&#125;&#125;*/matrix qpow(matrix a,long long b)&#123; matrix e; for(int i = 0;i&lt;=len_b;i++) for(int j = 0;j&lt;=len_b;j++) e.num[i][j]=(i==j); while(b)&#123; if(b&amp;1) e = mul(e,a); a = mul(a,a); b&gt;&gt;=1; &#125; return e;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); int all = C(n); for(int i = 0;i&lt;n;i++)&#123;/*&#123;&#123;&#123;*/ scanf("%d",num+i); if(num[i]) len_b++; else len_a++; &#125;/*&#125;&#125;&#125;*/ matrix base; for(int i = 0;i&lt;=len_b;i++)&#123; for(int j = max(0,i-1);j&lt;=min(len_b,i+1);j++)&#123; int b1 = j,b0 = len_b - j,a0 = len_a - b0,a1 = len_a - a0; if(i==j-1) base.num[i][j] = a0*b1; else if(i==j+1) base.num[i][j] = a1*b0; else base.num[i][j] = add(all,add(mod - a0*b1,mod - a1*b0)); &#125; &#125; int cnt = 0; for(int i = len_a;i&lt;n;i++) if(num[i]) cnt++; matrix ano; memset(ano.num,0,sizeof(ano.num)); ano.num[cnt][0] = 1; base = mul(qpow(base,k),ano); long long ans = base.num[len_b][0]; ans = mul(ans,qpow(qpow(C(n),k))); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 552]]></title>
    <url>%2F2019%2F04%2F17%2FCF%2FCodeforces_Round_552%2F</url>
    <content type="text"><![CDATA[F. Shovels Shop开启传送门 题目描述There are $n$ shovels in the nearby shop. The $i$-th shovel costs $a_i$ bourles. Misha has to buy exactly $k$ shovels. Each shovel can be bought no more than once. Misha can buy shovels by several purchases. During one purchase he can choose any subset of remaining (non-bought) shovels and buy this subset. There are also $m$ special offers in the shop. The $j$-th of them is given as a pair $(x_j,y_j)$, and it means that if Misha buys exactly $x_j$ shovels during one purchase then $y_j$ most cheapest of them are for free (i.e. he will not pay for $y_j$ most cheapest shovels during the current purchase). Misha can use any offer any (possibly, zero) number of times, but he cannot use more than one offer during one purchase (but he can buy shovels without using any offers). Your task is to calculate the minimum cost of buying $k$ shovels, if Misha buys them optimally. InputThe first line of the input contains three integers $n,m$ and $k$ ($1\leq n,m\leq 2\cdot 10^5,1\leq k\leq min(n,2000)$) - the number of shovels in the shop, the number of special offers and the number of shovels Misha has to buy, correspondingly. The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_1\leq 2\cdot 10^5$), where $a_i$ is the cost of the $i$-th shovel. The next $m$ lines contain special offers. The $j$-th of them is given as a pair of integers ($x_i,y_i$) ($1\leq y_i\leq x_i\leq n$) and means that if Misha buys exactly $x_i$ shovels during some purchase, then he can take $y_i$ most cheapest of them for free. OutputPrint one integer $-$ the minimum cost of buying $k$ shovels if Misha buys them optimally. Examplesinpus17 4 5 2 5 4 2 6 3 1 2 1 6 5 2 1 3 1 output17 input29 4 8 6 8 5 1 8 1 1 2 1 9 2 8 4 5 3 9 7 output217 input35 1 4 2 5 7 4 6 5 4 output317 NoteIn the first example Misha can buy shovels on positions 1 and 4 (both with costs 2) during the first purchase and get one of them for free using the first or the third special offer. And then he can buy shovels on positions 3 and 6 (with costs 4 and 3) during the second purchase and get the second one for free using the first or the third special offer. Then he can buy the shovel on a position 7 with cost 1. So the total cost is 4+2+1=7. In the second example Misha can buy shovels on positions 1, 2, 3, 4 and 8 (costs are 6, 8, 5, 1 and 2) and get three cheapest (with costs 5, 1 and 2) for free. And then he can buy shovels on positions 6, 7 and 9 (all with costs 1) without using any special offers. So the total cost is 6+8+1+1+1=17. In the third example Misha can buy four cheapest shovels without using any special offers and get the total cost 17. 题意zuhiul 都20了，还没有对象，然后家里人给安排了n个菇凉和他相亲，他需要挑出k个来相亲。相亲当然是男方请客，和每个妹子相亲的成本是不一样的，每个妹子都有一个固定成本，为了促进zuhiul相亲，家里人说，如果一次邀约了$x_i$个菇凉，家里就给报销这次相亲的所有菇凉中，成本最低的$y_i$个菇凉的花费，现在zuhiul想花最少的钱相完所有的亲，他最少要花多少钱呢？ 分析首先可以确定的是，我们一定找n个中最便宜的k个来相亲，因为如果不是这k个，我们一定可以合理的交换，得到一个不劣的解。 然后排序，干掉贵的那一部分。 那么如果不考虑报销的话，成本是固定的，所以剩下的问题就是怎么得到尽可能多的报销。 然后，显然是一个$n^2$的dp了。 我们可以预处理出，如果一次约j个女孩的话，可以省掉多少个女孩的费用，设为sub[j] 假设每个女孩的费用为values[i] 考虑转移，设dp[i]表示邀约前n个妹子的最小花费，那么可以得到$$dp[i] = \min_{j=1}^{i} (dp[i-j] + \sum_{k=i-j+sub[j]+1}^{i} values[k])$$ 然后对于后面的求和，可以搞一个前缀和来维护，复杂度$O(n^2)$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int maxk = 2005;const int maxm = 2e5+10;int sub[maxk];int n,m,k;int values[maxm];long long sum[maxm];int ans[maxk];long long cost[maxk];int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i = 1;i&lt;=n;i++) scanf("%d",values+i); sort(values+1,values+n+1); for(int i = 1;i&lt;=n;i++) sum[i] = sum[i-1]+values[i]; while(m--) &#123;/*&#123;&#123;&#123;*/ int a,b; scanf("%d%d",&amp;a,&amp;b); if(a&gt;k) continue; sub[a] = max(sub[a],b); &#125;/*&#125;&#125;&#125;*/ for(int i = 1;i&lt;=k;i++) sub[i] = max(sub[i],sub[i-1]); memset(cost,0x3f,sizeof(cost)); cost[0] = 0; for(int i = 1;i&lt;=k;i++)&#123; cost[i] = sum[i]; for(int j = 1;j&lt;=i;j++)&#123; cost[i] = min(cost[i],cost[i-j]+sum[i]-sum[i-j+sub[j]]); &#125; &#125; printf("%lld\n",cost[k]); return 0;&#125; G. Minimum Possible LCM开启传送门 题目描述You are given an array $a$ consisting of $n$ integers $a_1,a_2,\dots,a_n$. Your problem is to find such pair of indices $i,j (1\leq i&lt;j\leq n)$ that $lcm(a_i,a_j)$ is minimum possible. $lcm(x,y)$ is the least common multiple of $x$ and $y$ (minimum positive number such that both $x$ and $y$ are divisors of this number). ###Input The first line of the input contains one integer $n$ ($2\leq n\leq10^6$) — the number of elements in $a$. The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_i\leq 10^7$), where $a_i$ is the $i$-th element of $a$. OutputPrint two integers $i$ and $j$ ($1\leq i&lt;j\leq n$) such that the value of $lcm(a_i,a_j)$ is minimum among all valid pairs $i,j$. If there are multiple answers, you can print any. Examplesinpus15 2 4 8 3 6 output11 2 input25 5 2 11 3 7 output22 4 input36 2 5 10 1 10 2 output31 4 题意zuhiul有很多妹子，今天他想找两个妹子出去吃饭，每个妹子都有一个权值，他今天要花的钱等于这两个妹子权值的lcm，他想花尽可能少的钱，他该约哪两个妹子呢？ 分析我们考虑一下那种情况可以构成解。 首先对于重复的数据，我们可以干掉，因为相同值的lcm等于本身，所以我们可以把相同的权值干掉，然后剩下的数据都是不同的。 然后我们考虑权值都不相同的时候怎么构成解。 首先，这两个数肯定有一个gcd，哪怕gcd = 1，然后我们考虑一下，这$n*(n-1)&gt;&gt;1$这么多对数中，哪些对可以构成解，一个显而易见的想法就是，我们可以枚举gcd。 然后我们枚举这个gcd的所有倍数，这样能不重不漏的枚举出所有对数，然后我们考虑怎么减少枚举量。假设当前的$gcd=x$,因为前一步保证了没有相同的数据，所以我们只要找到最小的$i,j$使得$i\%x==0\&amp;\&amp;j\%x==0$，然后就用这两个数更新一下答案就行了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+10;int n;int app[maxm];struct p&#123; long long ans; int ind1,ind2; bool operator&lt;(const p a) const &#123; return ans&lt;a.ans; &#125;&#125;;int main()&#123; scanf("%d",&amp;n); p ans = &#123;1000000000000000000ll,-1,-1&#125;; for(int i = 1,buf;i&lt;=n;i++)&#123; scanf("%d",&amp;buf); if(app[buf]) ans = min(ans,&#123;buf,app[buf],i&#125;); app[buf] = i; &#125; for(int i = 1;i&lt;maxm;i++)&#123; int buf[3] = &#123;0&#125;; for(int j = i;j&lt;maxm;j+=i)&#123; if(app[j])&#123; buf[++buf[0]] = j; if(buf[0]==2)&#123; ans = min(ans,&#123;1ll*buf[1]*buf[2]/i,app[buf[1]],app[buf[2]]&#125;); break; &#125; &#125; &#125; &#125; if(ans.ind1&gt;ans.ind2) swap(ans.ind1,ans.ind2); printf("%d %d\n",ans.ind1,ans.ind2); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 551]]></title>
    <url>%2F2019%2F04%2F14%2FCF%2FCodeforces_Round_551%2F</url>
    <content type="text"><![CDATA[A. Serval and Bus开启传送门 题目描述It is raining heavily. But this is the first day for Serval, who just became 3 years old, to go to the kindergarten. Unfortunately, he lives far from kindergarten, and his father is too busy to drive him there. The only choice for this poor little boy is to wait for a bus on this rainy day. Under such circumstances, the poor boy will use the first bus he sees no matter where it goes. If several buses come at the same time, he will choose one randomly. Serval will go to the bus station at time $t$, and there are $n$ bus routes which stop at this station. For the $i$-th bus route, the first bus arrives at time $s_i$ minutes, and each bus of this route comes $d_i$ minutes later than the previous one. As Serval’s best friend, you wonder which bus route will he get on. If several buses arrive at the same time, you can print any of them. InputThe first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station. Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route. OutputPrint one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them. Examplesinput12 2 6 4 9 5 output11 input25 5 3 3 2 5 5 6 4 9 6 1 output23 input33 7 2 2 2 3 2 4 output31 题意zuhiul很忙，他要约妹子，他一共有$n$个妹子要约，但是他$t$天后才有空，妹子们也不是每天都有时间，但是妹子都是周期性有时间，比如，第$i$个妹子，$s_i$天之后才有时间，而且每$d_i$天就会再次出线，现在问你，zuhiul最早会和哪个妹子约会，如果会和多个妹子约会，只需要输出任意一个妹子就行了。 分析只需要枚举每个妹子，然后看一下这个妹子什么时候最早可以邀约，然后算一下min就可以了 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 105;int s[maxm],d[maxm];int main()&#123; int n,t; cin&gt;&gt;n&gt;&gt;t; int ind,sum = 1e8; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;s[i]&gt;&gt;d[i]; if(s[i]&gt;=t)&#123; if(sum&gt;s[i])&#123; sum = s[i]; ind = i; &#125; &#125;else &#123; int nee = t-s[i]; if(nee%d[i]!=0) nee = (nee/d[i]+1)*d[i]; nee+=s[i]; if(nee&lt;sum)&#123; sum = nee; ind = i; &#125; &#125; &#125; cout&lt;&lt;ind&lt;&lt;endl; return 0;&#125; B. Serval and Toy Bricks开启传送门 题目描述Luckily, Serval got onto the right bus, and he came to the kindergarten on time. After coming to kindergarten, he found the toy bricks very funny. He has a special interest to create difficult problems for others to solve. This time, with many $1\times 1\times 1$ toy bricks, he builds up a 3-dimensional object. We can describe this object with a $n\times m$ matrix, such that in each cell $(i,j)$ , there are $h_{i,j}$ bricks standing on the top of each other. However, Serval doesn’t give you any $h_{i,j}$, and just give you the front view, left view, and the top view of this object, and he is now asking you to restore the object. Note that in the front view, there are $m$ columns, and in the $i$-th of them, the height is the maximum of $h_{1,i},h_{2,i},\dots,h_{n,i}$. It is similar for the left view, where there are $n$ columns. And in the top view, there is an 𝑛×𝑚 matrix $t_{i,j}$, where $t_{i,j}$ is 0 or 1. If $t_{i,j}$ equals 1, that means $h_{i,j}$&gt;0, otherwise, $h_{i,j}$=0. However, Serval is very lonely because others are bored about his unsolvable problems before, and refused to solve this one, although this time he promises there will be at least one object satisfying all the views. As his best friend, can you have a try? InputThe first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station. Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route. OutputPrint one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them. Examplesinput13 7 3 2 3 0 0 2 0 1 2 1 3 1 0 0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 output11 0 0 0 2 0 0 0 0 0 0 0 0 1 2 3 0 0 0 0 0 input24 5 5 3 5 2 0 4 4 2 5 4 0 0 0 0 1 1 0 1 0 0 0 1 0 0 0 1 1 1 0 0 output20 0 0 0 4 1 0 2 0 0 0 5 0 0 0 3 4 1 0 0 Note The graph above illustrates the object in the first example. The first graph illustrates the object in the example output for the second example, and the second graph shows the three-view drawing of it. 题意zuhiul和妹子玩游戏，妹子搭了一个积木，然后zuhiul猜积木长啥样，zuhiul必然不会，于是小姐姐放过了他，告诉了他现在的主视图，侧视图和俯视图，然后让zuhiul猜，zuhiul还是不会，但是为了脸面不能说不会，然后来问你了。你需要输出一种可能的解满足这个三视图。 分析告诉了主视图和左视图，相当于限制了最大值，告诉俯视图相当于告诉哪里可能有方块。然后枚举俯视图的每个位置，输出答案即可。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxm = 105;int hang[maxm],lie[maxm],nouse;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;nouse; for(int i = 0;i&lt;m;i++) cin&gt;&gt;hang[i]; for(int i = 0;i&lt;n;i++) cin&gt;&gt;lie[i]; for(int i = 0;i&lt;n;i++)&#123; for(int j = 0,a;j&lt;m;j++)&#123; cin&gt;&gt;a; if(a) cout&lt;&lt;min(lie[i],hang[j])&lt;&lt;' '; else cout&lt;&lt;0&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; C. Serval and Parenthesis Sequence开启传送门 题目描述Serval soon said goodbye to Japari kindergarten, and began his life in Japari Primary School. In his favorite math class, the teacher taught him the following interesting definitions. A parenthesis sequence is a string, containing only characters “(“ and “)”. A correct parenthesis sequence is a parenthesis sequence that can be transformed into a correct arithmetic expression by inserting characters “1” and “+” between the original characters of the sequence. For example, parenthesis sequences “()()”, “(())” are correct (the resulting expressions are: “(1+1)+(1+1)”, “((1+1)+1)”), while “)(“ and “)” are not. Note that the empty string is a correct parenthesis sequence by definition. We define that $|s|$ as the length of string $s$. A strict prefix $s[1\dots l]$ (1 ≤ $l$ &lt; $|s|$) of a string $s=s_{1}s_{2}\dots s_{|s|}$ is string $s_{1}s_{2}\dots s_{l}$. Note that the empty string and the whole string are not strict prefixes of any string by the definition. Having learned these definitions, he comes up with a new problem. He writes down a string $s$ containing only characters “(“, “)” and “?”. And what he is going to do, is to replace each of the “?” in $s$ independently by one of “(“ and “)” to make all strict prefixes of the new sequence not a correct parenthesis sequence, while the new sequence should be a correct parenthesis sequence. After all, he is just a primary school student so this problem is too hard for him to solve. As his best friend, can you help him to replace the question marks? If there are many solutions, any of them is acceptable. InputThe first line contains a single integer $|s|$ (1≤$|s|$≤$3\cdot 10^5$), the length of the string. The second line contains a string $s$, containing only “(“, “)” and “?”. OutputA single line contains a string representing the answer. If there are many solutions, any of them is acceptable. If there is no answer, print a single line containing “:(“ (without the quotes). Examplesinput16(????? output1(()()) input210(???(???(? output2:( NoteIt can be proved that there is no solution for the second sample, so print “:(“. 题意给你一堆左括号右括号和问号，问你能否把问号变成左括号或者右括号，使得这个变成一个括号匹配的序列，并且序列的任何前缀不是一个括号匹配序列。 分析显然对于后一个条件，我们只需要让最左边的左括号和最右边的右括号匹配就行了，然后中间是一个括号匹配序列就行了。然后填充的时候贪心的让左边填充左括号,右边填充右括号,然后check一下就行了. 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int len;const int maxm = 3e5+10;char que[maxm];void NO()&#123; cout&lt;&lt;":("&lt;&lt;endl; exit(0);&#125;int main()&#123; cin&gt;&gt;len&gt;&gt;que; if(len&amp;1) NO(); if(que[0]=='?') que[0] = '('; if(que[len-1]=='?') que[len-1] = ')'; if(que[0]!='(') NO(); if(que[len-1]!=')') NO(); if(len==2) &#123; puts("()"); return 0; &#125; int l = 0,r = 0,has = 0; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='(') l++; else if(que[i]==')') r++; else has++; &#125; if(abs(l-r)&gt;has) NO(); l = (len-2)/2 - l; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='?') &#123; if(l)&#123; que[i] = '('; l--; &#125;else que[i] = ')'; &#125; &#125; has = 0; for(int i = 1;i&lt;len-1;i++)&#123; if(que[i]=='(') has++; else has--; if(has&lt;0) NO(); &#125; puts(que); return 0;&#125; D. Serval and Rooted Tree开启传送门 题目描述Now Serval is a junior high school student in Japari Middle School, and he is still thrilled on math as before. As a talented boy in mathematics, he likes to play with numbers. This time, he wants to play with numbers on a rooted tree. A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a node $v$ is the last different from $v$ vertex on the path from the root to the vertex $v$. Children of vertex $v$ are all nodes for which $v$ is the parent. A vertex is a leaf if it has no children. The rooted tree Serval owns has $n$ nodes, node 1 is the root. Serval will write some numbers into all nodes of the tree. However, there are some restrictions. Each of the nodes except leaves has an operation max or min written in it, indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons, respectively. Assume that there are $k$ leaves in the tree. Serval wants to put integers $1,2,\dots,k$ to the $k$ leaves (each number should be used exactly once). He loves large numbers, so he wants to maximize the number in the root. As his best friend, can you help him? InputThe first line contains an integer $n$ (2≤$n$≤$3\cdot 10^5$), the size of the tree. The second line contains $n$ integers, the $i$-th of them represents the operation in the node $i$. 0 represents min and 1 represents max. If the node is a leaf, there is still a number of 0 or 1, but you can ignore it. The third line contains $n-1$ integers $f_2,f_3,\dots,f_n$ (1≤$f_i≤$i-1$), where $f_i$ represents the parent of the node $i$. OutputOutput one integer $-$ the maximum possible number in the root of the tree. Examplesinput16 1 0 1 1 0 1 1 2 2 2 2 output11 input25 1 0 1 0 1 1 1 1 1 output24 input38 1 0 0 1 0 1 1 0 1 1 2 2 3 3 3 output34 input49 1 1 0 0 1 0 1 0 1 1 1 2 2 3 3 4 4 output45 NotePictures below explain the examples. The numbers written in the middle of the nodes are their indices, and the numbers written on the top are the numbers written in the nodes. In the first example, no matter how you arrange the numbers, the answer is $1$. In the second example, no matter how you arrange the numbers, the answer is $4$. In the third example, one of the best solution to achieve $4$ is to arrange $4$ and $5$ to nodes $4$ and $5$. In the fourth example, the best solution is to arrange $5$ to node $5$. 题意给你一颗有根树，每个非叶节点上有一个函数，可能为min或者max，你需要在k个叶节点上填上$1,2,\dots,k$,使得经过非叶节点的操作之后，根节点的值最大。 分析显然是要分析函数的作用。 如果是取max，说明所有的子节点中，我们可以把某一个子节点的值取到最大，然后其他的节点全塞垃圾值。 如果是取min，说明所有子节点都起作用，说明我们对于每个子节点都要尽可能的大。 然后就可以得到，max的策略是，找到孙子节点最少的子节点，填充大值，min的策略是，对所有子节点求和。 然后这样得到的就是所有对答案有贡献的节点数，然后用总结点数减去贡献节点数就是答案。 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 3e5+10;int n,cnt;int maxn[maxm];vector&lt;int&gt; son[maxm];int dfs(int a)&#123; if(son[a].size()==0)&#123; cnt++; return 1; &#125; if(maxn[a])&#123; int minm = 1e8; for(int i:son[a]) minm = min(minm,dfs(i)); return minm; &#125; int sum = 0; for(int i:son[a]) sum+=dfs(i); return sum;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++) cin&gt;&gt;maxn[i]; for(int i = 2,pre;i&lt;=n;i++)&#123; cin&gt;&gt;pre; son[pre].push_back(i); &#125; int nouse = dfs(1); cout&lt;&lt;cnt - nouse+1&lt;&lt;endl; return 0;&#125; E. Serval and Snake开启传送门 题目描述This is an interactive problem. Now Serval is a senior high school student in Japari Middle School. However, on the way to the school, he must go across a pond, in which there is a dangerous snake. The pond can be represented as a $n\times n$ grid. The snake has a head and a tail in different cells, and its body is a series of adjacent cells connecting the head and the tail without self-intersecting. If Serval hits its head or tail, the snake will bite him and he will die. Luckily, he has a special device which can answer the following question: you can pick a rectangle, it will tell you the number of times one needs to cross the border of the rectangle walking cell by cell along the snake from the head to the tail. The pictures below show a possible snake and a possible query to it, which will get an answer of $4$. Today Serval got up too late and only have time to make 2019 queries. As his best friend, can you help him find the positions of the head and the tail? Note that two cells are adjacent if and only if they have a common edge in the grid, and a snake can have a body of length 0, that means it only has adjacent head and tail. Also note that the snake is sleeping, so it won’t move while Serval using his device. And what’s obvious is that the snake position does not depend on your queries. InputThe first line contains a single integer $n$ (2≤$n$≤1000) $-$ the size of the grid. OutputWhen you are ready to answer, you should print ! x1 y1 x2 y2, where $(x_1,y_1)$ represents the position of the head and $(x_2,y_2)$ represents the position of the tail. You can print head and tail in any order. InteractionTo make a query, you should print ? x1 y1 x2 y2 (1≤$x_1$≤$x_2$≤𝑛, 1≤$y_1$≤$y_2$≤$n$), representing a rectangle consisting of all cells $(x,y)$ such that $x_1$≤$x$≤$x_2$ and $y_1$≤$y$≤$y_2$. You will get a single integer as the answer. After printing a query, do not forget to output the end of line and flush the output, otherwise you will get Idleness limit exceeded. To do this, use: fflush(stdout) or cout.flush() in C++; System.out.flush() in Java; flush(output) in Pascal; stdout.flush() in Python;see documentation for other languages. Answer $-1$ instead of a valid answer means that you made an invalid query or exceeded the maximum number of queries. Exit immediately after receiving $-1$ and you will see Wrong answer verdict. Otherwise you can get an arbitrary verdict because your solution will continue to read from a closed stream. If your program cannot find out the head and tail of the snake correctly, you will also get a Wrong Answer verdict. HacksTo make a hack, print a single integer $n$ (2≤$n$≤1000) in the first line, indicating the size of the grid. Then print an integer $k$ (2≤$k$≤𝑛2) in the second line, indicating the length of the snake. In the next $k$ lines, print $k$ pairs of integers $x_i,y_i$ (1≤$x_i,y_i$≤𝑛), each pair in a single line, indicating the $i$-th cell of snake, such that the adjacent pairs are adjacent, and all $k$ pairs are distinct. Examplesinput12 1 0 0 output1? 1 1 1 1 ? 1 2 1 2 ? 2 2 2 2 ! 1 1 2 1 input23 2 0 output2? 2 2 2 2 ? 2 1 2 3 ! 2 1 2 3 Note The pictures above show our queries and the answers in the first example. We first made a query for (1,1) and got an answer 1, then found that it must be connected to exactly one other cell. Then we made a query for (1,2) and got an answer of 0, then knew that the snake never entered it. So the cell connected to (1,1) must be (2,1). Then we made a query for (2,2) and got an answer 0, then knew that it never entered (2,2) as well. So the snake cannot leave (2,1), which implies that the answer is (1,1) and (2,1). The pictures above show our queries and the answers in the second example. By making query to (2,2) and receiving 2, we found that the snake occupies (2,2). And by making query to rectangle from (2,1) to (2,3) and receiving answer 0, we knew that it never goes out of the rectangle from (2,1) to (2,3). Since the first answer is 2, both (2,1) and (2,3) must be occupied but none of others, so the answer is (2,1) and (2,3). 题意现在有一条蛇在一个方格图中，你可以给出不超过2019次询问，每次询问一个矩形，回答是，你用这个矩形去切蛇，可以得到这个蛇被切了多少刀，现在问你蛇头和蛇尾的位置。 分析首先我们可以观察到，当一个矩形切下去之后发现切了奇数刀，那么可以有必然存在一个头或者尾在矩形中。 然后我们可以用$(n-1)&lt;&lt;1$次询问得到所有的行和列对应的切的次数。 然后可以证明的是，所有的数据中必然存在奇数。反证法易得。 然后可以证明奇数对应的行或者列左右必然存在头或者尾。 所以可以得到一个很直观的$O(6n)$的做法，$2n$用来寻找，剩下的$4n$来搜索答案。但是这必然会超过2019. 考虑哪些步骤可以优化？ $2n$不可优化，必然就只能优化搜索过程。 需要注意的是，可能存在行或者列不存在奇数的情况，稍微分析可以得到这种情况的特点了，头和尾在同一行或者同一列中。 我们考虑到，我们只用考虑奇偶的情况，而不用考虑具体值。 因为奇偶的加减特性，我们可以二分这个答案。 除此之外，如果行和列都有奇数值，那么可以得到行和列对应的四个点中，两个点是答案，枚举任何一个就可以得到答案。 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1005;int n;vector&lt;int&gt; r,c;int que(int u,int d,int l,int r)&#123; printf("? %d %d %d %d\n",u,l,d,r); fflush(stdout); int nouse; scanf("%d",&amp;nouse); return nouse&amp;1;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1;i&lt;=n;i++) if(que(i,i,1,n)) r.push_back(i); for(int i = 1;i&lt;=n;i++) if(que(1,n,i,i)) c.push_back(i); assert(r.size()+c.size()&gt;=2); if(c.empty()||r.empty())&#123; bool change = false; if(c.empty()) &#123; swap(r,c); change = true; &#125; int l = 1,r = n; while(l&lt;r)&#123; int mid = l+r&gt;&gt;1; int upper = l,down = mid,left = c[0],right = c[0]; if(change) swap(left,upper),swap(down,right); if(que(upper,down,left,right)) r = mid; else l = mid+1; &#125; if(!change) printf("! %d %d %d %d\n",l,c[1],l,c[0]); else printf("! %d %d %d %d\n",c[0],l,c[1],l); fflush(stdout); return 0; &#125; if(que(r[0],r[0],c[0],c[0])) printf("! %d %d %d %d\n",r[0],c[0],r[1],c[1]); else printf("! %d %d %d %d\n",r[0],c[1],r[1],c[0]); fflush(stdout); return 0;&#125; F. Serval and Bonus Problem开启传送门 题目描述Getting closer and closer to a mathematician, Serval becomes a university student on math major in Japari University. On the Calculus class, his teacher taught him how to calculate the expected length of a random subsegment of a given segment. Then he left a bonus problem as homework, with the award of a garage kit from IOI. The bonus is to extend this problem to the general case as follows. You are given a segment with length $l$. We randomly choose $n$ segments by choosing two points (maybe with non-integer coordinates) from the given segment equiprobably and the interval between the two points forms a segment. You are given the number of random segments $n$, and another integer $k$. The $2n$ endpoints of the chosen segments split the segment into ($2n+1$) intervals. Your task is to calculate the expected total length of those intervals that are covered by at least $k$ segments of the $n$ random segments. You should find the answer modulo $998244353$. InputFirst line contains three space-separated positive integers 𝑛, 𝑘 and 𝑙 ($1\leq k\leq n\leq 2000,1\leq l\leq 10^9$). OutputOutput one integer — the expected total length of all the intervals covered by at least $k$ segments of the $n$ random segments modulo $998244353$. Formally, let $M=998244353$. It can be shown that the answer can be expressed as an irreducible fraction $\frac{p}{q}$, where $p$ and $q$ are integers and $q\not\equiv0(modM)$. Output the integer equal to $p\cdot q^{-1}mod\ M$. In other words, output such an integer $x$ that $0\leq x&lt;M$ and $x\cdot q\equiv p(mod\ M)$. Examplesinpus11 1 1 output1332748118 input26 2 1 output2760234711 input37 5 3 output3223383352 input497 31 9984524 output4267137618 NoteIn the first example, the expected total length is $\int_0^1 \int_0^1 |x-y|\ dx\ dy = \frac{1}{3} $, and $\frac{1}{3}$ modulo $998244353$ is $332748118$. 题意长度为l的线段，随机选取n个线段，线段中至少被n个线段中k个线段覆盖的长度期望。 分析说实话我当时没做出来，看了题解才知道怎么做的，所以强烈建议看官方的题解。我这里也贴出来，感兴趣的可以看一下。 Without loss of generality, assume that $l$=1. For a segment covering, the total length of the legal intervals is the probability that we choose another point $P$ on this segment randomly such that it is in the legal intervals. Since all $2n+1$ points ($P$ and the endpoints of each segment) are chosen randomly and independently, we only need to find the probability that point $P$ is in the legal intervals. Note that only the order of these $2n+1$ points make sense. Because the points are chosen in the segment, the probability that some of them coincide is $0$, so we can assume that all points do not coincide. Now the problem is, how to calculate the number of arrangements that $P$ is between at least $k$ pairs of endpoints. It can be solved by dynamic programming in time complexity of $O(n^2)$. We define $f(i,j,x)$ as the number of arrangements for the first $i$ positions, with $j$ points haven’t been matched, and $P$ appeared $x$ times (obviously $x=0$ or $1$). So we can get three different types of transition for the $i$-th position below: Place $P$ at $i$-th position (if $j\geq k$): $f(i-1,j,0)\rightarrow f(i,j,1)$ Start a new segment (if $i+j+x&lt;2n$): $f(i-1,j-1,x)\rightarrow f(i,j,x)$ Match a started segment, note that we have 𝑗 choices of segments:$f(i-1,j+1,x)\times(j+1)\rightarrow f(i,j,x)$ Then $f(2n+1,0,1)$ is the number of legal arrangements. Obviously, the total number of arrangements is $(2n+1)!$. However, there are 𝑛 pairs of endpoints whose indices can be swapped, and the indices 𝑛 segments can be rearranged. So the final answer is $\frac{f(2n+1,0,1)\times n!\times 2^n}{(2n+1)!}$. 可能是受了题解的影响，后来也没想出来其他解法。 这里讲一下题解怎么做的。 首先我们可以发现，长度和答案成正比，也就是说如果长度为1的时候答案是a，那么长度为2的时候答案就是2a%mod. 然后我们不妨设长度为1，最后答案乘上l就行了。 然后因为我们要找到至少被线段覆盖k次的所有点，所以我们不如加上一个虚拟点，这样就一共有了$(n&lt;&lt;1|1)$个点，然后需要判断这个虚拟点被多少条线段覆盖了，如果覆盖次数超过k次，就说明可以统计进答案。然后就可以发现，所有点是随机取的，所以我们假设所有点不会重合，那么所有点就可以离散成一个序列。然后就可以统计k的覆盖次数。 接下来就是dp，我们设$dp[i][j][flag]$表示序列中前i个点，其中到目前为止有j条线段左节点出线了，但是右节点没有出现，也就是说当前这个点被覆盖了j次，flag表示虚拟点是否出现了。然后考虑转移： 当前节点是虚拟节点 如果这个需要统计进入答案，也就是说明当前节点需要被覆盖k次及以上，所以 $j\geq k$ $dp[i][j][1]+=dp[i-1][j][0]$ 当前节点是一个线段的左端点 也就是说左节点数量增加，被覆盖次数增加，但是不会影响虚拟节点的状态 $dp[i][j+1][flag]+=dp[i-1][j][flag]$ 当前节点是一个线段的右端点 也就是说右节点数量增加，被覆盖次数减少，但是不会影响虚拟节点的状态,注意右端点可能会有j个可能 $dp[i][j-1][flag]+=dp[i-1][j][flag]*j$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const long long mod = 998244353;const int maxm = 2345;inline long long add(long long a,long long b)&#123;return (a+b)%mod;&#125;inline long long mul(long long a,long long b)&#123;return a*b%mod;&#125;inline long long fac(long long a) &#123;return a==1?1:mul(a,fac(a-1));&#125;inline long long qpow(long long a,long long b = mod-2)&#123;/*&#123;&#123;&#123;*/ long long ret = 1; while(b)&#123; if(b&amp;1) ret = mul(ret,a); a = mul(a,a); b&gt;&gt;=1; &#125; return ret;&#125;/*&#125;&#125;&#125;*/long long n,k,l;long long dp[maxm&lt;&lt;1][maxm][2];int main()&#123; scanf("%lld%lld%lld",&amp;n,&amp;k,&amp;l); dp[0][0][0] = 1; for(int i = 1;i&lt;=(n&lt;&lt;1|1);i++) for(int j = 0;j&lt;=n;j++)&#123; if(j&gt;=k) dp[i][j][1] = add(dp[i][j][1],dp[i-1][j][0]); for(int flag = 0;flag&lt;2;flag++) if(dp[i-1][j][flag])&#123; if(j) dp[i][j-1][flag] = add(dp[i][j-1][flag],mul(dp[i-1][j][flag],j)); if(i+(j+1)-(1-flag)&lt;=(n&lt;&lt;1|1)) dp[i][j+1][flag] = add(dp[i][j+1][flag],dp[i-1][j][flag]); &#125; &#125; int ans = mul(dp[n&lt;&lt;1|1][0][1],qpow(2,n)); ans = mul(mul(ans,l),mul(fac(n),qpow(fac(n&lt;&lt;1|1)))); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[factorio]]></title>
    <url>%2F2019%2F03%2F31%2Ffactorio%2F</url>
    <content type="text"><![CDATA[level 1]]></content>
      <tags>
        <tag>factorio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试]]></title>
    <url>%2F2019%2F02%2F21%2Fgluten%2Fgluten_tt%2F</url>
    <content type="text"><![CDATA[头条面试回忆录废话这两天参加了头条的面试,总体来说,感觉不错,公司效率很高… 一面当天上午投的简历,下午让我第二天面试,时间很紧,很多东西都没来得及准备…. 1.自我介绍一下(balabalabala) 2.学过操作系统和计算机网络吗?(网络学了,操作系统下学期开,其实我很想说操作系统自学了,您可以问……) 3.说一下tcp和udp的区别(balabalabala) 2.1那个快?为什么?(udp快,因为三次握手四次挥手会占用cpu时间?) 2.2去掉三次握手四次挥手那个快?(不知道) 4.写两个题吧 3.1 给你一个数字矩阵,每行每列都是增序,问你某个值是否存在(剑指offer原题,我100%做过,但是我忘了怎么做的,只知道从角上枚举,然后先说了一下从右下角枚举,说不对,然后换成右上角,没啥问题….) 3.2 给一个矩阵,四联通,找到一个最长上升子序列(简单dp,写完就过了) 3.2.1 能把路径输出一下吗?(记录前驱….) 3.2.2 能把前驱数组去掉吗?(可以,瞎搞一下就行了…..) 4.闲聊(emmmmm) 二面二面感觉更严格,感觉答的不好….. 1.自我介绍(balabalabala) 2.有什么数据结构可以做到查询和插入都是o(1)的?(第一反映,显然不可能啊,这不是不可调和的矛盾吗?面试官说:知道hash吗?哇,感觉被鄙视了,确实傻了) 3.给你n个有序链表(从大到小),怎么找到这n个链表的前K大,(先取出每个链表的最大,然后建最大堆,然后每次取出堆顶,然后取出对应链表的后续元素,加入堆,然后一次操作,直到有k个元素) 3.1 复杂度多少?(o(n+klogn)) 3.2 n是怎么来的?(建堆时间) 3.3 能证明一下吗?(假设堆是用类树状数组的结构维护,先把数据随机放进来,然后每次从大到小枚举一个下标ind,比较当前位置ind和(ind&gt;&gt;1),然后根据大小关系交换一下,可以证明每次都是两个数比较,并且最多有n次比较,所以o(n)) 4.写两个题吧 2.1 给你一个字典,给你一个询问串,问你能否用字典中的某些单词(每个单词只能用一次),构成询问串.(想复杂了,一直在想怎么优化,后来才知道直接暴力就行,我当时还傻乎乎的用了lower_bound企图缩小范围,结果返回结果还死活不对,搞了30分钟才搞定,感觉要凉) 2.2 可能是看我太菜,没问第二道题,感觉好像对我不感兴趣就溜了??? 三面不知道自己怎么活过二面的……. 1.聊天,纯聊天,可能是怕我太紧张,感觉面试官很好 2.提出自我介绍被拒绝……. 3.简单说一下项目,(也不用详细说,因为项目就是很简单……) 4.有啥很厉害的技术要说明的吗?(没有……) 5.我们写两个题吧 5.1 给你一个无根树,让你转化成有根树,使得树的深度最小(一眼直径的中点,写了一下,好像有点问题,我问他我是调一下还是?他说不用调了,想法没啥大问题) 5.2 初始位置0,速度1,两个操作 1.position+=spead,spead*=2 2.spead&gt;0,spead = -1;else spead = 1 问你最少操作几次,使得,从0到x 我第一想法二进制拆分,然后瞎搞,写了一下,没啥大问题 复杂度?(32^2?) 怎么证明,我说每次考虑最高位的1,然后瞎搞一下balabalabala 说正解是dp,比我复杂,emmmmm…….. 6.浏览器输入baidu.com会发生啥?(balabalabala,昨天看过,不知道说的对不对) 7.你有啥觉得自己的技术亮点要说吗?(感觉瞎bb都能加分,但是我怂,老老实实说自己没啥技能点……) 8.你想过一些大的厂商,背后的技术部门都是怎么运行的吗?(不知道……..) 9.面试官可能觉得没啥聊的了,就放我走了…… 总结总的来说,面试官还是很和蔼的,有些问题还会引导你向正确的方向思考,问题都不难,好好准备应该好过,就这样吧…….]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 276 Primitive Triangles]]></title>
    <url>%2F2019%2F01%2F17%2FPE%2FPE276%2FPE276%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Consider the triangles with integer sides $a, b$ and $c$ with $a \leq b \leq c$.An integer sided triangle $(a,b,c)$ is called primitive if $gcd(a,b,c)=1$.How many primitive integer sided triangles exist with a perimeter not exceeding $10,000,000$? 题意问你存在多少个边长是整数的三角形,并且满足三边长的gcd为1,周长不超过$1e7$. 分析有一个比较奇奇怪怪的结论 我直接把结论搬过来$\dots$ \begin{eqnarray} F(n) = \begin{cases} \lfloor\frac{(n+3)^2+24}{48}\rfloor\ \ \ \ &amp;n\ \ is\ \ odd\\ \lfloor\frac{n^2+24}{48}\rfloor\ \ \ \ &amp;n\ \ is\ \ even\ \end{cases}\end{eqnarray} 这个结论说的是,周长为$n$的边长都是整数的三角形的数量.然后我们可以预处理出所有的周长为$n$的数量出来,然后我们怎么保证gcd呢,比较好想的就是容斥,我们容斥掉所有gcd不是1的就行了,也就是说我们用周长为$2\cdot n,3\cdot n,\dots$的减去周长为$n$的就行啦啦啦 给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+1;long long num[maxm];long long get(long long a)&#123; if(a&amp;1) return ((a+3)*(a+3)+24)/48; return (a*a+24)/48;&#125;void init()&#123;//预处理出每个周长对应的三角形数量,容斥得到正确的数量 for(int i = 1;i&lt;maxm;i++) num[i] = get(i); for(int i = 1;i&lt;maxm;i++) for(int j = i&lt;&lt;1;j&lt;maxm;j+=i) num[j]-=num[i];&#125;int main()&#123; init(); long long ans = 0; for(int i = 1;i&lt;maxm;i++) ans+=num[i]; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 643 2-Friendly]]></title>
    <url>%2F2019%2F01%2F09%2FPE%2FPE643%2FPE643%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Two positive integers $a$ and $b$ are 2-friendly when $gcd(a,b)=2^t,t&gt;0$. For example, $24$ and $40$ are 2-friendly because $gcd(24,40)=8=2^3$ while $24$ and $36$ are not because $gcd(24,36)=12=2^2\cdot 3$ not a power of $2$. Let $f(n)$ be the number of pairs, $(p,q)$, of positive integers with $1\leq p&lt;q\leq n$ such that $p$ and $q$ are 2-friendly. You are given $f(10^2)=1031$ and $f(10^6)=321418433$ modulo $1000000007$ . Find $f(10^{11})$ modulo $1000000007$. 题意问你所有满足$1\leq p&lt;q\leq 1e11$,并且$gcd(p,q)==2^t$的对数 分析显然可以对于每个$2^t$单独考虑,不妨设$2^t = x$,可以得到 $$ans = \sum_{x = 2的幂}^{upper}\sum_{i=1}^{upper/x} \varphi(i)$$ 显然有 ： $\varphi(i) \star I = id$ 。我们记 $S(n) = \sum_{i=1}^{n} \varphi(i)$ 。 对于上述卷积式，两边求和有： $$\sum_{i=1}^{n} id(i) = \sum_{i=1}^{n} \sum_{d|i} I(d) \cdot \varphi(\frac{i}{d})$$ $$\sum_{i=1}^{n} id(i) = \sum_{d=1}^{n} I(d) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \varphi(i)$$ $$\sum_{i=1}^{n}id(i) = \sum_{d = 1}^{n}I(d)\cdot S(\lfloor\frac{n}{d}\rfloor)$$ $$\sum_{i=1}^{n} id(i) = I(1)\cdot S(n) + \sum_{d=2}^{n}I(d)\cdot S(\lfloor\frac{n}{d}\rfloor)$$ $$\frac{n\cdot(n+1)}{2} = S(n) + \sum_{d=2}^{n}I(d)\cdot S(\lfloor\frac{n}{d}\rfloor)$$ $$S(n) = \frac{n\cdot(n+1)}{2} - \sum_{d=2}^{n}I(d)\cdot S(\lfloor\frac{n}{d}\rfloor)$$ 然后分块一下,递归搞下去就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const long long upper = 1e11;const int maxm = 2e7+10;const int mod = 1e9+7;int add(int a,int b)&#123;return (a+b)%mod;&#125;int mul(long long a,long long b)&#123;return (a%mod)*(b%mod)%mod;&#125;int inv(long long a)&#123; return a==1?1:mul(mod-mod/a,inv(mod%a)); &#125;int inv2 = inv(2);bool p[maxm];int pri[maxm];//质数int phi[maxm];//欧拉函数前缀和void init()&#123; phi[1] = 1; for(int i =2;i&lt;maxm;i++)&#123; if(!p[i])&#123; pri[++pri[0]] = i; phi[i] = i-1; &#125; for(int j = 1;j&lt;=pri[0]&amp;&amp;i*pri[j]&lt;maxm;j++)&#123; p[i*pri[j]] = true; if(i%pri[j]) phi[i*pri[j]] = phi[i]*(pri[j]-1); else&#123; phi[i*pri[j]] = phi[i]*pri[j]; break; &#125; &#125; &#125; for(int i = 2;i&lt;maxm;i++) phi[i] = add(phi[i],phi[i-1]);//因为只会用到前缀和,所以我们直接预处理成前缀和&#125;map&lt;long long,int&gt; mp;int solve(long long m)&#123; if(m&lt;maxm) return phi[m];//查表 if(mp[m]) return mp[m];//记忆化 int ret = mul(m,mul(m+1,inv2)); for(long long l = 2,r;l&lt;=m;l = r+1) &#123;//分块 r = m/(m/l); ret = add(ret,mod-mul(solve(m/l),r-l+1)); &#125; return mp[m] = ret;&#125;int main()&#123; init(); int ans = 0; for(long long x = 2;x&lt;=upper;x&lt;&lt;=1) &#123;//单独统计每一个2的幂 cout&lt;&lt;x&lt;&lt;endl; ans = add(ans,solve(upper/x)); ans = add(ans,mod-1); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 222 Sphere Packing]]></title>
    <url>%2F2019%2F01%2F04%2FPE%2FPE222%2FPE222%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 What is the length of the shortest pipe, of internal radius $50$mm, that can fully contain $21$ balls of radii $30$mm, $31$mm, …, $50$mm? Give your answer in micrometres ($10^{-6}$ m) rounded to the nearest integer. 题意让你在一个内径$50$的圆管里塞$21$个内径分别为$31-50$的小球,问你圆管最短是多少 分析比较显然是dp 考虑dp状态:dp[i][j]表示选择小球对应的集合为j,并且用第i个小球结尾,然后我们转移的时候就直接添加一个小球,对于剩余的小球枚举一个结尾,取最优解就行了 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 21;double ans[maxm][1&lt;&lt;maxm];int num[maxm+10];double cal(int a,int b)&#123;//得到两个小球的距离 int t = a+b+60; return 10*sqrt(t*2-100);&#125;int main()&#123; for(int i = 0;i&lt;maxm;i++) for(int j = 0;j&lt;(1&lt;&lt;maxm);j++) ans[i][j] = 1e8; for(int s = 0;s&lt;(1&lt;&lt;maxm);s++) for(int i = 0;i&lt;maxm;i++)&#123; if(s==0)&#123;//初值条件 ans[i][1&lt;&lt;i] = i+30; continue; &#125; if((s &gt;&gt; i &amp; 1)==1) continue; int t = s|(1&lt;&lt;i);//用S来扩展t for(int j = 0;j&lt;maxm;j++) if(s&gt;&gt;j&amp;1) ans[i][t] = min(ans[i][t],ans[j][s]+cal(i,j)); &#125; double rans = 1e8; for(int i = 0;i&lt;maxm;i++) rans = min(rans,ans[i][(1&lt;&lt;maxm)-1]+i+30); printf("%.0f\n",rans*1000); return 0;&#125;]]></content>
      <tags>
        <tag>PE</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 122 Efficient exponentiation]]></title>
    <url>%2F2019%2F01%2F02%2FPE%2FPE122%2FPE122%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The most naive way of computing $n^{15}$ requires fourteen multiplications: $n \times n \times \dots \times n = n^{15}$ But using a “binary” method you can compute it in six multiplications: \begin{eqnarray}n \times n &amp;= n^2\\n^2 \times n^2 &amp;= n^4\\n^4 \times n^4 &amp;= n^8\\n^8 \times n^4 &amp;= n^{12}\\n^{12} \times n^2 &amp;= n^{14}\\n^{14} \times n &amp;= n^{15}\\\end{eqnarray} However it is yet possible to compute it in only five multiplications: \begin{eqnarray}n \times n &amp;= n^2\\n^2 \times n &amp;= n^3\\n^3 \times n^3 &amp;= n^6\\n^6 \times n^6 &amp;= n^{12}\\n^{12} \times n^3 &amp;= n^{15}\\\end{eqnarray} We shall define $m(k)$ to be the minimum number of multiplications to compute $n^k$; for example $m(15) = 5$. For $1 \leq k \leq 200$, find $\sum m(k)$. 题意我们知道快速计算一个数的幂次有各种不同的方法,快速幂只是其中一种而且不是最快的,然后问你对于1~200的幂次来说,最少需要几次乘法操作. 分析有一个wiki讲的就是这个问题,可以看一看…. 我们可以发现,对于所有幂次来说,我们按照最后一步操作的数来构成他的前驱,然后我们会发现他是一棵树,然后我们直接构造出这颗树出来,就是最优答案….. 代码给大佬递上我奇丑无比的代码 (/ω＼) 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s[222];void cal(int a)&#123; int now = 1e8,ind = 0; for(int i = 1;i&lt;=a;i++)&#123;//枚举每一个比他小的数,看是否可以作为他的前驱 if(s[i].size()+1&gt;=now) continue;//如果不能优化解就不继续搜索 for(int x:s[i])//枚举每一个前驱的子元素 if(s[i].find(a-x)!=s[i].end())&#123;//如果能构成a now = s[i].size()+1;//更新解 ind = i; break; &#125; &#125; for(int i:s[ind]) s[a].insert(i);//保存路径 s[a].insert(a);&#125;int main()&#123; s[1].insert(1); for(int i = 2;i&lt;=200;i++) cal(i); int ans = 0; for(int i = 1;i&lt;=200;i++) ans+=s[i].size()-1;//要把里面的1剪掉,因为合成1不要代价 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 143 Investigating the Torricelli point of a triangle]]></title>
    <url>%2F2018%2F12%2F28%2FPE%2FPE143%2FPE143%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Let ABC be a triangle with all interior angles being less than $120$ degrees. Let $X$ be any point inside the triangle and let $XA = p, XC = q$, and $XB = r$. Fermat challenged Torricelli to find the position of X such that $p + q + r$ was minimised. Torricelli was able to prove that if equilateral triangles AOB, BNC and AMC are constructed on each side of triangle ABC, the circumscribed circles of AOB, BNC, and AMC will intersect at a single point, T, inside the triangle. Moreover he proved that T, called the Torricelli/Fermat point, minimises $p + q + r$. Even more remarkable, it can be shown that when the sum is minimised, $AN = BM = CO = p + q + r$ and that AN, BM and CO also intersect at T. If the sum is minimised and a, b, c, p, q and r are all positive integers we shall call triangle ABC a Torricelli triangle. For example, $a = 399, b = 455, c = 511$ is an example of a Torricelli triangle, with $p + q + r = 784$. Find the sum of all distinct values of $p + q + r ≤ 120000$ for Torricelli triangles. 题意就是三个角都小于120度的三角形存在费马点,然后让你找到所有这样的三角形,使得图上对应的六条边都是整数,其中$T$就是费马点.然后你要找到所有$p+q+r$不同的所有三角形,然后把$p+q+r$求和. 分析对于每一个圆来说,因为里面的三角形是对边三角形,然后因为$T$在园上,于是有$T$对应的角大小一定是$180-60 = 120$度,然后同理可得,三个角都是$120$度,然后我们运用余弦定理可以得到$p^2+q^2+pq=b^2$,因为我们只要$p+q+r$不同的解,所以我们不妨设$p&gt;=q&gt;=r$,因为三个角都是$120$度,所以余弦定理都成立,所以我们可以得到 \begin{eqnarray}q^2+r^2+qr &amp;= a^2\\p^2+q^2+pq &amp;= b^2\\p^2+r^2+pr &amp;= c^2\\p&gt;=q&gt;=r\\\end{eqnarray} 然后我们对于每对关系,可以显然发现都应该是类似的,然后我们可以存下来每个关系,然后暴搜就行了,emmmmmm$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int upper = 1.2e5;set&lt;int&gt; to[upper+10];bool ans[upper&lt;&lt;2];int main()&#123; for(long long i = 1;i&lt;=upper;i++)&#123; for(long long j = min(upper-i,i);j&gt;=1;j--)&#123; long long x = i*i+j*j+i*j; long long y = sqrt(x); if(y*y==x) to[i].insert(j); &#125; if(i%10==0) cout&lt;&lt;i&lt;&lt;'\n'; &#125; for(int i = 1;i&lt;=upper;i++)&#123; for(int j:to[i])&#123; for(int k:to[j])&#123; if(i+j+k&gt;upper) continue; if(to[i].count(k))&#123; ans[i+j+k] = true; &#125; &#125; &#125; &#125; int rans = 0; for(int i = 1;i&lt;=upper;i++) if(ans[i]) rans+=i; cout&lt;&lt;rans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IC(answer.chepter2)]]></title>
    <url>%2F2018%2F12%2F24%2Fknowledge%2FIC_chepter2%2F</url>
    <content type="text"><![CDATA[作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢 1.$\emptyset$ : $4^5 = 1024$.$\lbrace a\rbrace$ : $5\times 4\times 4\times 4 = 320$.$\lbrace b\rbrace$ : $5\times 5\times 5\times 2 = 250$.$\lbrace a,b\rbrace$ : $4\times 4\times 4\times 2 = 128$ 2.$(13!)^4 = 1503561738404723998944447273369600000000$. 3.$$\left( \begin{matrix} 52\\ 5 \end{matrix}\right)=2598960$$ 4.(a) $5\times 3\times 7\times 2 = 210$(b) $620 = 2^2+3^1+5^1+7^1$,$3\times 2\times 2\times 2 = 24$(c) $10^{10} = 2^{10} 5^{10}$,$11\times 11 = 121$ 5.因为$10 = 2\times 5$,所以我们只用统计$2,5$的数量就行了,然后我们可以发现,$2$的数量显然多于$5$的数量,所以我们只用统计$5$的个数就是答案.下面给出一个通用的代码 12345int cal(int a)&#123; int ret = 0; while(a) ret+=a/=5; return ret;&#125; 6.小数据暴力,大数据模拟]]></content>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IC(answer.chepter1)]]></title>
    <url>%2F2018%2F12%2F24%2Fknowledge%2FIC_chepter1%2F</url>
    <content type="text"><![CDATA[作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢 1.利用反证法容易得到,如果$n$和$m$都是奇数,那么$n*m$也是奇数,显然不可覆盖,所以$n$和$m$至少有一个偶数 2.我们定义行号从上到下为$1\dots m$,列号从左到右为$1\dots n$,然后我们就可以得到被切掉的那个方块只可能是奇数行奇数列,或者偶数行偶数列,我们考虑对这两种方案分别进行构造来得到我们想要的答案. 奇数行奇数列:对于和他在同一行同一列的方块来说,因为他去掉了,所以剩下的一定是可以匹配的偶数,也就是说我们可以匹配上这一行一列,对于剩下的一定都是偶数行偶数列的联通块,显然可以构造 奇数行奇数列:这个稍微麻烦一点,我们可以选择他周围的奇数行奇数列的一个子矩阵,显然可以螺旋式的构造,也就是说我们用完左上角,对于剩下的容易证明也是两个偶数的联通块,同样可以构造,看图 3.显然是不能获得自由的,因为我们可以将这个棋盘黑白二染色,然后可以发现对顶角颜色相同,每一步颜色都会反转,一共要走63步,所以最后一步一定会在异色块上,所以不行. 4.(a)对于每一个$n$来说我们直接考虑最后一块的摆放方法,如果是竖着放,那么剩下的就是$f(n-1)$的子问题,如果是横着放,那么倒数第二块显然也是横着放的,所以剩下的就是$f(n-2)$的子问题,所以显然可以得到的是$f(n) = f(n-1)+f(n-2)$,也就是说答案就是fibonacci.$\therefore f(12) = 233$ 4.(b)这里我们可以考虑DP来做,具体程序如下: 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e5+10;int dp[maxm][8];int main()&#123; dp[0][0] = dp[0][3] = dp[0][6] = dp[1][1] = dp[1][4] = dp[1][7] = 1; for(int i = 2;i&lt;maxm;i++)&#123; dp[i][0] = dp[i-2][3]+dp[i-2][6]+dp[i-2][0]; dp[i][1] = dp[i-1][0]+dp[i-2][1]; dp[i][3] = dp[i][0]+dp[i-2][3]; dp[i][4] = dp[i][1]; dp[i][6] = dp[i][3]; &#125; return 0;&#125; 然后可以发现$g(n) = 4\ast g(n-2)-g(n-4)$ 5.用4.(b)的代码容易可得,$g(4) = 11$ 6.同样采用反证法容易证得$n$是偶数,下面我们考虑$n$是奇数扣掉中间一块的情况.不妨假设八个角上的颜色是黑色,可以得到黑块数量是$4k^3+6k^2+3k+1$,白块的数量是$4k^3+6k^2+3k$,我们可以分两种情况讨论,我们假设$n = 2k+1$ 当k是奇数时,也就是$k = 2t+1$,即$n = 4t+3$,中间块是白色的.然后扣掉白块后,显然黑块和白块不匹配,然后不行鸭. 当k是偶数时,也就是$k = 2t$,即$n = 4t+1$,中间块是黑色的,扣掉黑块后,白块和黑块是匹配的,可能可以.下面我们证明$n = 4t+1$时是可行的 我们按照层数拆分,我们抽掉其中的第$2t+1$层,我们可以得到,这一层显然是可行的,类比于二阶的时候,我们扣掉中心块 对于剩下的两个联通块,我们显然可以得到是他们对称,我们只考虑上面的$2t$层的部分,我们每两层考虑一下 对于相连的两层,也就是$2\ast n\ast n$的形状,我们显然可以构造,所以整个三维结构是可以构造的. 7.首先证明$a$既是$n$的因子,又是$m$的因子 因为$a$是$b$的因子,所以$a\ast b$的可以看成多个$a\ast a$的,采用反证法,假设$a$不是$m$的因子,那么对于剩下的$(m%a)\ast (n%a)$的矩阵显然不可以用$a\ast a$的矩阵填满,所以$m%a==0&amp;&amp;n%a==0$. 再证$b$是$n$或者$m$的因子 同样反证法,我们将$a,b,m,n$同时缩小$a$倍,然后可以转化成,现在有一个$x\ast y$的棋盘,我要用一个$1\ast z$的棋盘去覆盖他,但是$gcd(x,z)=gcd(y,z)=1$,这个可以显然发现是不可能的 8.先证:存在完美覆盖$\rightarrow$存在平凡完美覆盖 利用习题7,我们得到如果存在完美覆盖,那么$gcd(n,a)=gcd(m,a)=a$并且$gcd(m,b)=b$,然后我们显然可以让$b$的朝向指向$m$的方向,也就是存在平凡完美覆盖 再证:存在平凡完美覆盖$\rightarrow$存在完美覆盖 显然 9.显然,举个简单例子$n=5,m=6,a=2,b=3$存在完美覆盖,但是不存在平凡完美覆盖. 10.假设存在不妨设四个变量是$a,b,c,d$,那么可以得到$a+b=b+c$即$a=c$显然不能构成幻方 11.12.13 如图 14.所有可能的构造如图 15.暴力枚举的,确实没有解,并不知道为什么…… 16.$n$阶幻方,幻方总和是$n^2\ast (n^2+1)/2$,所以每一行每一列求和都是$n\ast (n^2+1)/2$,现在替换后每一行每一列的和换成了$n\ast (n^2+1) - n\ast (n^2+1)/2 = n\ast (n^2+1)/2$所以可能是个幻方,然后因为里面的元素都是属于$[1,n^2]$之间的,所以$n^2+1-a$可以保证换完之后每个元素还是只出现一次,所以新生成的还是幻方. 17.给出$n=4$和$n=8$时的图……. 18.这个应该是显然的,因为二阶幻方都没有,显然没有二阶幻方体. 19.首先我们拆开来看没一个单独的平面,我们可以得到,对于一个四阶幻方来说,如果对角线也满足幻和,那么显然可以得到任意三阶子矩阵的对顶角之和等于幻和的一半,所以我们任取出四阶幻方体的任一三阶子体,可以得到类似于$a+b=b+c$的等式,也就是说存在$a==c$的情况,这显然和题意不符,所以不可能存在四阶幻方体. 20.首先,$10$和$5$一个颜色,$1,3,7,9$一个颜色,$2,4,6,8$一种颜色,可以得到可以由三种颜色构成,然后,$1,2,10$相互接壤,显然需要三种及以上颜色来涂,方案数为$3\ast 2\ast 1 = 6$. 21.(a) 二阶的显然不存在,书后面给了答案,还有一个比较简单的想法就是如果存在显然可以得到类似于$a==b$的结论,所以不存在. (b) 暴搜剪枝,emmmmm……如图]]></content>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab]]></title>
    <url>%2F2018%2F12%2F23%2Fknowledge%2Fmatlab%2F</url>
    <content type="text"><![CDATA[系统级命令 命令名称 功能说明 clear 清楚内存中所有的或指定的变量和函数 cd 显示和改变当前工作目录 clc 擦除MATLAB工作窗口中所有显示的内容 clf 擦除MATLAB当前工作窗口中的图形 dir 列出当前或者指定目录下的子目录和文件清单 disp 在运行中显示变量或文字信息 echo 控制运行的文字命令是否显示 hold 控制当前的图形窗口对象是否被刷新 home 擦除命令窗口中的内容,并把光标移动到命令窗口 pack 收集内存碎片以扩大内存空间 quit 关闭并退出MATLAB type 显示所指定文件的全部内容 exit 退出MATLAB save 将工作区的变量存放到指定文件 load 回复保存过的变量 系统变量 变量 解释 ans 结果的缺省变量名 pi 圆周率 i,j 虚数单位 inf 无穷大 NaN not a number 矩阵函数 函数 解释 complex 将两个矩阵并成一个复矩阵 zeros(a,b) a*b全0阵 ones(a,b) a*b全1阵 eye(a,b) a*b单位矩阵 randi([a,b],m,n) m*n在a,b之间等概率随机整数矩阵 randn(a,b) 产生均值为0,方差为1的a*b的高斯分布随机阵 repmat(a,b,c) 将a矩阵铺放成bc的形式,总大小size(a)b*c size(a) 确定矩阵大小,返回[行数,列数] length(a) 确定向量元素的个数 numel(a) 确定矩阵中元素个数 find() 查找矩阵中满足条件的下标,或者行列 reshape(a,b,c) 将a变成b行c列(按列重拍) a’ 转置,复数则共轭转置 a(:) 变成一列 rot90 旋转 fliplr 左右翻转 flipud 上下翻转 diag 抽取主对角线 tril 抽取上三角 triu 抽取下三角 max 各列最大值 min 各列最小值 sort 各列递增排序 sum 各列求和 mean 各列平均值 std 各列标准差 var 各列方差 基本数学函数 函数 解释 abs(x) x中每个实数元素的绝对值,复数元素的模 sqrt(x) x中每个元素求平方根 exp(x) 指数运算 real(x) 求实部 imag(x) 求虚部 conj(x) 求共轭 angle(x) 求相位角 sin(x) 正弦 cos(x) 余弦 asin(x) 反正弦 acos(x) 反余弦 tan(x) 正切 atan(x) 反正切 log10(x) 常用对数lgx log(x) 自然对数lnx loga(b) 任意对数 mod(x,y) 求余函数 rem(x,y) 输出对应元素的余数 sign(x) 求矩阵中元素的正负号 lcm(x,y) 最小公倍数 gcd(x,y) 最大公约数 round(a) 四舍五入 fix(a) 按0的方向取整 floor(a) 向负无穷方向取整 ceil(a) 向正无穷方向取整 randperm(n) 产生一个长度为n的排列 绘图 函数 解释 plot(x,y,’option’) x横轴,y纵轴,逐点连折线绘制二维图形,参数见下表 plot(y) y为向量,以下标作为x轴,y为纵轴,绘制曲线 title(‘text’) 添加标题 xlabel(‘text’) x轴加标注 ylabel(‘text’) y轴加标记 legend(‘图例1’,’图例2’,…) 添加图例 text(x,y,’text’) 在指定位置添加文本字符串 gtext(‘text’) 用鼠标放置文本 axis([xmin xmax ymin ymax zmin zmax]) 调整坐标 hold 图形保持函数 subplot 子图分割命令 stem 离散序列 绘图参数表 符号 含义 符号 含义 y 黄 b 蓝 m 洋红 w 白 c 青 k 黑 r 红 g 绿 - 实线 – 虚线 : 点线 -. 点划线 . 点 o 圆 x 叉号 + 加号 ^ 向上的三角形 v 向下的三角形 &gt; 大于号 &lt; 小于号 s 正方形 d 菱形 p 五角星 h 六角星 * 星号 字符串函数 函数 解释 abs 字符串到ascii转换 str2mat 字符串转换成字符矩阵 setstr ascii转字符串 num2str 数值转字符串 str2num 字符串转换成数值 dec2bin 十进制数转二进制字符串 bin2dec 二进制串转十进制 int2str 将数值取整后转成字符串 upper 字符串转换成大写 lower 字符串转换成小写 sprintf 用格式控制,数字转字符串 sscanf 格式控制,字符串转数字 输入输出 函数 解释 input(‘text’) 键盘提示输入 fprintf() 格式输出]]></content>
      <tags>
        <tag>live</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 463 A weird recurrence relation]]></title>
    <url>%2F2018%2F12%2F23%2FPE%2FPE463%2FPE463%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The function $f$ is defined for all positive integers as follows: $f(1)$ = $1$ $f(3)$ = $3$ $f(2n)$ = $f(n)$ $f(4n+1)$ = $2\cdot f(2n+1)-f(n)$ $f(4n+3)$ = $3\cdot f(2n+1)-2\cdot f(n)$ The function $S(n)$ is defined as $\sum_{i=1}^{n} f(i)$. $S(8)=22$ and $S(100)=3604$. Find $S(3^{37})$. Give the last $9$ digits of your answer. 题意就是给你一个序列,问你这个序列的前缀和是多少 分析显然是推公式嘛. 根据题意我们显然可以得到 $f(4n)+f(4n+1)+f(4n+2)+f(4n+3) = 6\cdot f(2n+1) - 2\cdot f(n)$ for $n\geq 1$ 然后我们每四项加一下就可以得到下面这个公式 \begin{eqnarray}S(4n+3) &amp;=&amp; \sum_{i=1}^{4i+3} f(i)\\ &amp;=&amp; 5 + \sum_{i=4}^{4i+3} f(i)\\ &amp;=&amp; 5 + \sum_{i=1}^{n} (6\cdot f(2i+1) - 2\cdot f(i))\\ &amp;=&amp; 5 + 6\sum_{i=1}^{n} (f(2i+1)+f(2i)) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; 5 + 6\sum_{i=2}^{2n+1} f(i) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; 5 - 6 + 6\sum{i=1}{2n+1} f(i) - 8\sum_{i=1}^{n} f(i)\\ &amp;=&amp; -1 + 6\sum{i=1}{2n+1} f(i) -8\sum_{i=1}^{n} f(i)\\\end{eqnarray} 然后瞎搞就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+10;const int mod = 1e9;inline int add(long long a,long long b)&#123;return (a+b)%mod;&#125;inline int mul(long long a,long long b)&#123;return a*b%mod;&#125;int num[maxm];int sum[maxm];long long f(long long a)&#123; if(a&lt;maxm&amp;&amp;num[a]) return num[a]; if(a==0) return 0; if(a==1) return 1; if(a==3) return 3; if((a&amp;1)^1) return f(a&gt;&gt;1); else if((a&amp;3)==3) return add(mul(3,f(a&gt;&gt;1)),mod-(f(a&gt;&gt;2)&lt;&lt;1)); else return add((f(a&gt;&gt;1|1)&lt;&lt;1),mod-f(a&gt;&gt;2));&#125;long long S(long long a)&#123; if(a&lt;maxm) return sum[a]; long long ret = 0; if(a%4==3)&#123; ret = add(ret,mul(6,S(a&gt;&gt;1))); ret = add(ret,mod-mul(8,S(a&gt;&gt;2))); ret = add(ret,mod-1); &#125;else&#123; while(a%4!=3) ret = add(ret,mod-f(++a)); ret = add(ret,S(a)); &#125; return ret;&#125;int main()&#123; for(int i = 1;i&lt;maxm;i++) num[i] = f(i),sum[i] = add(sum[i-1],num[i]); long long nouse = 1; for(int i = 1;i&lt;=37;i++)&#123; nouse = (nouse&lt;&lt;2)-nouse; &#125; cout&lt;&lt;S(nouse)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 368 A Kempner-like series]]></title>
    <url>%2F2018%2F12%2F21%2FPE%2FPE368%2FPE368%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 The harmonic series $1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\dots$ is well known to be divergent. If we however omit from this series every term where the denominator has a $9$ in it, the series remarkably enough converges to approximately $22.9206766193$. This modified harmonic series is called the Kempner series. Let us now consider another modified harmonic series by omitting from the harmonic series every term where the denominator has $3$ or more equal consecutive digits. One can verify that out of the first $1200$ terms of the harmonic series, only $20$ terms will be omitted.These $20$ omitted terms are: $$\frac{1}{111},\frac{1}{222},\frac{1}{333},\frac{1}{444},\frac{1}{555},\frac{1}{666},\frac{1}{777},\frac{1}{888},\frac{1}{999},\frac{1}{1000},\frac{1}{1110}, \frac{1}{1111},\frac{1}{1112},\frac{1}{1113},\frac{1}{1114},\frac{1}{1115},\frac{1}{1116},\frac{1}{1117},\frac{1}{1118},\frac{1}{1119}$$ This series converges as well. Find the value the series converges to.Give your answer rounded to $10$ digits behind the decimal point. 题意就是,调和级数不是发散的嘛,然后让你删掉那些分母含有连续三个相同数字的,然后可以证明剩下的级数是收敛的,然后问你收敛于多少. 分析做法比较巧妙,下面一点点分析. 首先我们令$S_1(n,d)$表示一个包含所有这样的$n$位数的集合,集合中所有的$n$位数最后一位是$n$,并且倒数第二位不是$n$. $S_2(n,d)$表示一个包含所有这样的$n$位数的集合,集合中所有的$n$位数最后两位是$n$,并且倒数第三位不是$n$. 然后我们令 $f_1(n,d,j)$ = $\sum_{x\in S_1(n,d)} \frac{1}{x^j}$ $f_2(n,d,j)$ = $\sum_{x\in S_2(n,d)} \frac{1}{x^j}$ 然后答案显然就是 $\sum_{i=1}^{99} \frac{1}{i}+\sum_{n=3}^{\infty } \sum_{d=0}^{9} [f_1(n,d,1)+f_2(n,d,1)]$ 关键是我们怎么算$f_1(n,d,j)$和$f_2(n,d,j)$ 二者分析方法一样,这里给出$f_2(n,d,j)$怎么推出来的. 首先根据定义我们有 $f_2(n,d,j)$ = $\sum_{x\in S_2(n,d)} \frac{1}{x^j}$ 我们不妨枚举每一个$x$,然后累加就是答案,所以子问题就是如何快速计算$\frac{1}{x^j} where x \in S_2(n,d)$ 因为最后一位是$d$,所以我们不妨设$x$ = $y\ast 100+d\ast 10+d$ 然后可以得到 $$(\frac{1}{x\ast 100+d\ast 10+d})^j=\frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot (\frac{1}{1+\frac{d}{x\ast 100+d\ast 10}})^j$$ 然后我们将第三个分式化简. 考虑到 $(1+a)^{-b} = \sum_{i=0}^{\infty } C_{b+i-1}^i \cdot (-a)^b$ 所以上式可以化简为 \begin{eqnarray}(\frac{1}{x\ast 100+d\ast 10+d})^j&amp;=&amp; \frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot \sum_{i=0}^{\infty } C_{j+i-1}^{i}(\frac{-d}{x\ast 100+d\ast 10})^i\\&amp;=&amp; \frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot \sum_{i=0}^{\infty } C_{j+i-1}^{i}(\frac{-d}{10})^i\cdot(\frac{1}{x\ast 10+d})^i\\&amp;=&amp; \frac{1}{10^j} \sum_{i=0}^{\infty } C_{j+i-1}^{i} \cdot (\frac{-d}{10})^i \cdot (\frac{1}{x\ast 10+d})^{i+j}\\\end{eqnarray} 然后我们考虑累加所有的$x$也就是原来的$f_2(n,d,j)$ 可以得到 $$f_2(n,d,j) = \frac{1}{10^j} \sum_{i=0}^{\infty } (\frac{-d}{10})^i \cdot C_{j+i-1}^{i} \cdot f_1(n-1,d,i+j)$$ 同理可以推得 $f_1(n,d,j)$ 然后就是代码如下啦啦啦$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 40;double C[maxm*3][maxm*3];double f1[2][10][maxm+1];double f2[2][10][maxm+1];double ans = 0;void init()&#123;//预处理出组合数和前99项的答案 for(int i = 0;i&lt;maxm*3;i++) for(int j = 0;j&lt;=i;j++)&#123; if(j==0) C[i][j] = 1; else C[i][j] = C[i-1][j-1]+C[i-1][j]; &#125; for(int i = 1;i&lt;100;i++) ans+=1.0/i;&#125;int main()&#123; init(); for(int d = 0;d&lt;=9;d++)&#123;//预处理出n = 3的情况 for(int j = 1;j&lt;=maxm;j++)&#123; for(int pre = 10;pre&lt;100;pre++)&#123; int fir = pre/10; int sec = pre%10; if(fir==sec&amp;&amp;sec==d) continue; if(sec==d) f2[1][d][j]+=1.0/pow(pre*10+d,j); else f1[1][d][j]+=1.0/pow(pre*10+d,j); &#125; &#125; ans+=f1[1][d][1]+f2[1][d][1]; &#125; for(int nouse = 4;nouse&lt;=10000;nouse++)&#123;//滚动的算n&gt;=4的时候 int now = nouse&amp;1; int las = now^1; for(int d = 0;d&lt;=9;d++)&#123; for(int j = 1;j&lt;=maxm;j++)&#123; f1[now][d][j] = f2[now][d][j] = 0;//别忘了初始化 double pre = 1.0/pow(10.0,j); for(int i = 0;i&lt;=maxm;i++)&#123; if(i+j&lt;=maxm) f2[now][d][j]+=pre*C[j+i-1][i]*f1[las][d][i+j]; for(int x = 0;x&lt;10;x++)&#123; if(x==d) continue; if(i+j&lt;=maxm) f1[now][d][j]+=pre*C[j+i-1][i]*(f1[las][x][i+j]+f2[las][x][i+j]); &#125; pre*=-d/10.0; &#125; &#125; ans+=f1[now][d][1]+f2[now][d][1]; &#125; printf("%.10f\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 492 Exploding sequence]]></title>
    <url>%2F2018%2F12%2F12%2FPE%2FPE492%2FPE492%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 Define the sequence $a_1, a_2, a_3,\dots$ as: $a_1 $=$ 1$ $a_{n+1} = 6a_n^2 + 10a_n + 3$ for $n \geq 1$. Examples: $a_3 $=$ 2359$ $a_6 $=$ 269221280981320216750489044576319$ $a_6 mod 1000000007 $=$ 203064689$ $a_{100} mod 1000000007 $=$ 456482974$ Define $B(x,y,n)$ as $\sum (a_n mod $ $p)$ for every prime $p$ such that $x \leq p \leq x+y$. Examples: $B(10^9, 10^3, 10^3)$ = $23674718882$ $B(10^9, 10^3, 10^{15})$ = $20731563854$ Find $B(10^9, 10^7, 10^{15})$. 题意给你一个二次递推序列,问你这个数列的第$10^{15}$项膜上一堆质数之后求和是多少. 分析看了大佬的题解之后才做出来的,还是太菜了$\dots$ 下面是分析. 首先我们令$b_n = 6a_n+5$ 于是有 $b_1$ = $11$ $b_{n+1} $=$ b_n^2-2$ 然后我们令 $ x + \frac{1}{x}$ = $11$ 可以显然发现 $b_n$ = $x^{2^{n-1}} + \frac{1}{x^{2^{n-1}}}$ 于是不妨设 $x$ = $\frac{11+\sqrt{117}}{2}$ $\therefore b_n$ = $(\frac{11+\sqrt{117}}{2})^{2^{n-1}} + (\frac{11-\sqrt{117}}{2})^{2^{n-1}}$ 然后我们可以直接算就行了 我们搞出递推式，然后用矩阵乘法的做法来做 我们考虑一个更一般的问题， 令$f_n = (\frac{11+\sqrt{117}}{2})^n + (\frac{11-\sqrt{117}}{2})^n$ 然后我们考虑$f_n$如何求解 首先我们假设$f_n = x\ast f_{n-1}+y\ast f_{n-2}$ $$令 (\frac{11+\sqrt{117}}{2})^{n-2} = a$$ $$令 (\frac{11-\sqrt{117}}{2})^{n-2} = b$$ 则有\begin{cases}\begin{eqnarray}f_n &amp;=&amp; a\ast (\frac{11+\sqrt{117}}{2})^2+b\ast (\frac{11-\sqrt{117}}{2})^2\\&amp;=&amp; a\ast (\frac{238+22\sqrt{117}}{4})+b\ast (\frac{238-22\sqrt{117}}{4})\\f_{n-1}&amp;=&amp;a\ast (\frac{11+\sqrt{117}}{2})+b\ast (\frac{11-\sqrt{117}}{2})\\f_{n-2}&amp;=&amp;a+b \\\end{eqnarray}\end{cases} \begin{eqnarray}&amp;\therefore&amp; a\ast (\frac{238+22\sqrt{117}}{4})+b\ast (\frac{238-22\sqrt{117}}{4})\\&amp;=&amp; x\ast a\ast (\frac{11+\sqrt{117}}{2})+x\ast b\ast (\frac{11-\sqrt{117}}{2}) + y\ast (a+b)\\\end{eqnarray} 将非根号项提出来，可以得到 $\therefore a\ast \frac{119}{2}+b\ast \frac{119}{2}$=$xa\ast \frac{11}{2}+xb\ast \frac{11}{2}+y(a+b) $ 同理将根号项提出可以得到 $a\ast \frac{11}{2}+b\ast \frac{-11}{2}$=$xa\ast \frac{1}{2}+xb\ast \frac{-1}{2} $ 然后可以解得 \begin{cases}x = 11\\y = -1\end{cases} 也就是说$f_n$ = $11\ast f_{n-1} - f_{n-2}$ 好了，我们得到了$f_n$的递推式，然后考虑原问题，也就是说 $$\left( \begin{matrix} b_{n+1}\\ b_n \end{matrix}\right)=\left( \begin{matrix} 11 &amp; -1\\ 1 &amp; 0 \end{matrix}\right)^{2^{n-1}-1}\left( \begin{matrix} b_2\\ b_1 \end{matrix}\right)=\left( \begin{matrix} 11 &amp; -1\\ 1 &amp; 0 \end{matrix}\right)^{2^{n-1}-1}\left( \begin{matrix} 119\\ 11 \end{matrix}\right)$$ $\because n$ 很大($10^{15}$) $\therefore 2^{n-1}-1$很大,以至于我们不能方便的计算 然后我们考虑降低指数 具体分析看大佬的分析,可以得到循环节可以是$(p+1)(p-1)$ 这个值我们可以接受,然后直接裸的矩阵ksm就行了$\dots$ 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const long long n = 1e15;const long long l = 1e9;const long long r = l+1e7;long long add(long long a,long long b,long long mod)&#123; return (a+b)%mod; &#125;long long mul(long long a,long long b,long long mod)&#123; a = add(a,mod,mod); b = add(b,mod,mod); long long ret = 0; while(b)&#123; if(b&amp;1) ret = add(ret,a,mod); a = add(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;long long qpow(long long a,long long b,long long mod)&#123; long long ret = 1; while(b)&#123; if(b&amp;1) ret = mul(ret,a,mod); a = mul(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;bool is_prime(int a)&#123; if(a&amp;1)&#123; for(int i = 3;i*i&lt;=a;i++) if(a%i==0) return false; return true; &#125; return false;&#125;struct p&#123; int mat[2][2]; void show()&#123; for(int i = 0;i&lt;2;i++)&#123; for(int j = 0;j&lt;2;j++) cout&lt;&lt;mat[i][j]&lt;&lt;' '; cout&lt;&lt;endl; &#125; &#125;&#125;;p mul(p a,p b,long long mod)&#123; p ret; memset(ret.mat,0,sizeof ret.mat); for(int i = 0;i&lt;2;i++)&#123; for(int j =0;j&lt;2;j++)&#123; for(int k = 0;k&lt;2;k++)&#123; ret.mat[i][j] = add(ret.mat[i][j],mul(a.mat[i][k],b.mat[k][j],mod),mod); &#125; &#125; &#125; return ret;&#125;p qpow(p a,long long b,long long mod)&#123; p ret; for(int i = 0;i&lt;2;i++) for(int j = 0;j&lt;2;j++) &#123; if(i==j) ret.mat[i][j]=1; else ret.mat[i][j]=0; &#125; while(b)&#123; if(b&amp;1) ret = mul(ret,a,mod); a = mul(a,a,mod); b&gt;&gt;=1; &#125; return ret;&#125;long long solve(long long prime)&#123; const long long MOD = prime*prime-1; long long zhi = qpow(2,n-1,MOD); zhi = add(zhi,MOD-1,MOD); p base; base.mat[0][0]=11,base.mat[0][1]=-1; base.mat[1][0]=1 ,base.mat[1][1]=0; base = qpow(base,zhi,prime); long long ret1 = mul(base.mat[1][0],119,prime); long long ret2 = mul(base.mat[1][1],11,prime); return add(ret1,ret2,prime);&#125;long long inv(long long a,long long mod)&#123; if(a==1) return 1; return mul(mod-mod/a,inv(mod%a,mod),mod);&#125;int main()&#123; long long ans = 0; for(int i = l;i&lt;=r;i++)&#123; if(is_prime(i))&#123; long long bn = solve(i); long long now1 = add(bn,i-5,i); long long an = mul(now1,inv(6,i),i); ans+=an; &#125; if(i%100000==0) cout&lt;&lt;i&lt;&lt;endl; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 294 Sum of digits-experience]]></title>
    <url>%2F2018%2F12%2F09%2FPE%2FPE294%2FPE294%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For a positive integer $k$, define $d(k)$ as the sum of the digits of $k$ in its usual decimal representation. Thus $d(42) = 4+2 = 6$. For a positive integer $n$, define $S(n)$ as the number of positive integers $k &lt; 10^n$ with the following properties : $k$ is divisible by $23$ and $d(k) = 23$. You are given that $S(9) = 263626$ and $S(42) = 6377168878570056$. Find $S(11^{12})$ and give your answer mod $10^9$. 题意你要找到一个所有满足一下三个条件的数字数量 假设这个数是$k$ $k$ $&lt;$ $10^{11^{12}}$ $k\%23$ = 0 $k$每个十进制位求和为$23$ 分析这个题目困扰了我两天,我一度以为自己读错题了,主要是数据范围太大了,大的人一点想法都没有$\dots$ 下面说正解 虽然数据范围很大,但是我们可以从小数据入手 先看第二个条件$k%23==0$,是否感觉出了一丝丝猫腻? 于是我大胆写了一下,比较好想的就是一定存在一个$n$使得$10^n%23==1$,也就是说存在膜数存在循环,而且显然有循环节是$O(23)$的 于是大胆暴力,找到了,循环节长度为$22$ 这也就是说,在十进制下,位数最多有$11^{12}$个,而且这些里面,可以拆分成$22$份,每一份里面,你不管把数字安排到哪里,都是同膜的 于是我们可以简单的把$11^{12}$近似的均分成了$22$份.而且每一份可以单独统计答案 然后问题就转化成了以下两个子问题: 找到$a_1,a_2\dots a_{22}$使得$a_1+a_2+\dots +a_{22} = 23$ 对于每一份就成了一个$a_i$个相同的球放入近似$11^{12}$个盒子里,每个盒子最多放$9$个球,问你方案数 对于第一个子问题,我们显然可以动态规划搞一搞 定义$dp(i,j,k)$表示$a_1+a_2+\dots +a_i == j$并且当前膜数为$k$的方案数 然后暴力转移就行了 关键是第二个子问题不好想,因为盒子数量太大了,必须要有一个$log$的做法 然后就枚举算法(毕竟会的算法不多) 然后就想到了分治,但是能不能分治呢,并不知道,写一发就知道了,然后跑的挺快的(然后就过了) 并不会算分治的玄学复杂度 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9;int add(int a,int b)&#123;return (a+b)%mod;&#125;int mul(int a,int b)&#123;return 1ll*a*b%mod;&#125;long long n,m;void init()&#123; m = 23; n = 1; for(int i = 1;i&lt;=12;i++) n*=11;&#125;map&lt;pair&lt;long long,int&gt;,int&gt;mp;int solve(long long a,int b)&#123;///b ball,a boxes if(a==1) return b&lt;=9; if(a==0) return b==0; pair&lt;long long,int&gt; now = make_pair(a,b); if(mp[now]) return mp[now]; int ret = 0; long long l = a/2,r = a-l; for(int i = 0;i&lt;=b;i++) ret = add(ret,mul(solve(l,i),solve(r,b-i))); return mp[now] = ret;&#125;long long dp[30][30][30];int main()&#123; init(); dp[0][0][0] = 1; int w = 1; for(int i = 0;i&lt;m;i++)&#123; long long has = n/(m-1) + (i&lt;n%22); for(int j = 0;j&lt;=m;j++)&#123; for(int k = 0;k&lt;m;k++)&#123; for(int t = 0;j+t&lt;=m;t++)&#123; dp[i+1][j+t][(k+w*t)%m] = add(dp[i+1][j+t][(k+w*t)%m],mul(dp[i][j][k],solve(has,t))); &#125; &#125; &#125; w = w*10%m; &#125; cout&lt;&lt;dp[m-1][m][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 288 An enormous factorial]]></title>
    <url>%2F2018%2F12%2F08%2FPE%2FPE288%2FPE288%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For any prime $p$ the number $N(p,q)$ is defined by $N(p,q) = \sum_{n=0}^q T_n*p^n$with $T_n$ generated by the following random number generator: \begin{eqnarray}&amp;&amp;S_0 = 290797\\&amp;&amp;S_{n+1} = S_n^2 mod 50515093\\&amp;&amp;T_n = S_n mod p\\\end{eqnarray} Let $Nfac(p,q)$ be the factorial of $N(p,q)$.Let $NF(p,q)$ be the number of factors $p$ in $Nfac(p,q)$. You are given that $NF(3,10000) mod 3^{20}=624955285$. Find $NF(61,10^7)$ mod $61^{10}$ 题意题意说的有点麻烦，我简化一下 $T_i$是随机生成的数据，$N(p,q)=\sum_{n=0}^q T_n*p^n$ 问你$N(p,q)$的阶乘里面，质因数分解以后$p$的指数膜$p^{10}$答案是多少． 分析首先可以观察到的是，$T_i$很小，而且他是随机的，我们显然要把他存起来． 然后一个比较显然的结论是$$n!质因数分解后素因子p的数量为\lfloor \frac{n}{p} \rfloor + \lfloor \frac{n}{p^2} \rfloor + \cdots$$$$\because 最后的答案要膜 p^{10} \therefore 我们统计的时候，对于第一项，我们统计指数为 [1,10]的，第二项[2,11],然后枚举项统计答案即可$$ 代码给大佬递上我奇丑无比的代码 (/ω＼)123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 1e7+1;const int pow_num = 10;long long T[maxm+100];const int p = 61;long long powp[1000];void init()&#123; powp[0] = 1; for(int i = 1;i&lt;=pow_num;i++) powp[i] = powp[i-1]*p; long long s0 = 290797; for(int i = 1;i&lt;maxm;i++) T[i] = (s0=s0*s0%50515093)%p;&#125;int main()&#123; init(); long long ans = 0; const long long mod = powp[pow_num]; for(int i = 1;i&lt;maxm;i++) for(int j = i;j&lt;=i+pow_num-1;j++) ans = (ans+(T[j]*powp[j-i]%mod))%mod; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 303 Multiples with small digits]]></title>
    <url>%2F2018%2F12%2F08%2FPE%2FPE303%2FPE303%2F</url>
    <content type="text"><![CDATA[开启传送门 题目描述 For a positive integer $n$, define $f(n)$ as the least positive multiple of $n$ that, written in base $10$, uses only digits $≤ 2$. Thus $f(2)=2, f(3)=12, f(7)=21, f(42)=210, f(89)=1121222$. Also,$ \sum_{n=1}^{100} \frac{f(n)}{n} = 11363107 $ Find $ \sum_{n=1}^{10000} \frac{f(n)}{n}. $ 题意问你对于每个数字来说，找到他的一个最小整数倍，使得最小整数倍在十进制下每位都小于3 分析很显然，考的是搜索，如何高效搜索． 最简单的想法就是枚举倍数，然后逐个判断是否合法，然后你会发现所有$999$的倍数都Ｔ飞了 然后考虑剪枝，因为可以显然得到，有些倍数一定无效，比如： $5来说，5\ast 1 = 5,5\ast 11 = 55,5\ast 21 = 105 \dots$ 可以显然发现，对于$5$来说，以$1$结尾的倍数显然都不合理，因为他们的最后一位一定是$5$，可以直接判断掉． 然后你就就基本可以过掉大部分数据，但是还是有一个比较头疼，那就是$9999$. 因为他对应的答案贼大，暴力搜索基本都GG．然后我们换一个思路． 那就是我们直接暴力枚举所有的那些看起来长的像$3$进制的十进制数． 然后我们就直接存储所有的这样的数字，然后枚举？ 那么显然内存不够，那怎么办呢？ dfs? 还是Ｔ飞，所以我们还要在此基础上剪枝． 首先我们可以构造出一种做法就是，每次搜索的时候得到的都是之前没出现过的最小的这类数字． 然后我们维护一个mod数组，表示当前这个mod正确的情况下，最小的这类数字是多少 然后答案显然就是mod[0]啦……. 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define ll unsigned long longusing namespace std;ll vis[10000+100];ll cal(int a)&#123; queue&lt;ll&gt; que; que.push(1),que.push(2); memset(vis,0,sizeof vis); vis[1] = 1; vis[2] = 2; while(true)&#123; ll now = que.front(); que.pop(); if(now%a==0) return now/a; for(int i = 0;i&lt;3;i++)&#123; ll buf = now*10+i; ll buff = buf%a; if(vis[buff]) continue; vis[buff] = buf; que.push(buf); &#125; &#125;&#125;int main()&#123; ll ans = 0; for(int i = 1;i&lt;=10000;i++) ans+=cal(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>PE</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mathematical formula(Irregular updates)]]></title>
    <url>%2F2018%2F12%2F07%2Fknowledge%2FMathematical_Formula%2F</url>
    <content type="text"><![CDATA[二元运算符 符号 功能 代码 符号 功能 代码 符号 功能 代码 $+$ 加 + $-$ 减 - $\triangleleft$ \triangleleft $\pm$ 加减 \pm $\mp$ 减加 \mp $\triangleright$ \triangleright $\times$ 乘 \times $\setminus$ 差集 \setminus $\star$ ５星乘 \star $\cup$ 并 \cup $\cap$ 交 \cap $\ast$ ６星乘 \ast $\sqcup$ \sqcup $\sqcap$ \sqcap $\circ$ \circ $\vee$ 合取 \vee $\wedge$ 析取 \wedge $\bullet$ \bullet $\oplus$ 异或 \oplus $\ominus$ \ominus $\diamond$ \diamond $\odot$ \odot $\oslash$ \oslash $\uplus$ \uplus $\otimes$ \otimes $\bigcirc$ \bigcirc $\amalg$ \amalg $\bigtriangleup$ \bigtriangleup $\bigtriangledown$ \bigtriangledown $\dagger$ \dagger $\lhd$ \lhd $\rhd$ \rhd $\ddagger$ \ddagger $\unlhd$ \unlhd $\unrhd$ \unrhd $\wr$ \wr 二元关系符 符号 功能 代码 符号 功能 代码 符号 功能 代码 $&lt;$ 小于 &lt; $&gt;$ 大于 &gt; $=$ 等于 = $\leq$ 小于等于 \leq $\geq$ 大于等于 \geq $\equiv$ 同余 \equiv $\ll$ 远小于 \ll $\gg$ 远大于 \gg $\doteq$ 约等于 \doteq $\prec$ \prec $\succ$ \succ $\sim$ \sim $\preceq$ \preceq $\succeq$ \succeq $\simeq$ \simeq $\subset$ 子集 \subset $\supset$ 父集 \supset $\approx$ \approx $\subseteq$ \subseteq $\supseteq$ \supseteq $\cong$ \cong $\sqsubset$ \sqsubset $\sqsupset$ \sqsupset $\Join$ \Join $\sqsubseteq$ \sqsubseteq $\sqsupseteq$ \sqsupseteq $\bowtie$ \bowtie $\in$ 属于 \in $\ni$ 被属于 \ni $\propto$ \propto $\vdash$ 蕴涵 \vdash $\dashv$ 被蕴涵 \dashv $\models$ \models $\mid$ 整除 \mid $\parallel$ 平行 \parallel $\perp$ \perp $\smile$ \smile $\frown$ \frown $\asymp$ \asymp $:$ ： $\notin$ 不属于 \notin $\neq$ 不等于 \neq 小写希腊字母 符号 代码 符号 代码 符号 代码 符号 代码 符号 代码 $\alpha$ \alpha $\beta$ \beta $\gamma$ \gamma $\delta$ \delta $\omega$ \omega $\epsilon$ \epsilon $\varepsilon$ \varepsilon $\zeta$ \zeta $\eta$ \eta $\psi$ \psi $\theta$ \theta $\vartheta$ \vartheta $\iota$ \iota $\kappa$ \kappa $\varphi$ \varphi $\lambda$ \lambda $\mu$ \mu $\nu$ \nu $\xi$ \xi $\phi$ \phi $\pi$ \pi $\varpi$ \varpi $\rho$ \rho $\varrho$ \varrho $\upsilon$ \upsilon $\sigma$ \sigma $\varsigma$ \varsigma $\tau$ \tau 大写希腊字母 符号 代码 符号 代码 符号 代码 符号 代码 符号 代码 $\Gamma$ \Gamma $\Delta$ \Delta $\Theta$ \Theta $\Lambda$ \Lambda $\Omega$ \Omega $\Xi$ \Xi $\Pi$ \Pi $\Sigma$ \Sigma $\Upsilon$ \Upsilon $\Psi$ \Psi $\Phi$ \Phi 箭头 符号 代码 符号 代码 符号 代码 符号 代码 $\leftarrow$ \leftarrow $\rightarrow$ \rightarrow $\Leftarrow$ \Leftarrow $\Rightarrow$ \Rightarrow $\longleftarrow$ \longleftarrow $\longrightarrow$ \longrightarrow $\Longleftarrow$ \Longleftarrow $\Longrightarrow$ \Longrightarrow $\uparrow$ \uparrow $\downarrow$ \downarrow $\Uparrow$ \Uparrow $\Downarrow$ \Downarrow $\nwarrow$ \nwarrow $\nearrow$ \nearrow $\swarrow$ \swarrow $\searrow$ \searrow $\Leftrightarrow$ \Leftrightarrow $\Longleftrightarrow$ \Longleftrightarrow $\Updownarrow$ \Updownarrow $\iff$ \iff $\mapsto$ \mapsto $\longmapsto$ \longmapsto $\hookleftarrow$ \hookleftarrow $\hookrightarrow$ \hookrightarrow $\leftharpoonup$ \leftharpoonup $\rightharpoonup$ \rightharpoonup $\leftharpoondown$ \leftharpoondown $\rightharpoondown$ \rightharpoondown $\updownarrow$ \updownarrow $\leadsto$ \leadsto $\rightleftharpoons$ \rightleftharpoons $\longleftrightarrow$ \longleftrightarrow $\leftrightarrow$ \leftrightarrow 括号 符号 代码 符号 代码 符号 代码 符号 代码 $\lbrack$ \lbrack $\rbrack$ \rbrack $\lbrace$ \lbrace $\rbrace$ \rbrace $\langle$ \langle $\rangle$ \rangle $\lfloor$ \lfloor $\rfloor$ \rfloor $\vert$ \vert $\Vert$ \Vert $\lceil$ \lceil $\rceil$ \rceil $\backslash$ \backslash 大尺寸符号 符号 代码 符号 代码 符号 代码 符号 代码 $\lgroup$ \lgroup $\rgroup$ \rgroup $\lmoustache$ \lmoustache $\rmoustache$ \rmoustache $\arrowvert$ \arrowvert $\Arrowvert$ \Arrowvert $\bracevert$ \bracevert]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UPCOJ 9999 Cube]]></title>
    <url>%2F2018%2F12%2F03%2Fother_oj%2FUPCOJ9999%2F</url>
    <content type="text"><![CDATA[题目描述给你一个 $ n\ast m $ 的棋盘，有一个 $ 1\ast 1\ast 2 $ 的长方体竖直放在 (1,1)上，你可以将其在棋盘上滚动，你的目标是让其竖直放在 ( n , m ) 上，问至少需要多少次操作。(放倒、竖直、翻滚) 输入一行，两个整数n，m (n&lt;=m) 输出需要最少时间能从(1,1)到达(n,m)，如果无解输出 $ impossible $ . 样例输入1 1 样例输出0 提示 分析这个题目我的做法其实比较暴力，因为和队友赌能不能1Y ，我甚至怂到写暴力对拍了．．．． 闲话少说，下面看分析． 其实还是比较好想的． 首先我们考虑哪种情况是 impossible ．比较好观察的是，当ｎ和ｍ足够大的时候就一定可达 所以我们只用找到一个ｎ和ｍ可达的下界就行了 然后就可以发现只有当ｎ和ｍ都小于３的时候会有impossible的情况(因为转不动．．．． 接下来分析其他情况，首先比较好分析的是，如果n%3==1&amp;&amp;m%3==1的话，答案可以显然得到是 $(n/3+m/3)\ast 2$ 剩下的同理搞搞就行了，大体情况见下表． 比较显然的是，加的那一项和n,m％3为2的数量一致，然后就是代码啦．．． 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std; int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; if(n&lt;=2)&#123; if(m%3==1) cout&lt;&lt;m/3*2+n-1&lt;&lt;endl; else cout&lt;&lt;"impossible"&lt;&lt;endl; &#125;else if(n==3&amp;&amp;m==3) cout&lt;&lt;8&lt;&lt;endl; else if(n==3)&#123; if(m%3==0) cout&lt;&lt;m/3*2+4&lt;&lt;endl; else if(m%3==1) cout&lt;&lt;(m+2)/3*2&lt;&lt;endl; else cout&lt;&lt;m/3*2+5&lt;&lt;endl; &#125;else &#123; int ans = (n/3+m/3)*2; ans+=(m%3==2)+(n%3==2); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UPCOJ 9805 Network Reliability]]></title>
    <url>%2F2018%2F12%2F03%2Fother_oj%2FUPCOJ9805%2F</url>
    <content type="text"><![CDATA[题目描述An undirected graph is given. Each edge of the graph disappears with a constant probability. Calculate the probability with which the remained graph is connected. 输入The first line contains three integers N (1≤N≤14), M (0≤M≤100) and P (0≤P≤100), separated by a single space. N is the number of the vertices and M is the number of the edges. P is the probability represented by a percentage. The following M lines describe the edges. Each line contains two integers $ v_i $ and $ u_i $ (1≤$ u_i $ ,$ v_i $≤N). ($ u_i $ ,$ v_i $) indicates the edge that connects the two vertices $ u_i $ and$ v_i $. 输出Output a line containing the probability with which the remained graph is connected. Your program may output an arbitrary number of digits after the decimal point. However, the absolute error should be $10^{−9}$ or less. 样例输入3 3 50 1 2 2 3 3 1 样例输出0.500000000000 题意zuhiul 和不超过14 个妹子存在着不清不楚的关系，但是他发现，有些妹子们相互之间是闺蜜，所以这些是闺蜜的妹子们有 $P$ 的概率会发现对面和zuhiul有关系从而导致关系破裂，现在问你多大的概率下，大家相安无事(妹子们还是一个联通图)． 分析数据量这么小，显然状压呀． 所以我们定义 $DP[i] 表示 state==i 时，i 包含的点相互联通的概率$ 那么比较容易得到答案就是 $ DP[(1&lt;&lt;n)-1] $ 现在我们考虑转移： ​ 因为要保证state内任意两点可达，所以我们不妨枚举出所有不可达的情况，容斥一下就行了． ​ 所以每次对于一个state，我们可以枚举他的每个点的子集，然后对于其他点到这个集合都割掉就行了 ​ 你问我为什么不会重复和遗漏？ ​ 这就要用到神奇的构造了． ​ 首先我们保证每个正确的点的子集里面都包含某一个点，那么对于包含这个点的所有正确子集来说肯定各不相同，这个保证了不会重复 ​ 然后怎么证明没有遗漏呢？ ​ 因为对于任何一个点来说，他都属于某一个联通块，我们实际上是在枚举每一个联通块，所以不会遗漏呀． ​ 恩，大概就是这样，详情请看代码． ​ 最后说一下复杂度． ​ 应该是 $O(\sum_{i = 1}^{n} C_n^i * 2^i) = O(3^n)$ 代码给大佬递上我奇丑无比的代码 (/ω＼)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;double p;double pow_p[100];int pow_2[100];int mat[100][100];void init()&#123; scanf("%d%d%lf",&amp;n,&amp;m,&amp;p); p/=100; pow_2[0] = 1; pow_p[0] = 1; for(int i = 1;i&lt;100;i++) pow_p[i] = pow_p[i-1]*p,pow_2[i] = pow_2[i-1]&lt;&lt;1; for(int i = 1,from,to;i&lt;=m;i++) &#123; scanf("%d%d",&amp;from,&amp;to); mat[--from][--to]++; mat[to][from]++; &#125;&#125;const int maxm = 1&lt;&lt;15;double dp[maxm];int has[100];int sub[100];void get(int state)&#123; dp[state] = 1; has[0] = 0; for(int i = 0;i&lt;n;i++) if(state&amp;(1&lt;&lt;i)) has[++has[0]] = i; if(has[0]==1) return ; for(int now = state&amp;(state-1);now;now = (now-1)&amp;state)&#123; if((now&amp;(1&lt;&lt;has[1]))==0) continue; sub[0] = 0; for(int i = 1;i&lt;=has[0];i++) if(now&amp;(1&lt;&lt;has[i])) sub[++sub[0]] = has[i]; int cnt = 0; for(int i = 1;i&lt;=has[0];i++) for(int j = 1;j&lt;=sub[0];j++)&#123; if(now&amp;(1&lt;&lt;has[i])) continue; cnt+=mat[has[i]][sub[j]]; &#125; dp[state]-=dp[now]*pow_p[cnt]; &#125;&#125;int main()&#123; init(); const int nouse = pow_2[n]; for(int i = 1;i&lt;nouse;i++)&#123; get(i); &#125; printf("%.10f\n",dp[nouse-1]); return 0;&#125;]]></content>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3829 FarmCraft]]></title>
    <url>%2F2018%2F12%2F02%2Fother_oj%2FBZOJ3829%2F</url>
    <content type="text"><![CDATA[题目描述In a village called Byteville, there are houses connected with N-1 roads. For each pair of houses, there is a unique way to get from one to another. The houses are numbered from 1 to . The house no. 1 belongs to the village administrator Byteasar. As part of enabling modern technologies for rural areas framework, computers have been delivered to Byteasar’s house. Every house is to be supplied with a computer, and it is Byteasar’s task to distribute them. The citizens of Byteville have already agreed to play the most recent version of FarmCraft (the game) as soon as they have their computers. Byteasar has loaded all the computers on his pickup truck and is about to set out to deliver the goods. He has just the right amount of gasoline to drive each road twice. In each house, Byteasar leaves one computer, and immediately continues on his route. In each house, as soon as house dwellers get their computer, they turn it on and install FarmCraft. The time it takes to install and set up the game very much depends on one’s tech savviness, which is fortunately known for each household. After he delivers all the computers, Byteasar will come back to his house and install the game on his computer. The travel time along each road linking two houses is exactly 1 minute, and (due to citizens’ eagerness to play) the time to unload a computer is negligible. Help Byteasar in determining a delivery order that allows all Byteville’s citizens (including Byteasar) to start playing together as soon as possible. In other words, find an order that minimizes the time when everyone has FarmCraft installed. 输入The first line of the standard input contains a single integer N(2&lt;=N&lt;=5 00 000) that gives the number of houses in Byteville. The second line contains N integers C1,C2…Cn(1&lt;=Ci&lt;=10^9), separated by single spaces; Ci is the installation time (in minutes) for the dwellers of house no. i. The next N-1 lines specify the roads linking the houses. Each such line contains two positive integers a and b(1&lt;=a&lt;b&lt;=N) , separated by a single space. These indicate that there is a direct road between the houses no. a and b. 输出The first and only line of the standard output should contain a single integer: the (minimum) number of minutes after which all citizens will be able to play FarmCraft together. 样例输入6 1 8 9 6 3 2 1 3 2 3 3 4 4 5 4 6 样例输出11 HitsExplanation: Byteasar should deliver the computers to the houses in the following order: 3, 2, 4, 5, 6, and 1. The game will be installed after 11, 10, 10, 10, 8, and 9 minutes respectively, in the house number order. Thus everyone can play after 11 minutes. If Byteasar delivered the game in the following order: 3, 4, 5, 6, 2, and 1, then the game would be installed after: 11, 16, 10, 8, 6, and 7 minutes respectively. Hence, everyone could play only after 16 minutes. 题意zuhiul是镇长，住在1号房子，镇里的房子构成了一颗树，现在zuhiul要给镇里其他房子里的小姐姐送电脑，每经过一条路径，zuhiul都要花掉一分钟(才不是为了看小姐姐)。但是zuhiul只负责送不负责装，每个小姐姐的脑子都比较奇怪，有些装的快，有些装的慢，最后zuhiul会返回自己的家给自己装电脑，然后他就可以和小姐姐视频了，但是必须要等所有的小姐姐都装好了才行，现在问你zuhiul最早什么时候可以和所有的小姐姐视频。 分析显然是树上DP，我们考虑定义DP状态，则有 f[i]表示以 i 为根的子树里，花费总时间的最大值是多少 我们定义son_num表示这个节点对应子树的节点数量 然后我们考虑转移，我们首先考虑怎么搞两个子节点的时候，然后进行推广。 不妨假设这两个字节点分别是a和b，然后可以得到先遍历a再遍历b的最大时长为 max(f[a]+1,f[b]+son_num[a]*2+1) 同理，先遍历b的最大时常为max(f[b]+1,f[a]+son_num[b]*2+1) 所以如果有max(f[a]+1,f[b]+son_num[a]2+1)&lt;max(f[b]+1,f[a]+son_num[b]2+1) 因为f[a]+son_num[b]2+1&gt;f[a]+1并且f[b]+son_num[a]2+1&gt;f[b]+1 所以只需要得到 f[b]+son_num[a]2&lt;f[a]+son_num[b]2 也即 f[b]-son_num[b]2&lt;f[a]-son_num[a]2 同样，对于多个节点来说，我们同样只要对每个子节点按照 f[son]-son_num[son]*2降序排序，然后从前往后贪心选就行了。 代码给大佬递上我奇丑无比的代码 (/ω＼) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxm = 7e5+10;struct p&#123; long long t,son_num;&#125; peo[maxm];long long len;vector&lt;int&gt;mat[maxm];long long f[maxm];int ind[maxm];bool cmp(int a,int b)&#123; return f[a]-peo[a].son_num*2&gt;f[b]-peo[b].son_num*2;&#125;void dfs(int a,int pre)&#123; peo[a].son_num = 1; if(a!=1) f[a] = peo[a].t; for(int i:mat[a])&#123; if(i==pre) continue; dfs(i,a); &#125; ind[0] = 0; for(int i:mat[a])&#123; if(i==pre) continue; ind[++ind[0]] = i; peo[a].son_num+=peo[i].son_num; &#125; sort(ind+1,ind+ind[0]+1,cmp); long long now = 0; for(int i = 1;i&amp;lt;=ind[0];i++)&#123; f[a] = max(f[a],f[ind[i]]+now+1); now+=peo[ind[i]].son_num*2; &#125;&#125;void solve()&#123; printf("%lld\n",max(f[1],len*2-2+peo[1].t));&#125;int main()&#123; scanf("%lld",&amp;len); for(int i = 1;i&amp;lt;=len;i++) scanf("%lld",&amp;peo[i].t); for(int i = 1,a,b;i&amp;lt;len;i++) &#123; scanf("%d%d",&amp;a,&amp;b); mat[a].push_back(b); mat[b].push_back(a); &#125; dfs(1,0); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200410]]></title>
    <url>%2F1020%2F04%2F10%2Fdiary%2F2020%2F04%2F20200410%2F</url>
    <content type="text"><![CDATA[11:18努力的人总该会拥有姓名。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200408]]></title>
    <url>%2F1020%2F04%2F08%2Fdiary%2F2020%2F04%2F20200408%2F</url>
    <content type="text"><![CDATA[17:52今天天气真好，适合见你。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200404]]></title>
    <url>%2F1020%2F04%2F04%2Fdiary%2F2020%2F04%2F20200404%2F</url>
    <content type="text"><![CDATA[23:51越是焦急的时候，越是不能降低标准，不然真的容易出大乱子。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200403]]></title>
    <url>%2F1020%2F04%2F03%2Fdiary%2F2020%2F04%2F20200403%2F</url>
    <content type="text"><![CDATA[00:39刚刚和嘉祺聊了一下，感觉自己舒服多了。 生活还是要继续啊，不然能怎么样呢？ 01:27你是毒药，也是良药。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200402]]></title>
    <url>%2F1020%2F04%2F02%2Fdiary%2F2020%2F04%2F20200402%2F</url>
    <content type="text"><![CDATA[23:49今天又搞了个事故。 晚上和老大聊的时候，无声落泪。这应该是这辈子第一次觉得这么难受吧。 其实这两周，不是很忙，虽然偶尔加班到深夜，但是我不难受，真的。 我一直秉承着“不求无功，但求无过”的想法。但是短短一个月搞了两个事故。今天实在忍不住了，情绪有点崩溃，实在是有点丢人哈。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200401]]></title>
    <url>%2F1020%2F04%2F01%2Fdiary%2F2020%2F04%2F20200401%2F</url>
    <content type="text"><![CDATA[01:31今天愚人节，真想听你撒谎说喜欢我。 12:42少年的快乐在于分享，后来的快乐在于占有。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200330]]></title>
    <url>%2F1020%2F03%2F30%2Fdiary%2F2020%2F03%2F20200330%2F</url>
    <content type="text"><![CDATA[22:17穷养出志气，富养出气质。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200329]]></title>
    <url>%2F1020%2F03%2F29%2Fdiary%2F2020%2F03%2F20200329%2F</url>
    <content type="text"><![CDATA[00:36嗯，有一点难过，我以为我会难受到不能自已，还好没有哈。 挺好的，当断不断，不断则乱。是该继续心无旁骛的努力了。 怪只怪自己有能力喜欢别人，没能力让别人喜欢自己。 诀别了哈，这应该是我为数不多的能称得上“青春”的东西了。 为什么你们都能习惯孤独？我挺怕孤独的。 给一个挚友打了个电话，我能感受到他是在劝解我，但是莫名的听不进去？ 不说了，再说就矫情了，生活还得继续不是？ 真想自己是太阳啊，这样无论是不是开心，第二天都能照常升起不是？ 09:58以前一直觉得你是小桥流水人家，只是暂时得不到法门进入，但是站在门外看看风景也是好的。 后来才发现你是堡垒，之前的防备是常态。这次可不就是被射成筛子了。 11:38如果痛恨黑暗，就把自己变成光。 23:16怕你不讲道理，却更怕你讲道理。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200325]]></title>
    <url>%2F1020%2F03%2F25%2Fdiary%2F2020%2F03%2F20200325%2F</url>
    <content type="text"><![CDATA[14:10知好色而慕少哀。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200324]]></title>
    <url>%2F1020%2F03%2F24%2Fdiary%2F2020%2F03%2F20200324%2F</url>
    <content type="text"><![CDATA[18:14中午不睡下午崩溃。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200322]]></title>
    <url>%2F1020%2F03%2F22%2Fdiary%2F2020%2F03%2F20200322%2F</url>
    <content type="text"><![CDATA[14:44谁又知道孤独和自由的区别呢？]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200320]]></title>
    <url>%2F1020%2F03%2F20%2Fdiary%2F2020%2F03%2F20200320%2F</url>
    <content type="text"><![CDATA[20:20大学那几年是我为数不多不用关心今天星期几的日子。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200319]]></title>
    <url>%2F1020%2F03%2F19%2Fdiary%2F2020%2F03%2F20200319%2F</url>
    <content type="text"><![CDATA[00:05为了让自己以后不那么为难，现在必须为难自己。 12:26锻炼过猛，浑身酸痛。 20:24这男女之间的事情，一旦挑明了，就没有挽回的余地了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200318]]></title>
    <url>%2F1020%2F03%2F18%2Fdiary%2F2020%2F03%2F20200318%2F</url>
    <content type="text"><![CDATA[11:54没经历过也就不会怀恋。 15:44所有忘掉之前欢愉的指责都是无耻行为。 17:02刚刚走在路上风太大，眼镜被刮走了。。。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200317]]></title>
    <url>%2F1020%2F03%2F17%2Fdiary%2F2020%2F03%2F20200317%2F</url>
    <content type="text"><![CDATA[00:27努力不那么笨拙。 00:31该冲动的时候冲动，该冷静的时候冷静。 10:08哪能真的不后悔自己干过的蠢事。 15:21情不知所起，一往而深。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200303]]></title>
    <url>%2F1020%2F03%2F03%2Fdiary%2F2020%2F03%2F20200303%2F</url>
    <content type="text"><![CDATA[18:10今天有点累了，外部协调工作实在是太累了，推动别人做事情永远是困难的。 有点怀恋学校养老的日子。 今天难得的没忍住脾气，发火了。感觉还是自制力不够。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200220]]></title>
    <url>%2F1020%2F02%2F20%2Fdiary%2F2020%2F02%2F20200220%2F</url>
    <content type="text"><![CDATA[10:11昨天晚上就有一点偏头痛，大概12点就睡了，刚睡醒写完日报，头还是有一点疼，而且疼的莫名其妙，毫无征兆。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200213]]></title>
    <url>%2F1020%2F02%2F13%2Fdiary%2F2020%2F02%2F20200213%2F</url>
    <content type="text"><![CDATA[10:01昨天晚上又做噩梦了，极其真实且恐怖，以至于现在还有一点后怕。 具体内容不描述，害怕一语成谶。 感觉是这几天压力有点大了，这周六好好休息一下。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200212]]></title>
    <url>%2F1020%2F02%2F12%2Fdiary%2F2020%2F02%2F20200212%2F</url>
    <content type="text"><![CDATA[21:19好几天没写日记了，倒不是真的懒了，是因为真的忙了，每天忙到凌晨一两点。 我不知道这个状态是好的还是不好的，我更多的把他归结于成长必经的一道坎，算是为了还之前欠下的所有的债。 然后今天发生的一件比较有意思的事是，我被老姐喷了，说我太蠢了，大家都是成年人了，谈个恋爱不能只看当下，两个人要展望一下未来。然后提到了一点现实问题。感触还挺深的。 的确，我都20多了，时间过的真的很快，我不知道是不是每个人都这么觉得，我感觉时间不是线性流逝的，反而呈现一种加速状态，小学的时候，觉得几分钟好快啊，高中觉得一天好快啊，这段时间觉得一年好快啊。日子就这么糊弄糊弄就过去了。 我还是适合被推着走，或者说我的水平还是不太够，只能被推着走。一旦让我去push一件事的时候，反而会让我有一种踹不过气的感觉。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200205]]></title>
    <url>%2F1020%2F02%2F05%2Fdiary%2F2020%2F02%2F20200205%2F</url>
    <content type="text"><![CDATA[20:14京天下雪了，那津天呢？]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200204]]></title>
    <url>%2F1020%2F02%2F04%2Fdiary%2F2020%2F02%2F20200204%2F</url>
    <content type="text"><![CDATA[17:29 PM向往有条不紊的生活，而不是每天赶鸭子上架。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200122]]></title>
    <url>%2F1020%2F01%2F22%2Fdiary%2F2020%2F01%2F20200122%2F</url>
    <content type="text"><![CDATA[10:43今天看了一下疫情情况，给我一种“瘟疫公司”的感觉？ 今天又看到了一个阴谋论，有没有可能这是大佬们的游戏？毕竟医学是最烧钱的，也是最挣钱的，然后所有的下层人员，无论是医生还是民众，都成了棋子。 这种想法其实挺危险的，也挺有意思的。我倒还有一点点赞同。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200121]]></title>
    <url>%2F1020%2F01%2F21%2Fdiary%2F2020%2F01%2F20200121%2F</url>
    <content type="text"><![CDATA[words我将所处何处，又将魂归哪里？]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200119]]></title>
    <url>%2F1020%2F01%2F19%2Fdiary%2F2020%2F01%2F20200119%2F</url>
    <content type="text"><![CDATA[18:20刚上完厕所出来。洗手的时候突然想到一件事。 为啥都是上完厕所之后才洗手，始终觉得，我全身上下手是最脏的。。。。为啥不是洗完手之后上厕所？？ words对于那种每次想到都能心悸不已的人，一定要谈恋爱，最好娶回家。 我觉得最有意思的爱情大概就是，我父母把你当闺女，你父母把我当儿子，我宠你如女儿，你待我如哥哥。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200118]]></title>
    <url>%2F1020%2F01%2F18%2Fdiary%2F2020%2F01%2F20200118%2F</url>
    <content type="text"><![CDATA[13:05睡到现在点了外卖。昨天真是玩累了。 早上一去就是追各种case。然后下午四点坐地铁转大巴去团建。 第一次玩卡丁车，第二次真人cs，第一次海底捞外卖。 一直在想一个问题，人该用什么来证明自己的存在呢？倒不是说要在历史上留下浓墨重彩的一笔，而是，在几十年后回想自己的一声的时候，和看其他人普通的一生到底会有何不同呢？到底有多少事情才是自己能记住并能发出欣慰的笑容，懊悔的表情呢？ words没有小姐姐的日子，一如既往的无聊。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200115]]></title>
    <url>%2F1020%2F01%2F15%2Fdiary%2F2020%2F01%2F20200115%2F</url>
    <content type="text"><![CDATA[17:05刚刚在群里聊到了显卡的事。想到了玩factorio，疯狂造机器人，电脑有点受不了。就来了一句，我也想要显卡。嘉祺回了句，你想要富婆。 想到之前一直说的一句话：“有没有富萝莉，请给我准备一打”。 如果有认识富萝莉的，请务必介绍给我。我也不想努力了。哈哈哈哈哈哈哈。 words“Is life always this hard. Or is it just when you’re a kid?”“Always like this.”]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200113]]></title>
    <url>%2F1020%2F01%2F13%2Fdiary%2F2020%2F01%2F20200113%2F</url>
    <content type="text"><![CDATA[17:52阻塞了，偷个懒写一点日记。 前天和奇哥被一个大佬拉去滑雪了。玩的倒是挺开心的。可能是因为学过轮滑的缘故，我的平衡能力比奇哥好，所以前期的时候我比他好，奇哥倒是一直摔的挺惨的。。。orz 然后我就膨胀了，作死挑战了一下高难度的，然后就飞了，对没错，是飞着甩出去的。。 玩的倒是挺开心的，昨天后遗症就来了，由于长时间没有运动，昨天基本上在家躺了一天，实在是太痛了。浑身酸痛啊啊啊啊啊啊。 中午起床点了个外卖，下午睡了会，晚上我，嘉祺，奇哥和奕去搓了一顿，hy去陪小姐姐了，害，有女人忘了兄弟。 然后晚上回来后就看了会电视剧，打了会游戏。 路过一个卖瓜子和糖葫芦的，买了个糖葫芦，买了两斤瓜子，就当办年货了，太真实了，一个人去买年货了解一下。直到此刻，还不想家。真实。 今天还是酸痛，但是要好多了，起码能动弹了。然后就是日常搬砖。今天进度有点慢，感觉今晚要加班了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200110]]></title>
    <url>%2F1020%2F01%2F10%2Fdiary%2F2020%2F01%2F20200110%2F</url>
    <content type="text"><![CDATA[14:01其实过年不想回家，其实也是对自己的考验，看自己是否真的对生活了十几年的家都没有一丝一毫的眷恋感。如果过年的时候还没有一丝一毫的感觉的话，可能真的需要考虑一下这个问题了，自己是从什么时候开始变的这样的呢？ 至少在目前看来，过年一周假和十一一周假在我看来其实没有太多区别。过年对我来说更多的是一种象征意义而无实际作用。仔细想想，感觉整个湖北真的有那种我非见不可的人吗？或者说有思念至极的人吗？倒还真没有，这样一想，其实我也挺可悲的。说透了就是没朋友呗。 20:09没找到一个特别好看的壁纸，不开心。 words我可能是得了一种害怕孤单又恐惧交际的病。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200109]]></title>
    <url>%2F1020%2F01%2F09%2Fdiary%2F2020%2F01%2F20200109%2F</url>
    <content type="text"><![CDATA[10:31今天早上走在上班的路上，想到自己很多时候都轻易放过了一些事。 定个小目标，暂不限时间，算是改掉一个坏习惯。 从 “想不明白-&gt;不想明白” 到 “想不明白-&gt;想要明白” 转变。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200108]]></title>
    <url>%2F1020%2F01%2F08%2Fdiary%2F2020%2F01%2F20200108%2F</url>
    <content type="text"><![CDATA[13:06总感觉这一周无比的漫长。今天居然才周三，今天不应该是周五吗？明天难道不该放假吗？ 又感觉这一周无比的短暂。好多事都没有做好就已经结束了。 可能是被一些烦心事打扰到了，然后精神状态不是很好。 这世间所有的惫懒可不都是不想努力，但是又想出成果嘛。 想到自己这几年还挺可悲的，各种虚与委蛇，假意奉承，谈不上累，只是有些许无趣。 不过也可能是不太了解有趣的定义。 这人世间的有趣到底是什么？我不能说是什么，但我至少能说说不是什么。 至少不是这无聊枯燥的生活，这独处时一个人的寂寞，这疲乏不堪又不得不负重前行的苟且。 words寻一有趣之人。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200107]]></title>
    <url>%2F1020%2F01%2F07%2Fdiary%2F2020%2F01%2F20200107%2F</url>
    <content type="text"><![CDATA[10:52今天需求算是delay了，现在算是明白了一个道理，任何需求，优先解决外部依赖，我们自己的业务总是可以解决的问题，但是外部依赖，不提前解决，不可能预估需要多少时间。 12:59刚刚讲到做梦的事了。 想起来这几天，天天晚上做梦。可能是一直在想一些有的没的吧。 昨天晚上做梦梦到打游戏？？？游戏还挺好玩的？？？我起码玩过500+手游，居然对这个有感觉？？？这游戏居然还是黑白的？？？ 13:32中午吃饭的时候，老大和hr一桌。然后拉我过去了。然后就被怼到问对象的事。 然后就各种尝试介绍，我感觉有点搞的。 不过，有一句话倒是真的，我是真的不知道自己是否真的适合谈恋爱。 其实用理性的考虑这一件事，感觉对象就和心爱的东西一样。其实就是看你是否愿意舍得放弃某些东西，心爱的东西可能需要你的财富，对象可能还需要你的时间等等等等。当然收益也很显然，两个人的力量真的大于两个人，而且很多时候有一个能调动你情绪的人真的很难得。 (这个跳跃有点突然是因为我想到调动情绪，就想到了吵架。。。。 其实我现在特别能理解为啥需要门当户对，因为这可以极大的避免见识的不同而造成的吵架。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200106]]></title>
    <url>%2F1020%2F01%2F06%2Fdiary%2F2020%2F01%2F20200106%2F</url>
    <content type="text"><![CDATA[08:55 PM昨天晚上又做梦了，感觉这几天休息的一直不是很好，也可能是太长时间没有工作的缘故，一些事牵扯着，感觉精神头不是很好。 今天总算是把三方寄出去了，还是太懒了，主要是不想写字，太丑了。 现在突然对赶路有一种别样的情绪，似乎赶路就是“在路上”的感觉，似乎这样自己就是在进步的路上。 月初定的目标，又搁浅了几天，单词也没背几十个，书更是没看，说来羞愧。 嘉祺的答辩delay了，因为leader有事，百惠答辩结束了。还是挺希望他们拿sp的。因为我太清楚同行的人，差别万分之一就足够让人难受的了。 可能离我们放肆吃海底捞的日子不远了，哈哈哈哈。 总感觉这几天没什么干劲。也可能是因为今天没怎么打代码的缘故，今天主要就是沟通去了，但是沟通一天的结果就是今天可能上不了，就很没有干劲。 然后就很容易联想到小姐姐一次次的拒绝。其实拒绝倒还好，主要是那种挫败感真的不是那么容易接受的。 总感觉自己这几年的努力都显得有些可笑。当然没有道德绑架的意思，没有强迫的意思，只是总感觉努力似乎不重要，反正她要的什么你都不知道。 哎，还是太菜了。然后很容易陷入恶性循环。越不想努力越菜，越菜越不想努力。就很矛盾。 然后，昨天才发现，原来其他人看电视剧都是正常速度的。其实我很早之前和母亲讨论过这个问题，我的解释是，看电视剧是为了看剧情，演技反而没有电影那么重要，所以可以快点看，没必要浪费太多时间。 然后我母亲就说，那为啥不看书呢？ 我当时的狡辩是：看书没有看电视剧快。 其实但是就是随口胡诌的。现在回想一下，这个问题还是挺有意思的。 似乎自己从某一刻开始就不怎么喜欢看书了，除非万不得已，极少回去看书。虽然很清楚看书大有裨益。 就像我和小姐姐说的一样，我小时候真的挺喜欢看书的，更甚过打游戏或者玩乐。但是这种兴趣似乎在某个时间段遗失了。 约莫是高中的时候，因为大学的时候已经不看书了。感觉是个坏习惯。还是得沉淀一下。 words昨天一个朋友问我们说如果他有单身一辈子的想法会不会吓到我们。 尽管这已经是我一个人的第四年，尽管我已经完全习惯了一个人的生活，但我依然告诉他，会。 习惯并不等于喜欢，淡然不代表不在意。所有一个人的独角戏，都是在等待另一个人有一天掀开帷幕，那一刻，舞台上的山水楼阁花袍羽扇才有了色彩。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200105]]></title>
    <url>%2F1020%2F01%2F05%2Fdiary%2F2020%2F01%2F20200105%2F</url>
    <content type="text"><![CDATA[09:37 AM刚睡醒，昨天晚上做梦梦到小姐姐了。记录一下。 梦到她找我玩了，还是很开心的啊。 缘由是，她因为学习的缘故来到我的城市（好像我已经不在北京了？好像在湖北？因为细节里我爸也在。） 把我激动的，鞋都找不到了，然后拉着我爸去买鞋。（？？？我也不知道为啥） 然后我爸有点事要离开，我和我爸吵了一架。（？？？莫名其妙） 然后走在路上的时候，你打车，我给你打电话。然后我突然看到你了。（视力从未如此好，在车流中一眼看见一辆出租车后排的你。） 然后你下车，嘲笑我说为啥穿着拖鞋。（哈哈哈哈哈） 然后就说带你去吃饭，不知道为啥整个梦里时间观念特别清晰，当时是下午2：47， 我俩都没吃午饭，你都饿坏了。但是我长时间没出去逛，不知道哪里好吃。 正在问舍友我们该去哪吃饭。但是我舍友从始至终没鸟我。（还是得靠自己。） 然后你说陪我逛街买鞋。 然后就是各种逛。（细节已经不清晰了）。 然后闹钟响了。（服了。。。。） 03:56 PM想起来昨天和母亲聊天。 感觉自己一直是一个没有归属感的人。似乎对任何地方都没有归属感。 其实如果真要问原因的话，其实我也不是很清楚。总感觉自己是一个没有感情的人。 其实我一直挺担心这个的。总感觉这个比一个人没有信仰来的更可怕。 其实这个问题在很多方面都可以暴露出来。尤其是在我扔不用的东西的时候，往往没有一点怜惜，就好像不是自己的东西一样。 也可能是没有值得我珍视的东西出现？ words梦里见到的人，醒了就该去见她。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200104]]></title>
    <url>%2F1020%2F01%2F04%2Fdiary%2F2020%2F01%2F20200104%2F</url>
    <content type="text"><![CDATA[05:31 PM又是玩了一天。啊啊啊啊啊啊，羞愧。 今天被同学问到了概率论题目，但是啥都不会啊啊啊 啊啊啊啊啊 。 大二学的东西已经全部还给老师了。啊啊啊啊啊啊啊啊啊。 书到用时方恨少，数学一定要学好!]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200103]]></title>
    <url>%2F1020%2F01%2F03%2Fdiary%2F2020%2F01%2F20200103%2F</url>
    <content type="text"><![CDATA[12:06 AM今天早上背单词的时候突然感觉很烦躁，感觉自己已经很难静下心来学习了，感觉是个不好的现象，该反思一下，好好学习了。 定个学习方向的小目标。 三月底前（90天）： 2000单词 看完至少一本书 复习一门cs基础 冲冲冲！没有妹子就努力学习啊。 01:45 PM我电脑上挂着微信和qq，是为了收到心爱人的消息，而不是天天看群里你们叭叭叭讲一些无聊的东西。 06:39 PM今天搞黄反系统测试，强行找黄色图片试。MD，上班时间ghs。太刺激了。 我渐渐能理解那种背德的人反而会有一种快感的原因。那种冲破桎梏而且游走在边缘的感觉，体验反而有一点一样的快感？]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200102]]></title>
    <url>%2F1020%2F01%2F02%2Fdiary%2F2020%2F01%2F20200102%2F</url>
    <content type="text"><![CDATA[08:53 PM啊啊啊啊，一年就这么没了。还是挺快的。本来以为自己会有茫茫多的感慨，但是仔细想想好像没有什么想说的。 其实我挺怕现在这样的日子。没有追求的样子真的让人感到厌恶。每天都好像千篇一律，甚至元旦在我看来都是平平无奇。甚至给人一种枯燥的厌烦感。 三方总算是到了，反而没有当初答辩的时候的那种激情了。倒不是说对搞钱不感兴趣了，只是兴奋降低了很多。 今天被小姐姐冷暴力了。啊，难受！ words我将在茫茫人海中寻找我唯一之灵魂伴侣。得之,我幸;不得,我命.如此而已.]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20200207]]></title>
    <url>%2F1020%2F01%2F02%2Fdiary%2F2020%2F02%2F20200207%2F</url>
    <content type="text"><![CDATA[18:46萌生出了再看一遍雪中的冲动。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191231]]></title>
    <url>%2F1019%2F12%2F31%2Fdiary%2F2019%2F12%2F20191231%2F</url>
    <content type="text"><![CDATA[08:23 PM今年的最后一天了，很想去找小姐姐跨年啊啊啊啊啊。 刚刚打了个电话，她明天上班，所以今年是不行了。 啊啊啊啊啊啊啊啊啊啊啊，垃圾医院，垃圾医院，垃圾医院！ 话说这种感觉还挺爽的，感觉自己整个人都被调动起来了，思维从未如此清晰。然后一下就冲淡了。那可太刺激了。 然后小姐姐还是买到了回家的票。所以不出意外的话，今年应该是我一个人过年。啊啊啊啊啊啊，好难受啊。 快哭了。 不行了，明年的时候，我一定要和小姐姐一起跨年，而非一群男的。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191227]]></title>
    <url>%2F1019%2F12%2F27%2Fdiary%2F2019%2F12%2F20191227%2F</url>
    <content type="text"><![CDATA[10:10 PM昨天被舍友拉着去唱k到今天凌晨4点，上午直接睡到12点。实在是顶不住了。 然后中午开始打factorio到下午四点。重开了一个档。 然后就是专业会，还有180+天就毕业了，还是挺感慨的。大学真的是过得太快了，快的让人没有感觉，无论是浑浑噩噩还是碌碌无为，都挺快的。 然后就是找了个自习教室准备和奇哥一起打cf。晚上10点10分的南教三楼，刚考完研的日子里，每个教室还有几十人在自习，感觉自己大学真的有些许荒废。除了打比赛的日子里，很少会在10点多的时候还在学习，那个时候基本都是在宿舍床上躺尸。 就这样了，比赛快开了，溜了溜了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191226]]></title>
    <url>%2F1019%2F12%2F26%2Fdiary%2F2019%2F12%2F20191226%2F</url>
    <content type="text"><![CDATA[06:57 AM我现在无悲无喜，只是有一点好奇，到底是什么人能搞定你。 words我希望有个如你一般的人，如山间清爽的风，如古城温暖的光。从清晨到夜晚，由山野到书房。只要最后是你，就好。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191225]]></title>
    <url>%2F1019%2F12%2F25%2Fdiary%2F2019%2F12%2F20191225%2F</url>
    <content type="text"><![CDATA[今天吃完饭之后，就离开了，其实有她送我，我应该开心的。 刚开始的时候还没有察觉，随着我上车，一点点的远离天津的时候，慢慢的，悲伤就弥漫上来了。再后来就是渐渐失去感觉睡着了。 下车的时候还有一点迷茫，不知道自己是在北京还是武汉还是青岛。或者说潜意识里面几者没有区别？天正下着雨，倒是挺应景的。 回到宿舍放下东西就饿了，突然的很饿。就一个人出去吃东西了。 再次回到宿舍的时候就是日常的宿舍吹逼时间。我渐渐能理解为什么大学需要宿舍这种东西了，因为无论何时，无论你变的多么傻逼，遇到了多少困难，变得多么菜，他们总是能变着法的安慰你，带给你欢乐，让你有继续走下去的动力。 等到这一切结束，我开始打这段文字的时候，除了有一点的不甘心之外，倒是没有其他的任何情绪了。 其实主要也是我的问题，我把一切考虑的太过简单，或者说是太过顺利了。不过这件事的失败，不仅让我认识到了自己能力的不足，也让我这段时间的努力看起来有些可笑。 是时候清醒一点了。以后要更加自律，一点点改掉自己的坏习惯。学一点养气功夫，要沉得住气！ 巍峨的山峰从来都不是平坦的。成功的路上总是崎岖多过风景。 塞翁失马焉知非福，以后的日子谁知道呢？静待花开。 因为爱情]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191224]]></title>
    <url>%2F1019%2F12%2F24%2Fdiary%2F2019%2F12%2F20191224%2F</url>
    <content type="text"><![CDATA[昨天晚上她上晚班，所以早上7点钟才下班，我就7点钟给她发消息，让她吃早饭。 不知道是不是我自己想多了，反正感觉她在撒谎？理由如下： 如果是7点钟下班，从工作地点到宿舍需要半小时，我7点钟发的消息，我觉得一个正常人会在7.30左右看，因为那个时候刚下班，还不困，而且有时间玩手机。但是她是八点钟回复我的，这个时间点和她刚刚昨天起床的时间点刚好吻合。此外，当我提到她今天还有晚班的时候，她一脸茫然的样子。 今天晚上和明天是最佳的约会时间，但是她都刚好没时间。倒不是说时间赶巧，只是觉得有点好奇。 昨天下午她说要去医院帮忙，然后给我看了一个截图。首先，我觉得如果她没有感受到我的意思的话，我觉得是不用截图的，其次，如果她不知道我的意思，压根都不用和我说她没时间。最后，截图没有ps掉头像和名字。首先名字+医院or名字+学校是搜索不出来的，其次，头像不像一个30+的人，所以我只能解释这个截图是同学说的话。那么这个截图的说服力显然是不够的，至少对于我来说。尤其是她昨天对我提到过，她曾经为了请假而让同学帮忙发短信造假的事。 两天时间，我们先后碰到两次她的同学，但是她都没有解释过我是谁，反而她同学冲她笑笑。我不知道是什么意思，暂定为是她害羞。 下面是我自己认为的一些解释： 对于8点钟看消息，我可以理解成她在医院耽误了一部分时间，还有可能是真的是8点钟下班，而她记错了和我说是7点。至于为什么没有想起来今天是上晚班，我也可以解释成上完晚班后不太清醒。 关于时间的问题，如果真是要连续上两个晚班的话，确实存在这种情况。 关于截图的问题，确实有点冗余的感觉，反而给我一种“此地无银三百两”的感觉。没想到一个很合理的解释，只能强行解释为性格问题。 这一点只能解释为，她没有介绍人的习惯，可能在她同学想起来的时候她会解释吧。 其实啰嗦了这么多，其实只有一个问题在围绕着我，她是不是有对象了。 如果答案是“是”，那么上面的一切都可以很简单的解释了。因为答案都是显然的。如果不是，那我应该就很惨了，因为显然这一次又完蛋了。 此外，我还回忆起一个细节，她和我说，她舍友和她说过什么，但是她暂时不想告诉我，说下次有时间再说。 感觉这是一个很有用的信息，因为她舍友和她说的话，好像很关键的样子，因为在接下来的一段时间，她反复提到这个细节两三次，又反复强调让我不要在意，而且是在我没有追问的情况下。 感觉她舍友说的话就是悬在头上的审判之剑，应该影响了她对我的判断。 明天看结果吧，反正一个人在这里瞎猜也么有用。 上面的吐槽说完了，下面考虑一下昨天提到的问题。 我的感官上没有感觉到以前那么快乐，虽然偶有欣喜，但是没那么强烈。这让我产生了一点点怀疑，也即，我是否真的想开始恋爱。 对此我能想到的一个解释是：我对这一次见面准备，或者说考虑的时间太长了，然后必然会产生一种结果是，我对这次见面的预期非常高，一度会让我对你的评价打到一个很高的水平。然而这一次没有达到这个很高的预期，所以觉得很失望。 我不太清楚一个正常人谈恋爱的样子是什么样的？是只需要快乐就够了吗？ 都说人在成年的时候需要建立三观，但是我到现在其实都没有一个很清晰的恋爱观。听过/看过的故事/事故太多了，所以我有一点点畏惧？其实我想的有点多了，还好我及时回头了，至少有一点是不会错的，恋爱不是一个非此即彼的过程。而且看对眼是一件很难的事，不是想象中的那么简单。总会有或多或少的困难，我以为自己能搞定所有的问题，但是我显然是高估自己的能力了。 我是冲着恋爱来的，还是冲着结婚来的？ 这个问题，我还真的没细想过，开始的时候一直觉得自己是冲着结婚来的，恋爱是一种附属品，因为我自信我能搞定一切。现在回想一下，这样的想法是不对的，为什么结婚之前要恋爱呢？真的只是需要时间来相互认识吗？恐怕不仅仅是这样，其实每个人都有故事，但是不多，一两个月时间都足够讲完了，但是为什么很少有人能在恋爱一两个月的时间结婚呢？我今天仔细思考了这个问题，一个我认为比较满意的解释是：恋爱的过程是为了以后有一个很美好的回忆。其实结婚不仅仅是一种仪式，更多的是宣判了感情达到了一个峰值，甚至可能是全局最大值。或许这就是人们常说的情感基础吧。 所以说，我现在考虑的问题应该是该如何恋爱，而非该如何结婚。 未来的路怎么走？ 还记得今年定的三个目标：顺利毕业，坐等offer，等待。 offer到手了，毕业问题不大。 等待的结果现在为止，我也不知道是顺利还是失败。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191223]]></title>
    <url>%2F1019%2F12%2F23%2Fdiary%2F2019%2F12%2F20191223%2F</url>
    <content type="text"><![CDATA[昨天见了小姐姐，开心！ 一件比较搞的事，我以为以为所有专业考研都是考四门，也即都考到昨天下午5点钟。但是她不考数学，所以下午没考试？？？ 我下午四点半到她学校，傻乎乎等到5点钟。然后？？？她没考试在睡觉？？？打扰了。 今天她晚上有晚班，然后早上我睡过了，手机还欠费了。。。然后她说中午有点事，所以我今天可能就得一个人逛了。 昨天带她去看《被光抓走的人》，感触挺多的，渐渐明白二刷的意义。当你站在一个对剧情全知全能的角度的时候，你能抓住之前没抓住的一些导演花心思的小细节。 回来的路上，我想了挺多的。 在见她之前的时候，我紧张，犹豫，彷徨。见的时候反而一切都消失了，对，那种快乐的感觉也消失了。当然也没有失望，就是感觉，我自己可能没有想清楚一件事。 就像我母亲曾经说过的，太长时间没谈恋爱，渐渐的可能都不会谈恋爱了。 我感觉我现在就处于这种状态，我不知道一个正常的情侣的日常是什么？我渐渐能明白为什么时间能冲淡两者之间的激情。 我曾一直以为，她就是那种，我想和她过日子的那种人。但是这一直都是我的主观臆测不是吗？我其实还没办法正式的去体验或者说经营一段感情不是吗？ 我觉得我需要想清楚这一件事后，可能才能有勇气或者说底气去表白，不然和耽误两个人的时间有什么区别呢？ 我曾回忆过很多次过去的日子，我一直标榜自己很理智，知道自己想做什么，想要什么，但是在这件事上我迷茫了。我并不知道我自己这几天在想什么，或者说我想做到什么。感觉更多的是在争一口气，而不像是沉迷爱情无法自拔。 除去一些龌龊的想法之外，我对一个人还有什么正儿八经的想法吗？我觉得那些东西才是一个人激情消退后的能让人感觉到历久弥新的东西。 其实也不是没有，我也想过我和她有一天一起起床，我做饭她洗漱，然后送她去上班，然后回家收拾收拾，我去上班，中午打个电话，晚上她回家等我，给我煮夜宵，晚上两个人躺在床上有聊不完的话题。 很平淡，也很有趣。但是我仔细思索了一下，这是我大概28-30左右该追寻的生活，那么现在呢？我需要的是什么呢？她报了四川大学，看了一下四川的公司，说实话，没有太让我心动的公司，所以我也没有足够的想法去跳槽。然后从北京最早的飞机到四川是10.30，然后转车去四川大学，需要一个小时，也就是最早11.30到。然后晚上最合适的一班是7.20走，十点到北京。按照这个时间，只能每两周放两天假的时候见面。 看起来时间还行的样子。 今天出门转转，好好想想吧。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191220]]></title>
    <url>%2F1019%2F12%2F20%2Fdiary%2F2019%2F12%2F20191220%2F</url>
    <content type="text"><![CDATA[今天突然产生一个念头，我现在是否适合恋爱呢？或者说我现在做好了开始一段恋情的准备了吗？我是否好久都没有考虑过该如何面对一个异性，如何继续的往下推进关系，如何解决两个人面对的问题，对于占用的时间我是否有一个预期，两个人在一起需要每天干嘛，我需要换一个她的城市还是继续留在北京，这些我是否认真的考虑清楚了呢？ 我不知道这些问题是必须要考虑的问题还是说随着时间推移就会有答案的东西，但是我不得不回想自己这一段时间的所作所为，我是否真的做好了准备，或者说未来一段时间是否做好了准备？或者说这一切真的是我想要的吗？我现在唯一能想到的解释是：我觉得我的日子过于枯燥，或者说一成不变，我需要一个人来带动我，让我有一点起码的动力，能够有兴趣去学习或者说尝试更多的东西。 感觉现在盲目的可能性更大，但是确实是想和她谈一次恋爱，这是真的。只不过可能还没有完全准备好，但是那种冲动是真真切切的。 偶尔突然想到她的时候，就会不自主的想两个人如果在一起会怎样怎样，然后会一阵阵的心跳加快，然后安静到能听到自己的呼吸和心跳。这种感觉真的好久都没有过了，感觉如果真有一个人能随时影响你某一刻的状态，就算不是喜欢，那开展一段感情总不会是错的。相比于几个月前一直担心你的拒绝，到后面反而没有那么担心了。 其实我也想过了，说到底无非就两个结局：接受，或者拒绝。接受当然是最好的。但是万一被拒绝了，我就准备安心学习了。匹夫何以言勇，同样的道理，菜鸡岂敢言强。努力成长呗，不然还能咋样呢。 其实偶尔想想也挺有意思的，我没想过自己到底缺的是一个对象，还是缺一个倾诉的对象，或者是两者都有？以前的时候不怎么和别人说话，一直是自己一个人闷着，倒也没有觉得很难受，但是现在有些时候真的还挺麻烦的，有些事想找你倾诉，而且每说一句话都猜测你看到的时候会是什么样子。这或许是他人说的感情？ 这世间的所有，大体分为三种： 第一种，该是你的，你怎么也扔不掉。 第二种，不是你的，你怎么也找不到。 游离在这二者之外的，才是你毕生的追求，你需要努力甚至拼命才能拿到的，一旦你得到，就像生命绽放了最美的华彩，充实而满足。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191218]]></title>
    <url>%2F1019%2F12%2F18%2Fdiary%2F2019%2F12%2F20191218%2F</url>
    <content type="text"><![CDATA[这几天实在是太懒了。好多事都一拖再拖。实在不能拖了才去做。看了一下这两个月的日记更是少之又少，惭愧惭愧。 这几天基本都是上午不起床，中午午睡一会，或者直接开始看操作系统，然后看的差不多就玩一会手机和魔方，然后晚上开始打factorio。有点上瘾，第一次对一个游戏这么上瘾。感觉有点沉迷了，在昨天的时候卸载了。 重点说说factorio。毕竟好几周天天打到凌晨三四点。。。。 游戏模式很简单，目标也很简单：发射火箭。 期间最重要的几个问题是： 活下去（你是有敌人的）！ 不断的发展科技（科技是第一生产力）！ 合理的规划（前期一个垃圾的设计，会让你后期非常恼火，而且修改困难）！ 及时重构（在玩通关两次之前，很多时候你对完整的体系不清楚，不可能避免所有的糟糕设计，甚至前期会有很多临时方案，及时重构，保证系统的健壮性）！ 时刻进步（不要等待，有些时候我会陷入一种前面科技研究完了，下一种瓶子还没出来的尴尬局面。很多时候就是因为我在看着传送带发呆。。。。）。 其实我仔细思考了从中大体了解到的这几点，我发现这真的是很适合一个程序员或者一个设计师玩的游戏。从中真的能明白不少东西，最重要的一点是：很杀时间（不知不觉就天亮了）。 还有就是回家发现了我小学时候的玩具：魔方。已经忘得差不多了，用了大概两天时间捡了回来，还是挺有意思的。看操作系统视频的时候，没事就玩玩魔方。（然后就是回放。。。。完全不能同时干两件事）。 最后就是昨天去看了个电影，被光抓走的人，哇，真的挺好看的，强烈建议各种人去看。故事讲的挺好的。 (PS: 对了，我紫了，哈哈哈]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019半年总结(20190306-20191128)]]></title>
    <url>%2F1019%2F11%2F28%2Fdiary%2F2019%2F11%2F20191128%2F</url>
    <content type="text"><![CDATA[从今年三月六号到现在，一直在头条这边实习，已经过去大半年了，是时候写个总结了。 真的很感激头条给的这个机会，能在这里学到很多东西，真的感觉自己成长了很多。明白了自己不会的东西还有很多，还需要继续努力。了解了做工程和打比赛不一样的地方。 本来有很多话想说的，突然噎住了。。。。上次想了很多，突然忘了。。。。。 我觉得对我个人而言影响最大的就是老大说的一句话：任何时候，你都需要具备一种快速解决问题的能力，无论你最后是不是写代码的人，这种能力都会让你在各行各界混得开。这句话说的真的挺对的，我其实在相当长的时间里面陷入了一个误区，那就是我这辈子都干程序员了，然后我一直觉得代码写的好看就够了。现在回想起来这个想法其实很蠢的。更多的时候，公司需要的不仅仅是你打代码的能力，更多的是一种解决问题的素质。而公司里面的问题，可不仅仅包括写代码。 还有就是时机。其实我理解一个约成熟的公司，机会应该是越多，但是反而很多展示自我的机会都被我自己浪费了。我在相当长的一段时间里面，都认为我和公司是雇佣关系，所以我来这边只是为了帮公司解决问题的，所以很多时候解决问题就完事了，很多东西都没有深入思考，或者说没有自己的见解。后来渐渐明白一件事，我和公司更多的应该是一种合作关系，我在帮公司做事的同时，我其实可以接触到更多的东西，不仅对公司的收益是个正增长，而且对个人成长也是有很大帮助的。可惜的是，等我想明白这一点的时候，就基本到了我离开的时候了。 最后就是环境，头条这边给我的感觉是一种很舒心的感觉。虽然偶尔也会加班。但是这种东西就和打比赛一样一样的，也分两种，一种是你宁可加班也要搞好，而且搞好了很有成就感，另外一种就是宁愿给我钱我也不相干的，至少头条这边大多数时候加班时间是前者。虽然偶尔会觉得累，但是开心的时候会更多。 接下来一部分用来回顾我的大学。 其实我一直觉得，除了高考没考好这件事没法改变以外，我从出生到现在，一直觉得自己是一个很幸运的人，或者说是幸运的部分大于了我努力的部分。初中及其以前的事就不说了，从高中开始讲起。 因为家里管的比较严的缘故，所以高中时候基本没怎么出去浪，更多的时候都是老老实实的好好学习。（整个高中没去过一次网吧的98年学生，你敢信？）该好好玩的时候，高一高二好好玩了，用功还行，努力真说不上。该努力的时候我也真的是玩命了。想想自己每天晚上刷题到12点，挺感激那时候的自己。 高考没考好其实是一件塞翁失马的事。现在回头看，可能好的成分居多：来到了一个看得过去的学校，认识了一群和蔼可亲的老师，有一宿舍的哥们，取得了以前不敢想的比赛成绩，有几个关系贼好的队友。就差一个如花似玉的对象和一个所向披靡的学习成绩，哇，简直人赢有没有？ 这辈子为数不多的做过几件我觉得不算蠢的事就是，我会提前想自己要的是什么，然后做好规划，初中知道自己读理，高二知道自己学计算机，大一知道自己要打比赛，大三知道自己要找工作。其实也说不上规划，中间有一大部分的阴差阳错。所以很多时候还挺怕自己活在梦里。。。。 大学正儿八经在学校的时间可能也就三年不到，如果在上课才算在上大学的话，可能一年半？惭愧惭愧，读书实在是不行，怪我怪我。 不太清楚别人对努力的定义是什么，个人理解是：主动把事情推向更好的方向。所以高一高二按部就班的上课写作业考试，真的说不上努力，更多的是在被推着走，或者说过的浑浑噩噩更多一些。仔细回想一下，努力的时候应该只能算高三和大二，这两段时光真的是努力了。也只有那个时候我是真的清楚自己在做什么，为了什么而做，意义何在，结果如何。 如果说大学有什么遗憾的话，最大的遗憾应该是没有找个对象，其次就是没有好好打比赛，然后就是没有好好学习，剩下的，我觉得没有遗憾了。个人来说，我脾气其实很不好，到了大学收敛了很多，更多的时候是自己一个人生闷气，所以自问没有得罪别人，如果有，那我也不认！哈哈哈哈哈哈。 未来努力的方向：看更多的书吧，大学看的书有点少了，或者说很多东西没有钻透，书到用时方恨少啊。 就这样，下棋下棋！]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191024]]></title>
    <url>%2F1019%2F10%2F24%2Fdiary%2F2019%2F10%2F20191024%2F</url>
    <content type="text"><![CDATA[这段时间要拍类似于毕业证上的照片这种东西，然后我就去拍了一下，在高曝光下，看到了自己气色好差。这段时间熬夜实在太多了。感觉以后要早点休息了。然后这几天每天保证12点之前睡觉。可能是之前熬夜太多了，这段时间虽然睡的很足，但是精神头还是不是很好。感觉以后真的需要好好休息了。 然后学校的学习还是遥遥无期，这周末应该要抽空写一下学校的作业了。也该看看操作系统的书了。水平还是太菜了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191017]]></title>
    <url>%2F1019%2F10%2F17%2Fdiary%2F2019%2F10%2F20191017%2F</url>
    <content type="text"><![CDATA[明天提测，所以今天在赶进度，因为我的原因，导致几个问题的跟进都堆积在同组其他人手中。导致我们进度失衡。 反思了一下，大部分是我的原因，有时候不怎么想跟进问题，觉得和他人沟通是一件很麻烦的事。此外，技术问题也很关键，不能第一时间反应出问题的根源在哪。主要是之前做的那一套没有吃透。后面也没有花时间补。导致自己没有很快速的处理问题。 难受是有一点的，后面继续努力吧。 还有就是关于最后一门必修课的事，还是有点慌，老师不是很好说话，所以可能答辩完就想回学校养老了。看情况，这几周的面试都不是很理想，可以说基本都凉了。老老实实搬砖吧。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191011]]></title>
    <url>%2F1019%2F10%2F11%2Fdiary%2F2019%2F10%2F20191011%2F</url>
    <content type="text"><![CDATA[今天又被老大喷了，老大的意思是我效率太低了。其实这几天我认为是没有很重要的事，所以这几天我基本都是在摸鱼，大部分时间是在刷题，虽然mentor看到了，但是可能是他觉得这段时间确实没事，所以没管我，因为刚好三个方向，他们三个正式工吧。然后就没我啥事了。于是我也就心安理得的再摸鱼。结果被老大看出来了。自然是被喷了。 然后我仔细思考了一下，我为什么会变成这样，然后我突然醒悟过来，我的想法还停留在我有无限的可能的层面，因为我一直觉得我未来不一定属于这里，我可能会去任何一家公司，所以这段时间，尤其是在十一假期期间，什么事都没有放在心上。现在回想一下，其实挺愚蠢的。我忽略了一个重要的事，那就是我做事的时候，我也在成长。忽略了这个细节，导致我潜意识里始终觉得，做事是亏了。愚蠢至极！ 接下来一段时间要安安心心做事了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191010]]></title>
    <url>%2F1019%2F10%2F10%2Fdiary%2F2019%2F10%2F20191010%2F</url>
    <content type="text"><![CDATA[今天水到cf_784E，看到了熟悉的数字电路处理。但是最后还是模拟过的。想电路图化简来着，然而立马发现，自己啥都不会了。突然一种悲哀油然而生。自己的大学到底学了一坨什么东西？很多课程已经忘的干干净净了，这是自己想要的吗？]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20191010]]></title>
    <url>%2F1019%2F10%2F10%2Fdiary%2F2019%2F10%2F20191031%2F</url>
    <content type="text"><![CDATA[今天有点难受，一个需求因为一些奇奇怪怪的原因没有达到预期效果。同事没有直接喷我，但是我从他的表情中读出了不情愿。 感觉是时候离开了，我的精力被分散的太厉害了，而我的能力并不足以支撑我去想太多东西。 或者说这一两个月以来，我过的并不开心，但是谁又会在意你开不开心呢？或许我该考虑一下，自己是否真的适合这份工作呢？我感觉现在的自己陷入了一个恶性循环。太多的时候过的浑浑噩噩了。每天非但没有进步，反而状态在不断的下滑。我也不知道自己是否真的哪一天就绷不住了。 其实我也知道，一直是我自己的问题导致现在很多，嗯，应该说是不是很好的结果。 很多时候是因为我似乎总是在逃避什么？大多数的时候给自己的借口是：我不会。我可能一直没想清楚一个问题是：别人不会给你太多时间让你成长。他们会不断的push你，让你做这做那。我又不好意思拒绝，以至于很多时候甚至压得我踹不过气。我从前一直劝解自己，没事，熬过这段就好了。但是有时候又感觉像是压死骆驼的最后一根稻草，不知道自己是不是某一天突然就绷不住了。 有时候又感觉生活挺难的。以前自己没有感受到生活的压力的时候还没什么，现在自己才一个人就有点顶不住了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190926]]></title>
    <url>%2F1019%2F09%2F26%2Fdiary%2F2019%2F09%2F20190926%2F</url>
    <content type="text"><![CDATA[今天突然想到一个问题，我这段时间是否太过于被动了，很多时候都是自我被动成长。居然已经很久都没有主动学习了。 很多时候都想着准备好了再上，但是仔细回想一下，很多时候都不会让你准备好了再上。所以更多的时候，我们应该做的是，努力准备，一旦发生，快速解决。 首先就是积累，没有积累，没有成长。其次是，认可自己，觉得自己可以。最后就是努力做好，不要想当然的觉得可行就ok。 对自己要求高一点，不要60分就满足，甚至50分就满足，追求更优解。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190925]]></title>
    <url>%2F1019%2F09%2F25%2Fdiary%2F2019%2F09%2F20190925%2F</url>
    <content type="text"><![CDATA[今天仔细想了想，我是否有我想象中的那么努力。很多时候，被别人吹捧了一下，难免会飘飘然。这个时候，很难冷静的思考一下。今天突然意识到这个问题。 我是否有自己想想的那么努力呢？显然没有，我仔细回忆了大学这几年，说实话，幸运的程度高于努力。 似乎自从高考失利之后，一直都比较幸运。幸运的参加了ACM，幸运的取得了比较理想的成绩，幸运的面试过了几家公司，幸运的遇到了一个比较好的老大。 然后看看自己的努力？ 算不上多努力罢了。因为自己懒，所以比赛也没有好好打。因为懒，每天空闲时间也没有学习，反而用来打游戏。因为懒，很多事情都被自己搁浅了。这种程度的努力，真的不值一提。 以后要更加努力啊。游戏小说什么的，还是适可而止吧。现在也一个人一个房间了，接下来的目标：早睡早起。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190923]]></title>
    <url>%2F1019%2F09%2F23%2Fdiary%2F2019%2F09%2F20190923%2F</url>
    <content type="text"><![CDATA[昨天被子送算是到了，算是彻底安顿下来了。 过生日，饭都没吃，还加班到晚上，第二天照常上班。 我居然会觉得很正常，可能这就是长大的代价？ 答辩的时间遥遥无期，想点的技能点太多，但是自己又太懒。这几天的状态不是很好，希望接下来的双月能调整好状态。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190919]]></title>
    <url>%2F1019%2F09%2F19%2Fdiary%2F2019%2F09%2F20190919%2F</url>
    <content type="text"><![CDATA[今天生日啊！ 昨天交完房租，今天就灰溜溜的来上班了。生活所迫，没办法啊。 刚来就需求评审。有点累。 找奇哥借了5000。手上有20000，但是房租18000，交完房租我基本就是个废人了。 这就是成年人的世界吗？手上小几万，一天就没了。啊，我死了。 加油加油！]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190915]]></title>
    <url>%2F1019%2F09%2F15%2Fdiary%2F2019%2F09%2F20190915%2F</url>
    <content type="text"><![CDATA[今天老妈非拉着我去给我买了两条裤子，我们在路上闲聊的时候，她又扯到我的小姐姐身上了，然后她就疯狂问我关于她的各种问题。我就各种说不知道。 我是真的不知道，她家里干什么的，她家里有几个孩子，她家里有一年挣多少，她家里父母文化水平是多少。 我是真的不知道，也不关心，我现在依然觉得，我喜欢的是她，不是吗？我自认为自己的水平还算不错，无论她家里什么情况，我都欣然接受，因为我觉得你要和她在一起的时候，无论她家里怎么样，你都至少可以改变自己不是吗？ 嗯，就酱紫，要和小姐姐谈一场甜甜的恋爱。]]></content>
      <tags>
        <tag>HER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190909]]></title>
    <url>%2F1019%2F09%2F09%2Fdiary%2F2019%2F09%2F20190909%2F</url>
    <content type="text"><![CDATA[这几天请假回学校玩了几天，感到很是堕落，每天的事都是今天拖明天，明天拖后天，感觉拖延症都上来了。不像以前的我。说实话这几天都不知道该干啥。当时回来之前给自己的定位是养老，但是真的养老的时候反而感觉到不适应。难道是因为真的不适合养老吗? 很多时候明明很慌，但是为什么又不想努力呢?到底说还是自己太懒了。然后实在是不想等下去了。明天处理完这边的事就准备回家了。 回家其实也没有太多事。不知道干啥。 其实我主要想说的是，我这段时间突然有点迷茫，不知道自己到底想要的是什么，很多时候我都会说想搞很多很多钱，但是我后来渐渐发现，我要的可能不是这个，因为这种想法往往禁不起后一步 推敲，比如进一步问我:搞了很多钱，然后呢?说实话我答不上来。我真的不知道自己想要的到底是什么。 我一直觉得，一个人又仔细想要的东西是一件很美好的事，他能让一个人有奋斗的目标，但是一旦你发现这个目标没有意义的时候，你就非常难受了。你会突然发现一切的努力没有了意义。 不说了，后天走的话，明天事还挺多的，先打游戏去了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190905]]></title>
    <url>%2F1019%2F09%2F05%2Fdiary%2F2019%2F09%2F20190905%2F</url>
    <content type="text"><![CDATA[从3.6到今天刚好半年时间，不知不觉已经来北京半年了，感慨挺多的。期间发生了很多事，下面一一总结。 首先就是比赛的事，虽然是上上个月就已经决定了，但是还是很多想说的。我之前一直觉得不回学校打比赛是因为父母的缘故，后来仔细想了想，可能不止于此吧。可能更多的是自己的想法。不怪队友，真的是自己没有了当年的激情了，或许真像水先生说的那样，自己已经被温水煮青蛙了。可能几年后再来回想这件事可能会有不同的看法吧。 其次就是自己在头条这边的成长，说句公道话，我没去过别的地方，所以暂时不做对比，单说头条。首先对于一个刚毕业或者说还没毕业的人来说，头条还算是比较肝的了，但是我始终觉得这种肝对于一个没有任何工程能力的人来说是非常有意义的。其次，头条这边的环境真的很好，尤其给我最深的一点体会就是，大家都是想把某个东西做好，且不说每个人出力多少，但是所有人朝着一个方向迈进，总会有所成就不是吗？最后就是：头条的伙食真的很好，我已经胖了10斤了。俨然是一个看起来20多，实际上刚20的中年油腻大叔，哈哈哈哈。 然后就是自己的脾气，真的是好了很多，可能是因为工程能力太菜了的缘故，很多时候都是陈述自己的意见，那种强迫奇哥接受我的想法的日子，一去不复返了。哈哈哈哈哈。对不起奇哥。 还有就是挺感谢头条给我的六个月，尤其是老大。初入职的第一个老大真的是非常重要了。我眼里一个完美老大的样子，不是他技术有多牛（当然，我老大也很厉害），而是他现在的样子，是否是你追求的样子，或者说，你想成为他那样的人吗？如果你“不幸”遇到了，那真的是能爽一辈子的事。真不巧，我老大就是这样。哈哈哈哈。 然后就是见了相见的小姐姐。还是挺爽的。没怎么出门玩过的人，可能稍显木讷，感觉被嫌弃了。orz。 还有108天，等着呗，很快的。 还没答辩就溜了，实在是太累了，没时间写ppt 啊啊啊。 昨天收拾东西的时候第一次感受到了六个月时间有多长，大概就是，刚来北京的时候我穿的是羽绒服，厚外套。昨天收拾东西的时候，我一个大男人的衣服硬生生有两个箱子+一书包？]]></content>
      <tags>
        <tag>个人总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190901]]></title>
    <url>%2F1019%2F09%2F01%2Fdiary%2F2019%2F09%2F20190901%2F</url>
    <content type="text"><![CDATA[这几周实在是忙昏了头，周报都没写，实在是有点懒了。 这几周有点迷茫了，很多东西都想学，但是还是一如既往的懒，好多东西都是想学的，但是因为懒，还用了没有时间作为了借口，实在是不应该啊。 然后这周四可能要回学校养老了，实在是需要时间来整理整理自己的东西了。 每天忙忙忙也不是个事。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190825]]></title>
    <url>%2F1019%2F08%2F25%2Fdiary%2F2019%2F08%2F20190825%2F</url>
    <content type="text"><![CDATA[今天看到一个人，虽然我从来没有和他说过话，但是我对他很反感，我突然间想到一件事，为什么我会对一个从来没有交流过的人，没有任何交集的人感到反感？ 仔细的思考了一下，大概原因是我是通过了我比较信任的人的描述，而产生了我脑补自己对他印象的现象。无论这个印象是否真实，但是一旦产生几乎不可更改。导致了我后来对他产生的反感。 想明白这一点之后，突然就感觉到可怕。人言可畏啊，很多时候都不用众口铄金，很多时候听了一个人的意见，就足以产生很大的印象。感觉以后很多事情需要有更多自己的思考。记录于此，引以为戒。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190816]]></title>
    <url>%2F1019%2F08%2F16%2Fdiary%2F2019%2F08%2F20190816%2F</url>
    <content type="text"><![CDATA[昨天晚上和大哥哥打了个电话，他和我说了很多事，我突然明白一个道理，一个人的无心之失真的会对一个人造成那么大的影响。 都是自己当时太年轻了，居然会犯那么傻屌的错误，还渐渐的遗忘了，实在是罪过。最近找个时间弥补一下吧。不然真的会后悔一辈子吧。 明确未来要做的三件事 1.等待 2.事业 3.毕业 加油吧，努力成长，静待怒放。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190812]]></title>
    <url>%2F1019%2F08%2F12%2Fdiary%2F2019%2F08%2F20190812%2F</url>
    <content type="text"><![CDATA[今天在清理历史消息的时候，突然发现一个事，那就是HR，5月份的时候拉了个群，意思是这个群里都是有实力转正的，但是没有我，直到7月底的时候才把我拉进去，这样我就不开心了。 不是，我就不懂了，这个意思是我不行呗？反正很不爽，突然就不想干活了，真的想一走了之，管他什么呢。 然后就直接找老大聊了一下，老大说他知道这个事，和我解释说，老大们没有对齐标准导致的。 好吧，我勉强能接受这个解释，但是说实话，我真的略失望。反正这样做搞的人很不爽。不开心，不开心，不开心！ 就这样吧。 可能有一天，等我攒够了失望就会离开。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190807]]></title>
    <url>%2F1019%2F08%2F07%2Fdiary%2F2019%2F08%2F20190807%2F</url>
    <content type="text"><![CDATA[听说今天是七夕，所以说也是我老爸的生日。 公司这边实在是太忙了，暂时没有时间想对象的事。刚刚给爸爸打了个电话，谁知道他已经睡了。确实有点晚了。 然后就是这个月底如果转正顺利的话，可能就要考虑回家一趟了。确实是好久没有回家了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190803]]></title>
    <url>%2F1019%2F08%2F03%2Fdiary%2F2019%2F08%2F20190803%2F</url>
    <content type="text"><![CDATA[今天刚看完了《哪吒之魔童降世》，颇有感触。 实际上最打动我的那一幕就是哪吒白化前的那一幕，哪吒的父亲，愿意和哪吒换命。一个二十好几的大老爷们真的是在影院无声的哭了。真的是挺打动我的。突然间就想到了我的父亲。我仔细的思索了一番，如果换做是我的父亲，他会怎么做，我感觉他同样不会犹豫。当时想到这个就哭了出来。为人父母真的是挺不容易的。 和哪吒一样，我从小一直很蠢。可能认识我的人都不会想到我曾经语文+数学都考不到60分。但是我小时候就是这个尿性。因为父母都是老师，同事的孩子也和我一般大。所以经常拿来做比较，因为父母很敬业，所以没有时间管教我，导致我小时候一直很差，不难想到父母因为我而失望过多少次。但是他们有放弃过我吗？没有，他们总是很有耐心的教育我。 再后来，我开始渐渐明白人事。也就是那个叛逆的年纪，开始不懂事。总是有意无意的气父母，着实很不该。现在回想起来，真的是很后悔当初的所作所为。可能在父母眼里，我永远是一个长不大的孩子吧。 想起来上周给家里打了个电话，我能明显感觉到母亲接到电话时那种欣喜的语气，反而让我感觉甚为羞愧。实在是想象不到，父母这个角色忍受了多少不该忍受的东西。那种不求回报的给予，真的很让人感到敬佩。 其实我一直以来都算不上听话，想起来上次我母亲用个软件，弄了半天还是没有弄好，给我整着急了，我就很不耐烦了。后来有一天我母亲和我说，让我对她有点耐心，毕竟他们渐渐的老了，不像以前那样灵光了。就像他们小时候对我一样，多给他们一些耐心。听完这个之后，我就很难受了。我一直觉得我已经长大很多了，但是实际上呢？还是动不动就惹父母生气，实在是罪过。 再回想一下，我是真的对父母的耐心很差了，他们也确实老了，而我呢？正处于上升期，很多时候都不太愿意听父母的建议。很多时候希望自己能拿主意，甚至很抵触父母的建议。但是大多数时候会发现他们的建议是对的，他们毕竟经历的比我们多多了。但是还是碍于面子，自己做决定了，现在回想一下还是真傻。在父母面前是最不用面子的。他们何曾求过我有一天能大富大贵呢？他们无非就是祈祷我能多回家看看罢了。然而这个愿望我在后面不知道还有多少日子的日子里，还能圆他们几次愿望呢？ 上次回家还是过年吧。总说自己忙忙忙，但是自己是真的忙吗？每天还有一个小时的时间用来打游戏，哪能算得上真忙呢？无非就是觉得他们很烦罢了吧？现在想想着实不该啊。为什么总是有这种幼稚、无聊的想法呢？ 不早了，先睡了。明天给家里打个电话吧。就这样，晚安。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190714]]></title>
    <url>%2F1019%2F07%2F14%2Fdiary%2F2019%2F07%2F20190714%2F</url>
    <content type="text"><![CDATA[昨天晚上给家里打了个电话，说了关于回学校继续比赛的事，实在是没想到家里人的反应会那么大，母亲的意思是，坚决反对我回学校打比赛。导致我昨天晚上想了很久关于是否回学校的事。 然后我回想了一下当时我们三个人讨论的事情，毫无疑问，我是主张不回去打比赛的，那么为什么让我动摇了呢？是因为他们两个都要回去吗？我一向自诩为遵从内心，自由生长。为何此刻就一直摇摆不定？ 我现在无非担心的两件事就是：我没有回去，他们打金了；我回去了，结果和去年一样。 毫无疑问，我其实更担心后者。 昨天问了一下奇哥，关于金牌和sp的把握，分别是75%和80%，其实在我心里分别是50%,60%，说真的，我不知道从那一刻开始，对很多东西不抱有希望了，很多时候都没有当初入学的那种激情了。正是这种激情的缺失，导致我一度不想回学校打比赛。奇哥的意思是，为什么不去尝试更多可能？可能我回学校发现那种激情又回来了？我对这种想法持怀疑态度。我感觉还是过早接触了不该接触的东西，导致我现在心思已经完全不在这上面了。就像淌过的时间之水，一去不返了。 然后奇哥说，如果我不回去，他还是有可能会去打比赛。我仔细思考了一下母亲说的，我是学校最厉害的人吗？虽然我一度这么觉得，但是结果是显然的——我不是。那么在三个人六个月没训练的情况下，他们完全足够和任何人进行磨合，而且结果不会太差。如此说来，我不回去其实没有我想的那么愧疚。哎，这糟心事。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190702]]></title>
    <url>%2F1019%2F07%2F02%2Fdiary%2F2019%2F07%2F20190702%2F</url>
    <content type="text"><![CDATA[今天上午已知在忙学校的事，真的被学校的事折磨死了，带我们小学期的老师感觉还不好说话。 我就不懂了，为什么每次好不容易被工作搞的有一点激情了，紧接着就被学校的破事消耗殆尽，甚至搞的身心俱疲。 学校那些死板的规定，天知道是哪一天定下来的，这么长时间没有被修改过了，恐怕已经被无数人诟病了，为什么就不能修改一下呢？我至今任不明白，学校到底是在培养什么样的人？从前的我一直以为是对社会有用的人，后来想想恐怕不是。为什么社会都承认的人，在学校还因为一些傻屌规定频频受阻？教育的病态性已经不容多说了，一直很好奇这种涉及到国家未来的事会一拖再拖？现在还提不出一个有效的方案？算了，无力吐槽了，毕竟这么多年来，都是我这样无病呻吟，没有权力导致碌碌无为的人，毕业了之后就没精力去改变什么了，说到底我也是作恶者罢了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190626]]></title>
    <url>%2F1019%2F06%2F26%2Fdiary%2F2019%2F06%2F20190626%2F</url>
    <content type="text"><![CDATA[今天早上5.30就起了，好久都没有起这么早过了。 除了周五的最后一个考试，这学期就算是结束了。 这两天因为天天在学校玩，所以有很多时间想一些自己的事。这里索性总结一下吧。 首先就是大学的日子，仔细想想，自己的大学貌似从大二毕业就已经死掉了。或者说从大一下半学期就已经死掉了。已经记不清自己逃了多少课，每次考试都是划水划过去的。大三上逃的课比上的都多。大三下直接就出来工作了。整个大学除了舍友和少数几个朋友，其他人真的只是点头之交。这其实和我刚入大学的想法还是很不一样的。曾经的我不是没有想过做一个学霸，但是出于种种原因，渐渐放弃了这个想法，不是天资不够，实在是努力不够，或者说努力的方向不一样。当时还是太喜欢打比赛了。说到底还是太想证明自己了。回头想了想，当时应该是因为高考成绩太差了，所以对成绩失望了，想找到一个方向，告诉自己我还行，不是那么差，所以找了一条人迹罕至的路。现在回头想想，没有后悔和失落，也没有欣喜和狂欢，只有默默的努力和玩乐。直到后来在这条路上渐行渐远的时候，我已经开始迷失了。其实大三上还是太颓废了，很多该学的东西都没有学好。现在就是各种踩坑啊啊啊啊。 还有就是工作的事，今天得知比我晚来的实习生要走了，问了一下，他的想法是在这边学不到什么东西，而且时间实在是太紧了，让他抽不出时间来学习。这个问题其实我上个月就已经意识到了，然后找15级几个学长问了下，他们的意见是，大部分互联网公司都一个逼样，所以不用太过忧愁，毕竟是没有去过其他公司，所以暂时不知道具体现象是什么样。暂时就先留在这里吧，转正再说。 然后就是考研的问题，现在时间上已经不足6个月了，我算是彻底放弃了，这个时间太不凑巧了，时间卡的太不好了，很多事都需要在这六个月里面完成，所以显然是来不及了。而且当时想考医学研究生显然是一时心血来潮，毕竟想和小姐姐再玩两年。后来想想还是算了，惹人厌烦。总给人一种逼宫的感觉，而且自己水平实在是不太够，虽然舍友每天都奶我，说我考必中，其实我知道无非是大家平时开玩笑之类的话罢了。随着年龄的增大，越来越不会嫉妒别人，因为我清楚的知道，每个人的努力和回报成正比，没有人能随随便便成功。虽然我不否认有些天才，但是没有不用付出的天才，不是吗？ 最后就是比赛了。因为和工作冲突的缘故，公司这边说是要8月底才能转正。但是如果9月才开始训练的话，三个月可能还是来不及，很可能还是和去年一个水平，那么我觉得浪费这三个月时间没有任何意义了。暂时还是没想好，看队友想法吧。我的话，自我感觉已经没有了大一刷题的激情了，还是老了，再也刷不动夜了，很多问题甚至是不想深究了，甚至是轻易的放过去了，导致大二结束到现在反而是水平跌落很多了。 算了不说了，继续搬砖去了。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常吐槽20190626]]></title>
    <url>%2F1019%2F06%2F26%2Fdiary%2F2019%2F08%2F20190802%2F</url>
    <content type="text"><![CDATA[今天终于是周五了，这周不知道为什么感觉特别的累，真的是由身到心的累。没有原因的那种。而且我感觉这周应该是7月最摸鱼的一周了，但是还是感觉很忙的感觉。 然后昨天写了一下周报，看了一下我写的东西，看起来是挺多的，但是仔细想想其实都是杂货，没什么技术含量，主要就是各方沟通吧。 其实应该在每个技术宅的眼里，默默写完自己的代码，然后run的很健壮，应该是一件很爽的事吧。]]></content>
      <tags>
        <tag>日常吐槽</tag>
      </tags>
  </entry>
</search>
