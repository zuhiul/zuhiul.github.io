<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>睡到二三更时      凡荣华皆成幻境</title>
  
  <subtitle>每份努力,必有回报</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zuhiul.github.io/"/>
  <updated>2020-01-22T02:50:51.469Z</updated>
  <id>http://zuhiul.github.io/</id>
  
  <author>
    <name>zuhiul</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Project Euler 698 123 Numbers</title>
    <link href="http://zuhiul.github.io/2020/01/22/PE/PE698/"/>
    <id>http://zuhiul.github.io/2020/01/22/PE/PE698/</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-01-22T02:50:51.469Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=698" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>We define <em>123-numbers</em> as follows:</p><ul><li>1 is the smallest 123-number.</li><li>When written in base 10 the only digits that can be present are “1”, “2” and “3” and if present the number of times they each occur is also a 123-number.</li></ul><p>So 2 is a 123-number, since it consists of one digit “2” and 1 is a 123-number. Therefore, 33 is a 123-number as well since it consists of two digits “3” and 2 is a 123-number.<br>On the other hand, 1111 is not a 123-number, since it contains 4 digits “1” and 4 is not a 123-number.</p><p>In ascending order, the first 123-numbers are:<br>$1,2,3,11,12,13,21,22,23,31,32,33,111,112,113,121,122,123,131,\dots$</p><p>Let $F(n)$ be the $n-th$ 123-number. For example $F(4)=11$, $F(10)=31$, $F(40)=1112$, $F(1000)=1223321$ and $F(6000)=2333333333323$.</p><p>Find $F(111111111111222333)$. Give your answer modulo $123123123$.</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义一种数字：</p><ul><li>1是这种数字</li><li>如果一个数字在10进制下只包含1，2，3，并且这些数字出现的次数也是这种数字，那么这个数字也是这种数字。</li></ul><p>将这种数字从小到大排序后得到一个序列，问你这个序列的第 $111111111111222333$ 项 % $123123123$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一个简单的想法是，对于每个固定长度的数字，我们可以得到所有可行的答案数。基于这个想法我们能很快定出答案的长度。</p><p>然后现在已经知道答案的长度了，我们可以枚举每一位答案，看当前位应该是几。</p><p>然后答案就很明显了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">num = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">111</span>,<span class="number">112</span>,<span class="number">113</span>,<span class="number">121</span>,<span class="number">122</span>,<span class="number">123</span>,<span class="number">131</span>]</span><br><span class="line">upper = <span class="number">111111111111222333</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">20</span>): </span><br><span class="line">        <span class="keyword">if</span> num[i] == a:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fac</span><span class="params">(a)</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a*fac(a<span class="number">-1</span>) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">C</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fac(a)/fac(b)/fac(a-b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">real_get</span><span class="params">(a, b, c, length)</span>:</span> </span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">20</span>):</span><br><span class="line">        <span class="keyword">if</span> num[i] &gt; length:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> num[i] &lt; a:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">20</span>):</span><br><span class="line">            <span class="keyword">if</span> num[i] + num[j] &gt; length <span class="keyword">or</span> length - num[i] - num[j] &lt; c:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> num[j] &lt; b <span class="keyword">or</span> check(length - num[i] - num[j]) == <span class="keyword">False</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ret = ret + C(length-a-b-c, num[i]-a) * C(length-b-c-num[i], num[j]-b)</span><br><span class="line">    <span class="keyword">return</span> ret </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equal</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a==b:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">50</span>):</span><br><span class="line">    buf = real_get(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,index)</span><br><span class="line">    <span class="keyword">if</span> upper &gt;= buf:</span><br><span class="line">        upper = upper - buf</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> index, upper</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">a = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, index):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">        buf = real_get(a[<span class="number">0</span>] + equal(j, <span class="number">0</span>), a[<span class="number">1</span>] + equal(j, <span class="number">1</span>), a[<span class="number">2</span>] + equal(j, <span class="number">2</span>), index)</span><br><span class="line">        <span class="keyword">if</span> upper &gt; buf:</span><br><span class="line">            upper = upper - buf</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a[j] = a[j] + <span class="number">1</span></span><br><span class="line">            ans = ans * <span class="number">10</span> + j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">print</span> ans % <span class="number">123123123</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=698&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Project Euler 317 Firecracker</title>
    <link href="http://zuhiul.github.io/2020/01/13/PE/PE317/"/>
    <id>http://zuhiul.github.io/2020/01/13/PE/PE317/</id>
    <published>2020-01-12T16:00:00.000Z</published>
    <updated>2020-01-13T12:41:43.076Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=317" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>A firecracker explodes at a height of $100$ m above level ground. It breaks into a large number of very small fragments, which move in every direction; all of them have the same initial velocity of $20 m/s$.</p><p>We assume that the fragments move without air resistance, in a uniform gravitational field with $g=9.81 m/s^2$.</p><p>Find the volume (in $m^3$) of the region through which the fragments move before reaching the ground. Give your answer rounded to four decimal places.</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个爆竹在 $100$ 米的高度上爆炸了，碎片以 $20m/s$ 的速度往四面八方迸射。假设当地有 $g = 9.81m/s^2$  的均匀重力加速度。问你所有碎片经过的体积。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其实我刚拿到题就意识到可能是一个我不会的知识。</p><p>然后队友想都没想来了句，抛物线的包络线。。。orz</p><p>如果知道包络线这种东西就很简单了。推导过程如下：</p><p>$ x = u \cdot cos\theta \cdot t$</p><p>$ y = u \cdot sin\theta \cdot t - \frac{1}{2} g \cdot t^2 + 100$</p><p>联立后消去 $t$ :</p><p>$y = tan\theta \cdot x - \frac{g \cdot sec^2\theta}{2u^2} \cdot x^2 + 100$</p><p>对 $\theta$ 求导有：</p><p>$\frac{dy}{d\theta} = sec^2\theta \cdot x - \frac{g \cdot x^2}{u^2} tan\theta \cdot sec^2\theta$</p><p>令上式等于 $0$ 有：</p><p>$tan\theta = \frac{u^2}{gx}$</p><p>带到原式有：</p><p>$y = \frac{u^2}{2g} - \frac{g \cdot x^2}{2u^2} + 100$</p><p>$\therefore y_{max} = \frac{u^2}{2g} + 100$ </p><p>$\therefore x^2 = \frac{u^4}{g^2} - \frac{2u^2Y}{g} + \frac{200u^2}{g}$</p><p>然后对每个圆积分，有</p><p>$answer = \big(\int_{0}^{100+\frac{u^2}{2g}} \frac{u^4}{g^2} - \frac{2u^2Y}{g} + \frac{200u^2}{g}dY\big)<em>\pi = \frac{u^4Y}{g^2} - \frac{u^2Y^2}{g} + \frac{200u^2</em>Y}{g}\big|_0^{100+\frac{u^2}{2g}}*\pi$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这题我是手算的　(<em>/ω＼</em>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=317&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Project Euler 292 Pythagorean Polygons</title>
    <link href="http://zuhiul.github.io/2020/01/10/PE/PE292/"/>
    <id>http://zuhiul.github.io/2020/01/10/PE/PE292/</id>
    <published>2020-01-09T16:00:00.000Z</published>
    <updated>2020-01-13T09:28:10.079Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=292" target="_blank" rel="noopener">开启传送门</a> </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>We shall define a pythagorean polygon to be a <strong>convex polygon</strong> with the following properties:</p><ul><li>there are at least three vertices,</li><li>no three vertices are aligned,</li><li>each vertex has integer coordinates,</li><li>each edge has integer length.</li></ul><p>For a given integer $n$, define $P(n)$ as the number of distinct pythagorean polygons for which the perimeter is $≤ n$.</p><p>Pythagorean polygons should be considered distinct as long as none is a translation of another.</p><p>You are given that $P(4) = 1$, $P(30) = 3655$ and $P(60) = 891045$.<br>Find $P(120)$.</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>我们定义满足以下条件的凸包是一个毕达哥拉斯多边形：</p><ul><li>至少包含三个点</li><li>不存在三点共线</li><li>所有点的横纵坐标都是整数</li><li>所有边长都是整数</li></ul><p>对于给定的 $n$，我们定义 $P(n)$ 是周长 $\leq n$ 的不同的毕达哥拉斯多边形的数量。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>显然可以记忆化搜索。</p><p>首先我们可以暴搜出所有可行的方向。可以发现可行的方向并不多。因为要求点和长度都是整数，意味着要么是平行x轴，要么是平行y轴，要么是一个两边长都是整数的直角三角形的斜边，而且斜边长是整数，例如 $(3,4,5)$ 。</p><p>然后为了保证是凸包，我们按照方向逆时针进行枚举，每次枚举出一个方向后，判断一下可以往这个方向延伸多少，然后check一下剩下的距离足够到原点嘛。稍微剪剪枝，就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_coordinate = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[max_coordinate &lt;&lt; <span class="number">1</span>][max_coordinate &lt;&lt; <span class="number">1</span>][<span class="number">130</span>][<span class="number">140</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> gcd(b % a, a);</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">if</span> (gcd(x, y) != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> buf = x * x + y * y;</span><br><span class="line">    <span class="keyword">int</span> sqrt_buf = <span class="built_in">sqrt</span>(buf);</span><br><span class="line">    <span class="keyword">if</span>(sqrt_buf*sqrt_buf==buf) <span class="keyword">return</span> sqrt_buf;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir</span> &#123;</span><span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">int</span> x, y, dis;</span><br><span class="line"></span><br><span class="line">    dir() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    dir(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> _dis) &#123;</span><br><span class="line">        x = _x, y = _y, dis = _dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line">dir all_dir[<span class="number">150</span>];</span><br><span class="line"><span class="keyword">int</span> len_all_dir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(dir a, dir b)</span> </span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">return</span> a.y * b.x &lt; a.x * b.y;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_all_dir</span><span class="params">()</span> </span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="comment">// domain 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">85</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">85</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (check(i, j))</span><br><span class="line">                all_dir[len_all_dir++] = dir(i, j, check(i, j));</span><br><span class="line">    sort(all_dir, all_dir + len_all_dir, cmp);</span><br><span class="line">    <span class="comment">// domain 2</span></span><br><span class="line">    <span class="keyword">int</span> len = len_all_dir;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) all_dir[len_all_dir++] = dir(-all_dir[i].x, all_dir[i].y, all_dir[i].dis);</span><br><span class="line">    <span class="comment">// domain 3, 4</span></span><br><span class="line">    len = len_all_dir;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) all_dir[len_all_dir++] = dir(all_dir[i].x, -all_dir[i].y, all_dir[i].dis);</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> len, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ans[x][y][len][ind] != <span class="number">-1</span>) <span class="keyword">return</span> ans[x][y][len][ind];</span><br><span class="line">    <span class="keyword">if</span> (x == max_coordinate &amp;&amp; y == max_coordinate &amp;&amp; len == <span class="number">0</span>) <span class="keyword">return</span> ans[max_coordinate][max_coordinate][<span class="number">0</span>][ind] = <span class="number">1</span>;</span><br><span class="line">    ans[x][y][len][ind] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ind; i &lt; len_all_dir; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ind &amp;&amp; all_dir[i].x == -all_dir[ind - <span class="number">1</span>].x &amp;&amp; all_dir[i].y == -all_dir[ind - <span class="number">1</span>].y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> upper = len / all_dir[i].dis;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= upper; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_x = x + all_dir[i].x * j;</span><br><span class="line">            <span class="keyword">int</span> new_y = y + all_dir[i].y * j;</span><br><span class="line">            <span class="keyword">int</span> new_len = len - all_dir[i].dis * j;</span><br><span class="line">            <span class="keyword">int</span> new_ind = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dis(new_x - max_coordinate, new_y - max_coordinate) &gt; new_len) <span class="keyword">continue</span>;</span><br><span class="line">            ans[x][y][len][ind] += gao(new_x, new_y, new_len, new_ind);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans[x][y][len][ind];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> upper = <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init_all_dir();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_coordinate &lt;&lt; <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; max_coordinate &lt;&lt; <span class="number">1</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">130</span>; k++)<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">140</span>; l++) ans[i][j][k][l] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= upper; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> buf = gao(max_coordinate, max_coordinate, i, <span class="number">0</span>);</span><br><span class="line">        ans += buf;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; buf &lt;&lt; <span class="string">' '</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=292&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt; &lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Project Euler 684 Inverse Digit Sum</title>
    <link href="http://zuhiul.github.io/2019/12/03/PE/PE684/"/>
    <id>http://zuhiul.github.io/2019/12/03/PE/PE684/</id>
    <published>2019-12-02T16:00:00.000Z</published>
    <updated>2019-12-03T13:18:52.766Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=684" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>Define $s(n)$ to be the smallest number that has a digit sum of $n$. For example $s(10)=19$.</p><p>Let $S(k)=\sum_{n=1}^k s(n)$. You are given $S(20)=1074$.</p><p>Further let $f_i$ be the Fibonacci sequence defined by $f_0=0,f_1=1$ and $f_i=f_{i−2}+f_{i−1}$ for all $i≥2$.</p><p>Find $\sum_{i=2}^{90} S(f_i)$. Give your answer modulo $1\ 000\ 000\ 007$.</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义 $s(n)$  表示最小的数位和为 $n$ 的整数，例如 $s(10) = 19$。</p><p>并定义 $S(k) = \sum_{n=1}^k s(n)$ ，例如 $S(20) = 1074$ 。</p><p>此外定义 $f_i$ 为fibonacci第 $n$ 项。</p><p>求 $\sum_{i=2}^{90} S(f_i) % 1\ 000\ 000\ 007$ 。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们有，$s(n)$ 的后缀显然是一串 $9$ ，前缀是某一个数字或者空。这样为最大。</p><p>然后一个简单的想法是，我们诸位统计答案，对于每一位来说，显然是存在 $1\rightarrow 9$ 。然后剩下的这个位置一定全是 $9$ 。这样可以统计出答案，但是我们发现，数据量太大了。$o(n)$ 的显然不太够。</p><p>我的做法是，我把每个数字都 $+1$ ，这样做的好处是，每一位一定是$1\rightarrow9$ 。然后后面的位数就是一个等比数列，然后稍微处理一下前面几位就可以了。</p><p>简单画个示意图，假设 $n = 20$。</p><p>老做法是这样：</p><table><thead><tr><th>百位</th><th>十位</th><th>个位</th></tr></thead><tbody><tr><td>$0$</td><td>$0$</td><td>$1\rightarrow9$</td></tr><tr><td>$0$</td><td>$1\rightarrow 9$</td><td>$9$</td></tr><tr><td>$1\rightarrow 2$</td><td>$9$</td><td>$9$</td></tr></tbody></table><p>然后我们诸位统计，答案的计算表达式大概是这样：${\sum_{i=1}^9 <em> 1 + 9</em>(n-9)} + {\sum_{i=1}^9 + 9<em>(n-18)}</em>10 + {\sum_{i=1}^2}*100$</p><p>新做法是每个数 $+1$ ，然后补一个 $1$ 然后总答案 $-(n+1)$ 。补 $1$ 后：</p><table><thead><tr><th>百位</th><th>十位</th><th>个位</th></tr></thead><tbody><tr><td>$0$</td><td>$0$</td><td>$1\rightarrow9$</td></tr><tr><td>$0$</td><td>$1\rightarrow 9$</td><td>$0$</td></tr><tr><td>$1\rightarrow 3$</td><td>$0$</td><td>$0$</td></tr></tbody></table><p>然后对于后缀是一个公比为 $10$ 的等比数列。可以直接统计：</p><p>$45<em>(1+10) + \sum_{i=1}^{3}</em>100 - (20+1)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;a%=mod, b%=mod;<span class="keyword">return</span> (a+b+mod)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;<span class="keyword">return</span> a*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b) &#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = mul(ret, a);</span><br><span class="line">a = mul(a,a);</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span> </span>&#123; <span class="keyword">return</span> qpow(a, mod<span class="number">-2</span>); &#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">ret = add(ret, mul(<span class="number">45</span>, mul(inv(<span class="number">9</span>), add(qpow(<span class="number">10</span>, a/<span class="number">9</span>), <span class="number">-1</span>))));</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> buf = a%<span class="number">9</span>+<span class="number">1</span>;</span><br><span class="line">ret = add(ret, mul(mul(buf, buf+<span class="number">1</span>), mul(inv(<span class="number">2</span>), qpow(<span class="number">10</span>, a/<span class="number">9</span>))));</span><br><span class="line">ret = add(ret, -a<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_num</span><span class="params">()</span> </span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"f_1 = "</span>&lt;&lt;num[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=<span class="number">90</span>;i++) &#123;</span><br><span class="line">num[i] = num[i<span class="number">-1</span>] + num[i<span class="number">-2</span>];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"f_"</span>&lt;&lt;i&lt;&lt;<span class="string">" = "</span>&lt;&lt;num[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">init_num();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=<span class="number">90</span>;i++) &#123;</span><br><span class="line">ans[i] = add(ans[i<span class="number">-1</span>],S(num[i]));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"sum of S(f_"</span>&lt;&lt;i&lt;&lt;<span class="string">") = "</span>&lt;&lt;ans[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=684&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 847 I</title>
    <link href="http://zuhiul.github.io/2019/09/23/CF/CF_847_I/"/>
    <id>http://zuhiul.github.io/2019/09/23/CF/CF_847_I/</id>
    <published>2019-09-22T16:00:00.000Z</published>
    <updated>2019-09-27T10:48:56.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-Noise-Level"><a href="#I-Noise-Level" class="headerlink" title="I. Noise Level"></a>I. Noise Level</h2><p><a href="http://codeforces.com/problemset/problem/847/I" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>The Berland’s capital has the form of a rectangle with sizes $n × m$ quarters. All quarters are divided into three types:</p><ul><li>regular (labeled with the character ‘.’) — such quarters do not produce the noise but are not obstacles to the propagation of the noise;</li><li>sources of noise (labeled with an uppercase Latin letter from ‘$A$’ to ‘$Z$’) — such quarters are noise sources and are not obstacles to the propagation of the noise;</li><li>heavily built-up (labeled with the character ‘$*$’) — such quarters are soundproofed, the noise does not penetrate into them and they themselves are obstacles to the propagation of noise.</li></ul><p>A quarter labeled with letter ‘A’ produces $q$ units of noise. A quarter labeled with letter ‘B’ produces $2\cdot q$ units of noise. And so on, up to a quarter labeled with letter ‘Z’, which produces $26\cdot q$ units of noise. There can be any number of quarters labeled with each letter in the city.</p><p>When propagating from the source of the noise, the noise level is halved when moving from one quarter to a quarter that shares a side with it (when an odd number is to be halved, it’s rounded down). The noise spreads along the chain. For example, if some quarter is located at a distance $2$ from the noise source, then the value of noise which will reach the quarter is divided by $4$. So the noise level that comes from the source to the quarter is determined solely by the length of the shortest path between them. Heavily built-up quarters are obstacles, the noise does not penetrate into them.</p><p><img src="http://codeforces.com/predownloaded/5a/7c/5a7cae99652db48cf802c68f3c82351b4084d138.png" alt=""></p><p><center><font size="1">The values in the cells of the table on the right show the total noise level in the respective quarters for q = 100, the first term in each sum is the noise from the quarter ‘A’, the second — the noise from the quarter ‘B’.</font></center><br>The noise level in quarter is defined as the sum of the noise from all sources. To assess the quality of life of the population of the capital of Berland, it is required to find the number of quarters whose noise level exceeds the allowed level $p$.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains four integers $n, m, q$ and $p$ ($1 ≤ n, m ≤ 250, 1 ≤ q, p ≤ 10^6$) — the sizes of Berland’s capital, the number of noise units that a quarter ‘$A$’ produces, and the allowable noise level.</p><p>Each of the following $n$ lines contains m characters — the description of the capital quarters, in the format that was described in the statement above. It is possible that in the Berland’s capital there are no quarters of any type.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print the number of quarters, in which the noise level exceeds the allowed level $p$.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1"><a href="#input1" class="headerlink" title="input1"></a>input1</h4><p>3 3 100 140</p><p>…</p><p>A*.</p><p>.B.</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>3</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>3 3 2 8</p><p>B*.</p><p>BB*</p><p>BBB</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>4</p><h4 id="input3"><a href="#input3" class="headerlink" title="input3"></a>input3</h4><p>3 4 5 4</p><p>..*B</p><p>..**</p><p>D…</p><h4 id="output3"><a href="#output3" class="headerlink" title="output3"></a>output3</h4><p>7</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>The illustration to the first example is in the main part of the statement.</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>zuhiul家里有很多妹子，但是有一天，妹子们对他都很不满，所以妹子们都在呼叫他，如你所见，妹子在一些点中，并且每个妹子的音量都是他的倍数，其中 A 表示一倍，B表示两倍，最厉害的妹子甚至可以喊出他 26 倍音量（也即 Z ），但是好处是，每个妹子的音量都会随着哈密顿距离指数级减半。zuhiul的耳朵有个承受上线，如果太多杂音，他会受不了。现在问，有多少个位置的音量是zuhiul可接受的。注意，他不能和妹子一个位置。也不能在*上。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一个显然的做法是，我们可以直接把每个有音量的地方传播下去，就可以得到一个比较完美的图。然后把音量叠加后枚举每个位置，判断当前音量是否超过阈值即可。</p><p>可以发现的是，因为每次音量都是倍减的，所以可以得到，最多倍减log次，所以对于一个音量来说，最大的传播范围是O($log(p_{max})<em>log(p_{max})$) ，所以复杂度是O($n</em>m<em>log(p_{max})</em>log(p_{max})$)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line"><span class="keyword">char</span> mat[maxm][maxm];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[maxm][maxm];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> dirx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> diry[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> vis[maxm][maxm];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;p&gt; vis_buf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;p&gt; q;</span><br><span class="line">vis_buf.resize(<span class="number">0</span>);</span><br><span class="line">q.push(p&#123;a,b,val&#125;);</span><br><span class="line">vis_buf.push_back(p&#123;a,b,val&#125;);</span><br><span class="line">vis[a][b] = <span class="literal">true</span>;</span><br><span class="line">ans[a][b] += val;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">p buf = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(buf.val==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> dir = <span class="number">0</span>;dir&lt;<span class="number">4</span>;dir++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = buf.x + dirx[dir];</span><br><span class="line"><span class="keyword">int</span> y = buf.y + diry[dir];</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=n||y&gt;=m) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(mat[x][y]==<span class="string">'*'</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">vis_buf.push_back(p&#123;x,y,<span class="number">0</span>&#125;);</span><br><span class="line">ans[x][y] += buf.val&gt;&gt;<span class="number">1</span>;</span><br><span class="line">q.push(p&#123;x,y,buf.val&gt;&gt;<span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:vis_buf) &#123;</span><br><span class="line">vis[i.x][i.y] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lld%lld"</span>, &amp;n, &amp;m, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, mat[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mat[i][j] == <span class="string">'*'</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> val = mat[i][j] == <span class="string">'.'</span> ? <span class="number">0</span> : (mat[i][j] - <span class="string">'A'</span> + <span class="number">1</span>) * a;</span><br><span class="line"><span class="keyword">if</span>(val==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">gao(i,j,val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;m;j++) <span class="keyword">if</span>(ans[i][j]&gt;b) rans++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;I-Noise-Level&quot;&gt;&lt;a href=&quot;#I-Noise-Level&quot; class=&quot;headerlink&quot; title=&quot;I. Noise Level&quot;&gt;&lt;/a&gt;I. Noise Level&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/problemset/problem/847/I&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1187 E</title>
    <link href="http://zuhiul.github.io/2019/09/20/CF/CF_1187_E/"/>
    <id>http://zuhiul.github.io/2019/09/20/CF/CF_1187_E/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2019-09-20T06:57:34.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="E-Tree-Painting"><a href="#E-Tree-Painting" class="headerlink" title="E. Tree Painting"></a>E. Tree Painting</h2><p><a href="http://codeforces.com/problemset/problem/1187/E" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given a tree (an undirected connected acyclic graph) consisting of $n$ vertices. You are playing a game on this tree.</p><p>Initially all vertices are white. On the first turn of the game you choose one vertex and paint it black. Then on each turn you choose a white vertex adjacent (connected by an edge) to <strong>any</strong> black vertex and paint it black.</p><p>Each time when you choose a vertex (even during the first turn), you gain the number of points equal to the size of the connected component consisting only of white vertices that contains the chosen vertex. The game ends when all vertices are painted black.</p><p>Let’s see the following example:</p><p><img src="http://codeforces.com/predownloaded/ad/4f/ad4fad5ce28ee4d1715321cbdee7db39ee67260c.png" alt=""></p><p>Vertices $1$ and $4$ are painted black already. If you choose the vertex $2$, you will gain $4$ points for the connected component consisting of vertices $2,3,5$ and $6$. If you choose the vertex $9$, you will gain $3$ points for the connected component consisting of vertices $7,8$ and $9$.</p><p>Your task is to maximize the number of points you gain.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer $n$ — the number of vertices in the tree ($2≤n≤2⋅10^5$).</p><p>Each of the next $n−1$ lines describes an edge of the tree. Edge $i$ is denoted by two integers $u_i$ and $v_i$, the indices of vertices it connects ($1≤u_i,v_i≤n$, $u_i\neq v_i$).</p><p>It is guaranteed that the given edges form a tree.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print one integer — the maximum number of points you gain if you will play optimally.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1"><a href="#input1" class="headerlink" title="input1"></a>input1</h4><p>9</p><p>1 2</p><p>2 3</p><p>2 5</p><p>2 6</p><p>1 4</p><p>4 9</p><p>9 7</p><p>9 8</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>36</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>5</p><p>1 2</p><p>1 3</p><p>2 4</p><p>2 5</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>14</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>The first example tree is shown in the problem statement.</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>zuhiul认识很多妹子（不超过$2\cdot 10^5$个），妹子之间是个树形关系。他决定每天聊一个妹子，但是他是个强迫症，第一天他可以随便聊任何一个妹子，但是之后每一天，他只能聊和之前聊过的妹子有关系的妹子。每次聊一个妹子之前，他会数一下这个妹子所在的未聊过的连通块的大小，当然，连通块越大他越开心（连通块为 $n$ ，他会得到 $n$ 开心度），现在问你，他聊完所有妹子后，开心度求和后为多少。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果我们强制第一次聊编号为 $1$ 的妹子， 我们考虑怎么统计答案。</p><p>一个很直观的想法是，我们可以一次dfs出所有子树的大小，然后对于每棵子树大小求和就是答案。</p><p>那么现在问题就转化成了，如何对于每个根求答案。</p><p>显然换根可解，但是如何统计换根后的答案呢？</p><p>我们考虑一下，我们以 $1$ 为根的时候怎么算的答案呢？</p><p>每棵子树的大小求和。但是我们可以换个角度看问题，我们不看子树的贡献，我们考虑每个节点的贡献，可以显然的发现，每个节点的贡献就是每个节点到 $1$ 的距离。</p><p>所以换根就很直观了。我们定义 $ans[i]$ 表示以 $i$ 为根的答案，$cnt[i]$ 表示以 $1$ 为根的时候，$i$ 子树的大小。所以换根相对于当前节点的父亲的代价就是 $i$ 子树深度-1，其他节点深度+1。所以当前节点相对于父亲的答案是，减少了 $cnt[i]$，增加了 $n-cnt[i]$。也即</p><p>$$ans[ind] = ans[pre] - cnt[ind] + (n-cnt[ind]) $$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mat[maxm];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> size[maxm];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> ind = <span class="number">1</span>, <span class="keyword">int</span> pre = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">size[ind] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:mat[ind]) &#123;</span><br><span class="line"><span class="keyword">if</span>(i==pre) <span class="keyword">continue</span>;</span><br><span class="line">dfs(i, ind);</span><br><span class="line">size[ind] += size[i];</span><br><span class="line">&#125;</span><br><span class="line">ans[<span class="number">1</span>] += size[ind];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">ans[ind] = ans[pre] - size[ind] + (n-size[ind]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:mat[ind]) &#123;</span><br><span class="line"><span class="keyword">if</span>(i==pre) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(i, ind);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, from, to;i&lt;n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;from,&amp;to);</span><br><span class="line">mat[from].push_back(to);</span><br><span class="line">mat[to].push_back(from);</span><br><span class="line">&#125;</span><br><span class="line">dfs();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:mat[<span class="number">1</span>]) dfs2(i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> rans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) rans = max(rans, ans[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, rans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;E-Tree-Painting&quot;&gt;&lt;a href=&quot;#E-Tree-Painting&quot; class=&quot;headerlink&quot; title=&quot;E. Tree Painting&quot;&gt;&lt;/a&gt;E. Tree Painting&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/problemset/problem/1187/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1187 E</title>
    <link href="http://zuhiul.github.io/2019/09/20/CF/CF_226_B/"/>
    <id>http://zuhiul.github.io/2019/09/20/CF/CF_226_B/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2019-10-06T06:13:44.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="E-Tree-Painting"><a href="#E-Tree-Painting" class="headerlink" title="E. Tree Painting"></a>E. Tree Painting</h2><p><a href="http://codeforces.com/problemset/problem/1187/E" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>There are $n$ piles of stones of sizes $a_1,a_2,\dots,a_n$ lying on the table in front of you.</p><p>During one move you can take one pile and add it to the other. As you add pile $i$ to pile $j$, the size of pile $j$ increases by the current size of pile $i$, and pile $i$ stops existing. The cost of the adding operation equals the size of the added pile.</p><p>Your task is to determine the minimum cost at which you can gather all stones in one pile.</p><p>To add some challenge, the stone piles built up conspiracy and decided that each pile will let you add to it not more than $k$ times (after that it can only be added to another pile).</p><p>Moreover, the piles decided to puzzle you completely and told you $q$ variants (not necessarily distinct) of what $k$ might equal.</p><p>Your task is to find the minimum cost for each of $q$ variants.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains integer $n$ ($1 \leq n \leq 10^5$) — the number of stone piles. The second line contains $n$ space-separated integers: $a_1,a_2,\dots,a_n$ ($1 \leq a_i \leq 10^9$) — the initial sizes of the stone piles.</p><p>The third line contains integer $q$ ($1 \leq q \leq 10^5$) — the number of queries. The last line contains $q$ space-separated integers $k_1,k_2,\dots,k_q$ ($1 \leq k_i \leq 10^5$) — the values of number $k$ for distinct queries. Note that numbers $k_i$ can repeat.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print $q$ whitespace-separated integers — the answers to the queries in the order, in which the queries are given in the input.</p><p>Please, do not use the $\%lld$ specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the $\%I64d$ specifier.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1"><a href="#input1" class="headerlink" title="input1"></a>input1</h4><p>5</p><p>2 3 4 1 1</p><p>2</p><p>2 3</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>9 8 </p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first sample one way to get the optimal answer goes like this: we add in turns the $4$-th and the $5$-th piles to the $2$-nd one; then we add the $1$-st pile to the $3$-rd one; we add the $2$-nd pile to the $3$-rd one. The first two operations cost $1$ each; the third one costs $2$, the fourth one costs $5$ (the size of the $2$-nd pile after the first two operations is not $3$, it already is $5$).</p><p>In the second sample you can add the $2$-nd pile to the $3$-rd one (the operations costs $3$); then the $1$-st one to the $3$-th one (the cost is $2$); then the $5$-th one to the $4$-th one (the costs is $1$); and at last, the $4$-th one to the $3$-rd one (the cost is $2$).</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>这有 $n$ 堆石子，每堆分别有 $a_1,a_2,\dots,a_n$ 个石子放在你面前的桌子上。</p><p>在每次移动中，你可以选择一堆石子，并把它合并到其他的堆上。如果你把第 $i$ 堆加到第 $j$ 堆上，那么第 $j$ 堆会增加当前第 $i$ 堆拥有的石子数，并且第 $i$ 堆将不会继续存在。这样操作的代价是第 $i$ 堆的石子数。</p><p>你的任务是考虑把这些石子合成一堆的最小代价。</p><p>为了增加一些难度，我们规定，合并的石头堆最多被合并 $k$ 次（在这之后，你只能把这一堆合并到其他堆上）。</p><p>此外，你将会被询问 $q$ 次，每次给你可能相同的 $k$ 。</p><p>你的任务是对于这 $q$ 个询问，给出最小花费。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们首先考虑如果只有一次询问我们怎么做。</p><p>假设当前每一堆最多被合并 $k$ 次。</p><p>假设当前只有 $k+1$ 堆，我们的做法显然是，排序，把最小的 $k$ 堆合并到最大堆上。</p><p>假设当前只有 $k+2$ 堆，那么我们可以得到的是，我们需要合并 $k+1$ 次，所以必然有一堆被合并了两次，除了最大堆之外，其他堆合并了一次。要让代价最小，我们需要让最小堆被合并两次。所以操作是，我们把最小堆合并到除最大堆的某一堆，然后其他堆合并到最大堆。</p><p>$\dots$</p><p>假设当前有 $k*k + k + 1$ 堆，我们怎么操作呢？</p><p>首先我们可以确定的是，需要合并 $k<em>k+k$ 次，因为一堆最多被合并 $k$ 次，所以我们可以得到，这 $k</em>k+k$ 次合并中，必定会有 $k$ 次合并，实际上是将两堆及以上合并到了某一堆中，也即：有 $k*k$ 堆被合并了两次， 有 $k$ 堆被合并了一次。所以一个显而易见的贪心策略就出来了。</p><p>每次我们倍增 $k$ 挑出这么多堆出来，合并次数增加。为了保证答案最小，显然是，最后合并的是大堆，也就是合并次数最少。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sort(a,a+n);</span><br><span class="line">reverse(a,a+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++) a[i] += a[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> rlen = len, cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;) &#123;</span><br><span class="line"><span class="keyword">int</span> r = min(n<span class="number">-1l</span>l,i+rlen<span class="number">-1</span>);</span><br><span class="line">ans += (a[r] - a[i<span class="number">-1</span>])*cnt;</span><br><span class="line">cnt++;</span><br><span class="line">i = r+<span class="number">1</span>;</span><br><span class="line">rlen *= len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"><span class="keyword">while</span>(q--) &#123;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;len;</span><br><span class="line"><span class="keyword">if</span>(ans[len]) <span class="built_in">cout</span>&lt;&lt;ans[len]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans[len] = get_ans(len);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans[len]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">input();</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;E-Tree-Painting&quot;&gt;&lt;a href=&quot;#E-Tree-Painting&quot; class=&quot;headerlink&quot; title=&quot;E. Tree Painting&quot;&gt;&lt;/a&gt;E. Tree Painting&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/problemset/problem/1187/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1215 E</title>
    <link href="http://zuhiul.github.io/2019/09/16/CF/CF_1215_E/"/>
    <id>http://zuhiul.github.io/2019/09/16/CF/CF_1215_E/</id>
    <published>2019-09-15T16:00:00.000Z</published>
    <updated>2019-09-16T09:53:09.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="E-Marbles"><a href="#E-Marbles" class="headerlink" title="E. Marbles"></a>E. Marbles</h2><p><a href="http://codeforces.com/contest/1215/problem/E" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Monocarp has arranged $n$ colored marbles in a row. The color of the $i$-th marble is $a_i$. Monocarp likes ordered things, so he wants to rearrange marbles in such a way that all marbles of the same color form a contiguos segment (and there is only one such segment for each color).</p><p>In other words, Monocarp wants to rearrange marbles so that, for every color $j$, if the leftmost marble of color $j$ is $l$-th in the row, and the rightmost marble of this color has position $r$ in the row, then every marble from $l$ to $r$ has color $j$.</p><p>To achieve his goal, Monocarp can do the following operation any number of times: choose two neighbouring marbles, and swap them.</p><p>You have to calculate the minimum number of operations Monocarp has to perform to rearrange the marbles. Note that the order of segments of marbles having equal color does not matter, it is only required that, for every color, all the marbles of this color form exactly one contiguous segment.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains one integer $n$ ($2≤n≤4\cdot10^5$) — the number of marbles.</p><p>The second line contains an integer sequence $a_1, a_2, \dots, a_n$($1≤a_i≤20$), where $a_i$ is the color of the $i$-th marble.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Print the minimum number of operations Monocarp has to perform to achieve his goal.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1"><a href="#input1" class="headerlink" title="input1"></a>input1</h4><p>7</p><p>3 4 2 3 4 2 2</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>3</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>5</p><p>20 1 14 10 2</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>0</p><h4 id="input3"><a href="#input3" class="headerlink" title="input3"></a>input3</h4><p>13</p><p>5 5 4 4 3 5 7 6 5 4 4 6 </p><p>5</p><h4 id="output3"><a href="#output3" class="headerlink" title="output3"></a>output3</h4><p>21</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example three operations are enough. Firstly, Monocarp should swap the third and the fourth marbles, so the sequence of colors is $[3,4,3,2,4,2,2]$. Then Monocarp should swap the second and the third marbles, so the sequence is $[3,3,4,2,4,2,2]$. And finally, Monocarp should swap the fourth and the fifth marbles, so the sequence is $[3,3,4,4,2,2,2]$.</p><p>In the second example there’s no need to perform any operations.</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>zuhiul认识很多妹子，显然不同的妹子有不同的颜值（颜值最高为20，最小为1），有一天他把他认识的所有妹子召集在一起（不超过$4\cdot 10^5$个），她们站成一排。现在zuhiul想把颜值相同的妹子放在一起，但是妹子们都在玩手机，所以他只能每次叫两个相邻的妹子配合一下交换。现在问你最小交换次数，使得所有颜值相同的妹子坐在一起。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>当时没做出来，看的题解（orz）， 所以先给官方题解，强烈建议先看官方题解。</p><p>The main fact is that the number of colors is less than $20$, which allows us to use exponential solutions.</p><p>For each pair of colors $(i,j)$, we can calculate $cnt[i][j]$ — the number of swaps required to place all marbles of color $i$ before all marbles of color $j$ (if we consider only marbles of these two colors). We can store a sorted vector for each color, and calculate this information for a fixed pair with two pointers.</p><p>Then let’s use subset DP to fix the order of colors. Let $d[mask]$ be the minimum number of operations to correctly order all marbles from the $mask$ of colors. Let’s iterate on the next color we consider — it should be a position in binary representation of $mask$ with $0$ in it. We will place all marbles of this color after all marbles we already placed. If we fix a new color $i$, let’s calculate the $sum$ (the additional number of swaps we have to make) by iterating on the bit $j$ equal to $1$ in the $mask$, and increasing 𝑠𝑢𝑚 by $cnt[j][i]$ for every such bit. The new state of DP can be calculated as $nmask=mask|(1&lt;&lt;i)$. So the transition can be implemented as $d[nmask]=min(d[nmask],d[mask]+sum)$.</p><p>The answer is the minimum number of swaps required to place all the colors, and that is $d[2^{20}-1]$.</p><p>因为看的题解，所以没想出第二种解法，用我的话复述一下。</p><p>因为不同的颜值数量很少（$&lt;=20$)，所以我们可以在这个方向上下文章。</p><p>如果考虑只有两种颜色，我们可以很轻易的知道答案是多少（通过枚举每个不同的位置算贡献）。</p><p>于是考虑可以用状压DP来搞，$dp[i]$表示状态为 $i$ 的时候的代价。那么答案显然是$d[2^{20}-1]$.</p><p>考虑转移，枚举每个已知答案的子集。我们怎么推算下一个状态的答案呢？</p><p>显然是往里面加了一个之前没有的值。我们不妨设当前状态为$mask$，当前新加的是 $i$ ， $i$ 加进来的代价是 $sum$ 。那么新状态显然就是$nmask=mask|(1&lt;&lt;i)$。并且我们有$ans[nmask] = min(ans[nmask], ans[mask]+sum)$。</p><p>剩下的就是考虑怎么算 $sum$。 记得我们刚刚说的吗？对于两种颜值我们怎么计算的？利用两种颜值的计算方法，我们可以预处理处一个代价矩阵$cnt[i][j]$,表示只考虑 $i$ 和 $j$ 两种颜值，我们把这两堆人排好序（ $i$ 在前，$j$ 在后）的代价。</p><p>然后可以得到 $ sum = \sum_{j\in mask}^{} cnt[i][j]$</p><p>over.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; mat[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> value[<span class="number">22</span>][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">1</span>&lt;&lt;<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, a;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">        mat[a].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=<span class="number">20</span>;i++) mat[i].push_back(maxm&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">20</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mat[i].size()==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=<span class="number">20</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mat[j].size()==<span class="number">0</span>||i==j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ind1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ind : mat[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ind &gt; maxm) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(ind &gt; mat[i][ind1]) ind1++;</span><br><span class="line">                value[i<span class="number">-1</span>][j<span class="number">-1</span>] += ind1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);i++) ans[i] = inf;</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">0</span>;mask&lt;(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);mask++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; has_bit;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;i++) <span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;i)) has_bit.push_back(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;has_bit.size();j++) sum+=value[i][has_bit[j]];</span><br><span class="line">            <span class="keyword">int</span> nmask = mask|(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            ans[nmask] = min(ans[nmask], ans[mask]+sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;E-Marbles&quot;&gt;&lt;a href=&quot;#E-Marbles&quot; class=&quot;headerlink&quot; title=&quot;E. Marbles&quot;&gt;&lt;/a&gt;E. Marbles&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1215/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 761 E</title>
    <link href="http://zuhiul.github.io/2019/09/14/CF/CF_761_E/"/>
    <id>http://zuhiul.github.io/2019/09/14/CF/CF_761_E/</id>
    <published>2019-09-13T16:00:00.000Z</published>
    <updated>2019-09-16T09:33:15.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="E-Dasha-and-Puzzle"><a href="#E-Dasha-and-Puzzle" class="headerlink" title="E. Dasha and Puzzle"></a>E. Dasha and Puzzle</h2><p><a href="http://codeforces.com/contest/761/problem/E" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Dasha decided to have a rest after solving the problem. She had been ready to start her favourite activity — origami, but remembered the puzzle that she could not solve.</p><p><img src="http://codeforces.com/predownloaded/1d/1a/1d1ae6a6db028195fcbb0bc79ccb8111c2862fdc.png" alt=""></p><p>The tree is a non-oriented connected graph without cycles. In particular, there always are $n - 1$ edges in a tree with $n$ vertices.</p><p>The puzzle is to position the vertices at the points of the Cartesian plane with integral coordinates, so that the segments between the vertices connected by edges are parallel to the coordinate axes. Also, the intersection of segments is allowed only at their ends. Distinct vertices should be placed at different points.</p><p>Help Dasha to find any suitable way to position the tree vertices on the plane.</p><p>It is guaranteed that if it is possible to position the tree vertices on the plane without violating the condition which is given above, then you can do it by using points with integral coordinates which don’t exceed $10^{18}$ in absolute value.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains single integer $n$ ($1 ≤ n ≤ 30$) — the number of vertices in the tree.</p><p>Each of next $n - 1$ lines contains two integers $u_i, v_i$ ($1 ≤ u_i, v_i ≤ n$) that mean that the $i$-th edge of the tree connects vertices $u_i$ and $v_i$.</p><p>It is guaranteed that the described graph is a tree.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>If the puzzle doesn’t have a solution then in the only line print “NO”.</p><p>Otherwise, the first line should contain “YES”. The next <em>n</em> lines should contain the pair of integers $x_i$, $y_i$ (|$x_i$|, |$y_i$| ≤ $10^{18}$) — the coordinates of the point which corresponds to the $i$-th vertex of the tree.</p><p>If there are several solutions, print any of them.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1"><a href="#input1" class="headerlink" title="input1"></a>input1</h4><p>7</p><p>1 2</p><p>1 3</p><p>2 4</p><p>2 5</p><p>3 6</p><p>3 7</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>YES</p><p>0 0</p><p>1 0</p><p>0 1</p><p>2 0</p><p>1 -1</p><p>-1 1</p><p>0 2</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>6</p><p>1 2</p><p>2 3</p><p>2 4</p><p>2 5</p><p>2 6</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>NO</p><h4 id="input3"><a href="#input3" class="headerlink" title="input3"></a>input3</h4><p>4</p><p>1 2</p><p>2 3</p><p>3 4</p><h4 id="output3"><a href="#output3" class="headerlink" title="output3"></a>output3</h4><p>YES</p><p>3 3</p><p>4 3</p><p>5 3</p><p>6 3</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first sample one of the possible positions of tree is:</p><p><img src="http://codeforces.com/predownloaded/ea/d8/ead8e669677d63668948ddcb9eaca58e76deabba.png" alt=""></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>zuhiul认识很多妹子（不超过30个），妹子之间是个树形关系。zuhiul家很大，所以他想把所有妹子放家里，因为zuhiul比较喜欢整点，所以他希望妹子都在整点上，并且有关系的妹子，他们之间的连线平行于坐标轴，并且关系不能相交，也不能重合（贵圈真乱！）。虽然zuhiul很有钱，但是他家也不是无限大，也即：所有妹子的坐标的绝对值不能超过$10^{18}$。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>显然的构造题。</p><p>首先因为妹子的关系不能相交，并且要平行于坐标轴，所以可以得到如果一个妹子和四个以上的妹子有关系，那么显然就不能构造出来。首先处理这种非法情况。</p><p>剩下的显然是一个dfs搞一下，因为无根，直接取$1$为根。</p><p>然后显然是找一个比较好的展开方式就行了。一个直观的做法就是按层次展开就行了。但是为了保证关系不交。我们考虑用下面两个规则展开。</p><ul><li>1.每层的距离至多为前一层的$\frac{1}{2}$。</li><li>2.同层的节点的距离不同。</li></ul><p>这样可以保证所有的点在四相扩展的时候不交。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dirx[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> diry[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> has_position[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ansx[<span class="number">100</span>],ansy[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lay</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> pre, <span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y, <span class="keyword">int</span> dir, <span class="keyword">int</span> <span class="built_in">floor</span>)</span> </span>&#123;</span><br><span class="line">has_position[ind] = <span class="literal">true</span>;</span><br><span class="line">ansx[ind] = x;</span><br><span class="line">ansy[ind] = y;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> rdis = <span class="number">1l</span>l&lt;&lt;<span class="built_in">floor</span>;</span><br><span class="line"><span class="keyword">int</span> dir_ind = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:son[ind]) &#123;</span><br><span class="line"><span class="keyword">if</span>(i==pre) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dir_ind==(dir^<span class="number">1</span>)) dir_ind++;</span><br><span class="line"><span class="keyword">if</span>(dir_ind&gt;<span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">lay(i, ind, x+dirx[dir_ind]*rdis, y+diry[dir_ind]*rdis, dir_ind, <span class="built_in">floor</span><span class="number">-1</span>);</span><br><span class="line">rdis--;</span><br><span class="line">dir_ind ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, from ,to;i&lt;n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;from,&amp;to);</span><br><span class="line">son[from].push_back(to);</span><br><span class="line">son[to].push_back(from);</span><br><span class="line">&#125;</span><br><span class="line">lay(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">50</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!has_position[i]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, ansx[i], ansy[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;E-Dasha-and-Puzzle&quot;&gt;&lt;a href=&quot;#E-Dasha-and-Puzzle&quot; class=&quot;headerlink&quot; title=&quot;E. Dasha and Puzzle&quot;&gt;&lt;/a&gt;E. Dasha and Puzzle&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/761/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>mac下监听全局键盘输入</title>
    <link href="http://zuhiul.github.io/2019/08/04/skill/mac_keyboard_monitor/"/>
    <id>http://zuhiul.github.io/2019/08/04/skill/mac_keyboard_monitor/</id>
    <published>2019-08-03T16:00:00.000Z</published>
    <updated>2019-08-04T08:39:31.249Z</updated>
    
    <content type="html"><![CDATA[<p>因为这段时间终于狠下心来买了把键盘。然后这两天脑子里面全是如何统计键盘敲击次数，在我踩了几个坑之后，终于搞定了，这里总结一下。</p><p>首先就是mac下不支持pyhook，貌似，所以只能用pynput来瞎搞。安装各种依赖就不说了。</p><p>首先一个坑点就是，mac为了安全考虑，拒绝一般的程序监听键盘和鼠标等外设的输入。</p><p>然后我就想办法给python权限，“系统偏好设置-&gt;安全性与隐私-&gt;完全磁盘访问权限”，给权限整上了，但是我发现一个比较尴尬的事是：依然是跑不起来。然后就各种寻求帮助。</p><p>后来发现是要在sudo下运行，我试了一下，还是不行。</p><p>最后才发现，需要的权限名字不叫“完全磁盘访问权限”，而是“辅助功能”，服了。我的理解是：你丫都有完全的磁盘访问权限了，还没有辅助功能？开玩笑呢？</p><p>啊，我死了。</p><p>这里贴上我抄的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pynput <span class="keyword">import</span> keyboard</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_press</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'out'</span>, <span class="string">'a+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f.write(str(key.char) + <span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            f.write(str(key) + <span class="string">'\n'</span>)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_release</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Collect events until released</span></span><br><span class="line"><span class="keyword">with</span> keyboard.Listener(</span><br><span class="line">        on_press=on_press,</span><br><span class="line">        on_release=on_release) <span class="keyword">as</span> listener:</span><br><span class="line">    listener.join()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为这段时间终于狠下心来买了把键盘。然后这两天脑子里面全是如何统计键盘敲击次数，在我踩了几个坑之后，终于搞定了，这里总结一下。&lt;/p&gt;
&lt;p&gt;首先就是mac下不支持pyhook，貌似，所以只能用pynput来瞎搞。安装各种依赖就不说了。&lt;/p&gt;
&lt;p&gt;首先一个坑点就是，ma
      
    
    </summary>
    
    
      <category term="体验优化" scheme="http://zuhiul.github.io/tags/%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Problems in Set Theory</title>
    <link href="http://zuhiul.github.io/2019/07/29/knowledge/Set%20Theory/"/>
    <id>http://zuhiul.github.io/2019/07/29/knowledge/Set Theory/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-07-29T09:22:20.544Z</updated>
    
    <content type="html"><![CDATA[<p>$\text{1.Prove Theorem 1 (show that $x$ is in the left-hand set iff it is in the right-hand set).For example,for (d),}$</p><p>\begin{eqnarray}<br>x \in(A \cup B) \cap C &amp;\Longleftrightarrow&amp; [x \in(A \cup B) \text { and } x \in C] \\<br>&amp;\Longleftrightarrow&amp; [(x \in A \text { or } x \in B), \text { and } x \in C] \\<br>&amp;\Longleftrightarrow&amp; [(x \in A, x \in C) \text { or }(x \in B, x \in C)]<br>\end{eqnarray}</p><ul><li>$ A \cup A = A ; A \cap A = A$</li></ul><p>\begin{eqnarray}<br>A \cup A &amp;=&amp; \{ x|x \in A \} \cup \{ x|x \in A \}\\<br>&amp;=&amp; \{ x|x \in A \}\\<br>&amp;=&amp;A\\<br>A \cap A &amp;=&amp; \{ x| x \in A \} \cup \{ x|x \in A \}\\<br>&amp;=&amp; \{ x|x \in A \}\\<br>&amp;=&amp;A\\<br>\end{eqnarray}</p><ul><li>$ A \cup B = B \cup A , A \cap B = B \cap A $</li></ul><p>\begin{eqnarray}<br>A \cup B &amp;=&amp; \{ x| x \in A \} \cup \{ x|x \in B \} \\<br>&amp;=&amp; \{ x|x \in A\ or\ x \in B \}\\<br>&amp;=&amp; \{ x|x \in B \} \cup \{ x|x \in A \}\\<br>&amp;=&amp; B \cup A<br>\end{eqnarray}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;$\text{1.Prove Theorem 1 (show that $x$ is in the left-hand set iff it is in the right-hand set).For example,for (d),}$&lt;/p&gt;
&lt;p&gt;\begin{eqn
      
    
    </summary>
    
    
      <category term="Mathematical Analysis" scheme="http://zuhiul.github.io/tags/Mathematical-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>The Curse of Knowledge</title>
    <link href="http://zuhiul.github.io/2019/07/22/knowledge/The_Curse_of_Knowledge/"/>
    <id>http://zuhiul.github.io/2019/07/22/knowledge/The_Curse_of_Knowledge/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2019-07-22T09:52:45.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识的诅咒"><a href="#知识的诅咒" class="headerlink" title="知识的诅咒"></a>知识的诅咒</h2><p>今天看到这个很有意思的词，记录一下。</p><p>先扔链接。</p><p><a href="https://hbr.org/2006/12/the-curse-of-knowledge" target="_blank" rel="noopener">英文链接</a></p><p><a href="https://en.wikipedia.org/wiki/Curse_of_knowledge" target="_blank" rel="noopener">wiki</a></p><p>用自己的一句话理解来说这件事就是：双方知识的不对等，导致告知者理解不了被告知者因为不清楚某些信息而造成的错误。</p><p>因为告知者很难理解在他看来很“常识”的东西，被告知者却不知道。</p><p>很多时候，我们描述一个东西，通常会省略我们都认为大家默认如此的东西，但是往往这些我们漏掉的关键信息反而是对方不清楚的。</p><p>一个很常见的例子是：我上周要做一个merge数据的操作，老大让我搞一下，当时他的原话是“有时间把这个merge做一下，这个拖了好久了”，然后我就吭哧吭哧开始做了，当我写完设计文档之后，他看完说了句“我说的不是这个merge”。</p><p>事实是这样：我们有两部分数据需要做merge。第一部分是上周没做，留下来的，第二部分是一天前没时间做的，我的理解是“拖了很久”，意思应该是第一个，而老大的意思是第二个，因为他觉得第二个是比较紧急的。</p><p>这种信息的不对等，导致了我们理解的不一致，如果我继续做的话，必然是有问题的。但是显然大家的理解都没问题，只是知识不对等而已。</p><p>知识的诅咒，描述的就是这种现象：当一个人知道一件事后，他就无法想象自己是不知道这件事的。</p><p>或许我们可以通过这看懂另一句话：门当户对。</p><p>我其实一直不理解为什么要门当户对，后来我渐渐明白一件事：两个环境相似的家庭诞生的两个孩子，可能思维观点一致的可能性更高，稳定的婚姻就越容易。成长环境其实很能限制一个人的发展，每个人的想法很大程度基于自己的成长过程。</p><p>同理，我们也很好解释，为啥会产生“知识的诅咒”这种现象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识的诅咒&quot;&gt;&lt;a href=&quot;#知识的诅咒&quot; class=&quot;headerlink&quot; title=&quot;知识的诅咒&quot;&gt;&lt;/a&gt;知识的诅咒&lt;/h2&gt;&lt;p&gt;今天看到这个很有意思的词，记录一下。&lt;/p&gt;
&lt;p&gt;先扔链接。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hb
      
    
    </summary>
    
    
      <category term="word" scheme="http://zuhiul.github.io/tags/word/"/>
    
  </entry>
  
  <entry>
    <title>C++ 大数</title>
    <link href="http://zuhiul.github.io/2019/06/03/knowledge/BigInt/"/>
    <id>http://zuhiul.github.io/2019/06/03/knowledge/BigInt/</id>
    <published>2019-06-02T16:00:00.000Z</published>
    <updated>2019-12-13T03:52:55.752Z</updated>
    
    <content type="html"><![CDATA[<p>闲来无事写了一发玩玩。。。</p><p>不保证正确性。。。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;streambuf&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">char</span> for_cin[mod&lt;&lt;<span class="number">8</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bigInt</span> &#123;</span><span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">bool</span> neg;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    bigInt() &#123;</span><br><span class="line">        neg = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bigInt(<span class="keyword">int</span> len) &#123;</span><br><span class="line">        neg = <span class="literal">false</span>;</span><br><span class="line">        num.resize(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) num[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relen</span><span class="params">(bigInt&amp;a)</span> </span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"><span class="keyword">int</span> len = a.num.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.num[i] &amp;&amp; a.num[i<span class="number">-1</span>]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            a.num[i]--;</span><br><span class="line">            a.num[i<span class="number">-1</span>] += mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a.num.size()&gt;=<span class="number">1</span>&amp;&amp;a.num[a.num.size()<span class="number">-1</span>]==<span class="number">0</span>) a.num.resize(a.num.size()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a.num.size()==<span class="number">0</span>) a.num.push_back(<span class="number">0</span>);</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(bigInt a,<span class="keyword">char</span> b = <span class="string">'\n'</span>)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">if</span>(a.neg) <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    <span class="keyword">int</span> len = a.num.size();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a.num[len<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%04d"</span>,a.num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">input</span><span class="params">(bigInt &amp; ret)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,for_cin)==EOF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ret.num.resize(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> startInd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(for_cin);</span><br><span class="line">    <span class="keyword">if</span>(for_cin[<span class="number">0</span>]==<span class="string">'-'</span>) &#123;</span><br><span class="line">        startInd = <span class="number">1</span>;</span><br><span class="line">        ret.neg = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = len<span class="number">-4</span>;i&gt;=startInd;i-=<span class="number">4</span>)&#123;</span><br><span class="line">        ret.num.push_back(atoi(for_cin+i));</span><br><span class="line">        for_cin[i] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i!=startInd) ret.num.push_back(atoi(for_cin+startInd));</span><br><span class="line">    relen(ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function">bigInt <span class="title">trans</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="function">bigInt <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>) ret.neg = <span class="literal">true</span>,a = -a;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        ret.num.resize(ret.num.size()+<span class="number">1</span>);</span><br><span class="line">        ret.num[ret.num.size()<span class="number">-1</span>] = a%mod;</span><br><span class="line">        a/=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    relen(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function">bigInt <span class="title">trans</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="function">bigInt <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>) ret.neg = <span class="literal">true</span>,a = -a;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        ret.num.resize(ret.num.size()+<span class="number">1</span>);</span><br><span class="line">        ret.num[ret.num.size()<span class="number">-1</span>] = a%mod;</span><br><span class="line">        a/=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    relen(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(bigInt a,bigInt b)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">if</span>(a.neg!=b.neg) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.num.size()!=b.num.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = a.num.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) <span class="keyword">if</span>(a.num[i]!=b.num[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bigger</span><span class="params">(bigInt a,bigInt b)</span> </span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">if</span>(a.neg&amp;&amp;!b.neg) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!a.neg&amp;&amp;b.neg) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.neg&amp;&amp;b.neg) &#123;</span><br><span class="line">        a.neg = b.neg = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> ret = bigger(b,a);</span><br><span class="line">        a.neg = b.neg = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.num.size()&gt;b.num.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.num.size()&lt;b.num.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = a.num.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.num[i]!=b.num[i]) <span class="keyword">return</span> a.num[i]&gt;b.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function">bigInt <span class="title">add</span><span class="params">(bigInt a,bigInt b)</span> </span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="function">bigInt <span class="title">ret</span><span class="params">(max(a.num.size(),b.num.size())+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(a.neg&amp;&amp;b.neg)&#123;</span><br><span class="line">        a.neg = b.neg = <span class="literal">false</span>;</span><br><span class="line">        ret = add(a,b);</span><br><span class="line">        ret.neg = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.neg)&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">        a.neg = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(bigger(a,b)) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b.num.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                a.num[i]-=b.num[i];</span><br><span class="line">                <span class="keyword">if</span>(a.num[i]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                    a.num[i]+=mod;</span><br><span class="line">                    a.num[i+<span class="number">1</span>]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            relen(a);</span><br><span class="line">            a.neg = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = a.num.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                b.num[i]-=a.num[i];</span><br><span class="line">                <span class="keyword">if</span>(b.num[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    b.num[i]+=mod;</span><br><span class="line">                    b.num[i+<span class="number">1</span>]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            relen(b);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line">    <span class="keyword">if</span>(b.neg) <span class="keyword">return</span> add(b,a);</span><br><span class="line">    <span class="keyword">int</span> maxlen = max(a.num.size(),b.num.size());</span><br><span class="line">    a.num.resize(maxlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> minlen = min(a.num.size(),b.num.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;minlen;i++)&#123;</span><br><span class="line">        a.num[i]+=b.num[i];</span><br><span class="line">        <span class="keyword">if</span>(a.num[i]&gt;=mod) &#123;</span><br><span class="line">            a.num[i]-=mod;</span><br><span class="line">            a.num[i+<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        b.num[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    relen(a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function">bigInt <span class="title">sub</span><span class="params">(bigInt a,bigInt b)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    b.neg = ~b.neg;</span><br><span class="line">    <span class="keyword">return</span> add(a,b);</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function">bigInt <span class="title">mul</span><span class="params">(bigInt a,bigInt b)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">int</span> lena = a.num.size();</span><br><span class="line">    <span class="keyword">int</span> lenb = b.num.size();</span><br><span class="line">    <span class="keyword">int</span> len = lena+lenb;</span><br><span class="line">    <span class="function">bigInt <span class="title">ret</span><span class="params">(len)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> buf = add;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = max(<span class="number">0</span>,i-lenb+<span class="number">1</span>);j&lt;=i&amp;&amp;j&lt;lena;j++) buf = buf+a.num[j]*b.num[i-j];</span><br><span class="line">        add = buf/mod;</span><br><span class="line">        ret.num[i] = buf%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.neg = (a.neg!=b.neg);</span><br><span class="line">    relen(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function">bigInt <span class="title">exec</span><span class="params">(bigInt a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    <span class="keyword">bool</span> neg = (b&lt;<span class="number">0</span>);</span><br><span class="line">    <span class="function">bigInt <span class="title">ret</span><span class="params">(a.num.size())</span></span>;</span><br><span class="line">    ret.neg = (a.neg!=neg);</span><br><span class="line">    a.neg = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> buf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.num.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        buf = buf*mod+a.num[i];</span><br><span class="line">        ret.num[i] = buf/b;</span><br><span class="line">        buf%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    relen(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function">bigInt <span class="title">exec</span><span class="params">(bigInt a,bigInt b)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">    bigInt base = trans(<span class="number">1</span>);</span><br><span class="line">    bigInt big10 = trans(<span class="number">10</span>);</span><br><span class="line">    bigInt big0 = trans(<span class="number">0</span>);</span><br><span class="line">    bigInt ans = trans(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">bool</span> neg = (a.neg!=b.neg);</span><br><span class="line">    a.neg = b.neg = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(bigger(a,mul(b,big10))) &#123;</span><br><span class="line">        base = mul(base,big10);</span><br><span class="line">        b = mul(b,big10);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!equal(base,big0)) &#123;</span><br><span class="line">        <span class="keyword">while</span>(bigger(a,b)) &#123;</span><br><span class="line">            ans = add(ans,base);</span><br><span class="line">            a = sub(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        b = exec(b,<span class="number">10</span>);</span><br><span class="line">        base = exec(base,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.neg = neg;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mod</span><span class="params">(bigInt a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.num.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        ret = ret*mod+a.num[i];</span><br><span class="line">        ret%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">bigInt table[mod];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闲来无事写了一发玩玩。。。&lt;/p&gt;
&lt;p&gt;不保证正确性。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模板" scheme="http://zuhiul.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>程序对拍器</title>
    <link href="http://zuhiul.github.io/2019/05/29/skill/program_beat/"/>
    <id>http://zuhiul.github.io/2019/05/29/skill/program_beat/</id>
    <published>2019-05-28T16:00:00.000Z</published>
    <updated>2019-06-03T13:22:37.677Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对拍器"><a href="#对拍器" class="headerlink" title="对拍器"></a>对拍器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 my.cpp -o my</span><br><span class="line">g++ -std=c++11 data.cpp -o data</span><br><span class="line">g++ -std=c++11 ac.cpp -o ac</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">./data &gt; <span class="keyword">in</span></span><br><span class="line">./my &lt; <span class="keyword">in</span> &gt; my.out</span><br><span class="line">./ac &lt; <span class="keyword">in</span> &gt; ac.out</span><br><span class="line"><span class="keyword">if</span> diff my.out ac.out; <span class="keyword">then</span></span><br><span class="line">((var++))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"WA\n"</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对拍器&quot;&gt;&lt;a href=&quot;#对拍器&quot; class=&quot;headerlink&quot; title=&quot;对拍器&quot;&gt;&lt;/a&gt;对拍器&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
    
      <category term="模板" scheme="http://zuhiul.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 63</title>
    <link href="http://zuhiul.github.io/2019/04/28/CF/Educational%20Codeforces%20Round%2063/"/>
    <id>http://zuhiul.github.io/2019/04/28/CF/Educational Codeforces Round 63/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-04-29T06:37:03.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-Delivery-Oligopoly"><a href="#F-Delivery-Oligopoly" class="headerlink" title="F. Delivery Oligopoly"></a>F. Delivery Oligopoly</h2><p><a href="https://codeforces.com/contest/1155/problem/F" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>The whole delivery market of Berland is controlled by two rival companies: BerEx and BerPS. They both provide fast and reliable delivery services across all the cities of Berland.</p><p>The map of Berland can be represented as an <strong>undirected</strong> graph. The cities are vertices and the roads are edges between them. Each pair of cities has no more than one road between them. Each road connects different cities.</p><p>BerEx and BerPS are so competitive that for each pair of cities $(v,u)$ they have set up their paths from $v$ to $u$ in such a way that <strong>these two paths don’t share a single road.</strong> It is guaranteed that it was possible.</p><p>Now Berland government decided to cut down the road maintenance cost by abandoning some roads. Obviously, they want to maintain as little roads as possible. However, they don’t want to break the entire delivery system. So BerEx and BerPS should still be able to have their paths between every pair of cities non-intersecting.</p><p>What is the minimal number of roads Berland government can maintain?</p><p><em>More formally, given a 2-edge connected undirected graph, what is the minimum number of edges that can be left in it so that the resulting graph is also 2-edge connected?</em></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two integers $n$ and $m$ ($3\leq n\leq14$, $n\leq m\leq \frac{n(n-1)}{2}$) — the number of cities and the number of roads between them.</p><p>Each of the next 𝑚 lines contains two integers $v$ and $u$ ($1\leq v,u\leq n,v\neq u$) — the cities connected by the next road.</p><p>It is guaranteed that each pair of cities has no more than one road between them. It is guaranteed that each pair of cities have at least two paths between them that don’t share a single road.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The first line should contain a single integer $k$ — the minimum number of roads Berland government can maintain so that BerEx and BerPS are still able to have their paths between every pair of cities non-intersecting.</p><p>The next $k$ lines should contain the list of roads which are being maintained. Each line of form “$v\ u$”, where $v$ and $u$ are cities connected by the next road.</p><p>If there are multiple lists of minimum size, print any of them. The order of roads in the list doesn’t matter.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1"><a href="#input1" class="headerlink" title="input1"></a>input1</h4><p>3 3<br>1 2<br>2 3<br>3 1</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>3<br>1 3<br>3 2<br>1 2</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>4 5<br>1 2<br>1 4<br>2 3<br>4 3<br>1 3</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>4<br>1 4<br>4 3<br>3 2<br>1 2</p><h4 id="input3"><a href="#input3" class="headerlink" title="input3"></a>input3</h4><p>6 10<br>1 2<br>2 3<br>3 1<br>3 4<br>4 5<br>5 6<br>4 6<br>2 5<br>1 6<br>3 5</p><h4 id="output3"><a href="#output3" class="headerlink" title="output3"></a>output3</h4><p>6<br>1 6<br>6 5<br>5 4<br>4 3<br>3 2<br>1 2</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>Here are graphs from the examples, red edges are the maintained ones.</p><p><img src="/img/cf_1155_f_1.png" alt="cf_1155_f_1.png"></p><p><img src="/img/cf_1155_f_2.png" alt="cf_1155_f_1.png"></p><p><img src="/img/cf_1155_f_3.png" alt="cf_1155_f_1.png"></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个不超过14个节点的无向图，让你找到满足一下条件的一个子图：</p><ul><li>包含所有点</li><li>包含尽可能少的边</li><li>子图中任意两个点存在两条完全不交的路径</li></ul><p>让你输出一个任意符合题意的子图。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>当时没做出来，看题解才做出来的。建议先看原题解。如下：</p><p>  Let’s use dynamic programming to solve this problem. We will start with a single biconnected component consisting of vertex $0$, and connect other vertices to it. So, the state of our dynamic programming will be a $mask$ of vertices that are in the same biconnected component with $0$.</p><p>  How can we extend a biconnected component in such a way that some other vertices are added into it, but it is still biconnected? We will add a path (possibly cyclic) that starts in some vertex $x$ belonging to the $mask$, goes through some vertices not belonging to the $mask$, and ends in some vertex $y$ belonging to the $mask$ (possibly $x=y$). If for every triple ($x,y,addmask$) we precalculate some path that starts in $x$, goes through vertices from $addmask$ and ends in $y$ (and $addmask$ does not contain neither $x$ nor $y$), then we can solve the problem in $O(3^nn^2)$: there will be $2^n$ states, for every state we will iterate on two vertices $x$ and $y$ belonging to the $mask$, and the number of possible pairs of non-intersecting masks $mask$ and $addmask$ is $O(3^n)$.</p><p>  The only thing that’s left is precalculating the paths for triples ($x,y,addmask$). That can be done with auxiliary dynamic programming $dp2[x][y][addmask]$ which will denote whether such a path exists. For every edge ($u,v$) of the original graph, $dp2[u][v][0]$ is true, and we can go from $dp2[x][y][addmask]$ to some state $dp2[x][z][addmask^{‘}]$, where $addmask^{‘}$ will contain all vertices from $addmask$ and vertex $y$ (and we should ensure that there is an edge ($y,z$) in the graph and the $addmask$ didn’t contain vertex $y$ earlier). We should also somehow be able to restore the paths from this dp, and we also should be careful not to choose the same edge twice (for example, if we start a path by edge ($x,y$), we should not use the same edge to return to $x$) — both these things can be done, for example, by storing next-to-last vertex in the path.</p><p>我基本是看完题解才有想法的，和题解写的一模一样，（其实不一样，我写的比标程丑）。</p><p>大体思路还是很清晰的。</p><p>首先，我们可以很轻松的发现，答案一定是很多环交在了一起构成了答案对应的子图，然后对于任何一个存在很多环相交的图来说，我们可以拆成一个环和很多很多边构成的，如下图：</p><p><img src="/img/edu_cf_63_f_1.png" alt="edu_cf_63_f_1.png"></p><p>同样的我们可以很轻松的得到，任何一个环都可以作为拆分后唯一的环。剩下的问题就是我们怎么找到所有的边了。也即怎么找到我们需要的所有路径。我们做以下定义。</p><p>我们找到一条从$a$到$b$的路径，并且其中包括$mask$对应的其他点，我们假设$dp2[a][b][mask]$表示是否存在一条从$a$到$b$的路径，并且还包含了$mask$点，例如：</p><p>$dp2[1][3][1] = 1$表示存在一条$1-0-3$的路径</p><p>$dp2[3][5][3] = 1$表示存在一条从$3$到$5$的路径，其中包含$0$号点和$1$号点，路径可能是$3-0-1-5$，也可能是$3-1-0-5$。</p><p>对于他的转移显然比较好想，直接枚举下一个点是谁就行了。</p><p>然后我们取出任意一个节点表示当前符合答案的子图的子图。因为一个点的时候显然符合答案（因为一对都没有）。然后我们在这个子图的子图中不断的添加边构成环，最后判断得到的全图是否满足答案就行了。。。。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1</span>&lt;&lt;maxn;</span><br><span class="line"><span class="keyword">int</span> n,m,upper;</span><br><span class="line"><span class="keyword">int</span> dp[maxm|<span class="number">10</span>];<span class="comment">//记录答案是否存在，也即当前子图是否满足条件（子图中任意两个点存在两条完全不交的路径）</span></span><br><span class="line"><span class="keyword">bool</span> dp2[maxn][maxn][maxm];<span class="comment">//表示是否存在一条从i到j，包含mask对应点的路径</span></span><br><span class="line"><span class="keyword">int</span> last[maxn][maxn][maxm];<span class="comment">//用来记录i到j中上一个点是谁，用来输出路径</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit[maxm|<span class="number">10</span>];<span class="comment">//表示mask中对应的点的编号</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mat[maxm|<span class="number">10</span>];<span class="comment">//存输入的图</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; con[maxm|<span class="number">10</span>];<span class="comment">//表示mask对应的两个外部点，也就是路径的起点终点</span></span><br><span class="line"><span class="keyword">int</span> addmask[maxm|<span class="number">10</span>];<span class="comment">//mask对应的外部边对应的mask</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bit</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a) show_bit(a&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(a&amp;<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">upper = <span class="number">1</span>&lt;&lt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,a,b;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">a--,b--;</span><br><span class="line">mat[a].push_back(b);</span><br><span class="line">mat[b].push_back(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="built_in">memset</span>(dp2,<span class="literal">false</span>,<span class="keyword">sizeof</span> dp2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j: mat[i])&#123;</span><br><span class="line">dp2[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">last[i][j][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">0</span>;mask&lt;upper;mask++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++) <span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;j)) bit[mask].push_back(j);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">0</span>;mask&lt;upper;mask++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;i)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;j)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(i==j||dp2[i][j][mask]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> z:mat[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;z)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(z==last[i][j][mask]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dp2[i][z][mask|(<span class="number">1</span>&lt;&lt;j)]==<span class="literal">false</span>)&#123;</span><br><span class="line">last[i][z][mask|(<span class="number">1</span>&lt;&lt;j)] = j;</span><br><span class="line">dp2[i][z][mask|(<span class="number">1</span>&lt;&lt;j)] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">0</span>;mask &lt; upper;mask++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> add = mask;add;add = (add<span class="number">-1</span>)&amp;mask)&#123;</span><br><span class="line"><span class="keyword">int</span> pre = add^mask;</span><br><span class="line"><span class="keyword">int</span> cnt = __builtin_popcount(add)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[pre]+cnt&gt;=dp[mask]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:bit[pre])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> y: bit[pre])&#123;</span><br><span class="line"><span class="keyword">if</span>(dp2[x][y][add])&#123;</span><br><span class="line">dp[mask] = dp[pre]+cnt;</span><br><span class="line">con[mask] = make_pair(x,y);</span><br><span class="line">addmask[mask] = add;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]==inf) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> cur = (<span class="number">1</span>&lt;&lt;n) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> add = addmask[cur];</span><br><span class="line"><span class="keyword">int</span> x = con[cur].first;</span><br><span class="line"><span class="keyword">int</span> y = con[cur].second;</span><br><span class="line">cur^=add;</span><br><span class="line"><span class="keyword">while</span>(add)&#123;</span><br><span class="line"><span class="keyword">int</span> ny = last[x][y][add];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;y+<span class="number">1</span>&lt;&lt;<span class="string">' '</span>&lt;&lt;ny+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">y = ny;</span><br><span class="line">add^=(<span class="number">1</span>&lt;&lt;ny);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x+<span class="number">1</span>&lt;&lt;<span class="string">' '</span>&lt;&lt;y+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;F-Delivery-Oligopoly&quot;&gt;&lt;a href=&quot;#F-Delivery-Oligopoly&quot; class=&quot;headerlink&quot; title=&quot;F. Delivery Oligopoly&quot;&gt;&lt;/a&gt;F. Delivery Oligopoly&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1155/problem/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 553</title>
    <link href="http://zuhiul.github.io/2019/04/19/CF/Codeforces_Round_553/"/>
    <id>http://zuhiul.github.io/2019/04/19/CF/Codeforces_Round_553/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T10:51:16.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-Sonya-and-Informatics"><a href="#F-Sonya-and-Informatics" class="headerlink" title="F. Sonya and Informatics"></a>F. Sonya and Informatics</h2><p><a href="https://codeforces.com/contest/1151/problem/F" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>A girl named Sonya is studying in the scientific lyceum of the Kingdom of Kremland. The teacher of computer science (Sonya’s favorite subject!) invented a task for her.</p><p>Given an array $a$ of length $n$, <strong>consisting only of the numbers</strong> $0$ <strong>and</strong> $1$, and the number $k$. Exactly $k$ times the following happens:</p><ul><li>Two numbers $i$ and $j$ are chosen equiprobable such that ($1\leq i&lt;j\leq n$).</li><li>The numbers in the $i$ and $j$ positions are swapped.</li></ul><p>Sonya’s task is to find the probability that after all the operations are completed, the $a$ array will be <strong>sorted in non-decreasing order</strong>. She turned to you for help. Help Sonya solve this problem.</p><p>It can be shown that the desired probability is either $0$ or it can be represented as $\frac{P}{Q}$, where $P$ and $Q$ are coprime integers and $Q\not\equiv0(mod\ 10^9+7)\textscA$.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two integers $n$ and $k$ ($2\leq n\leq 100,1\leq k\leq 10^9$) — the length of the array $a$ and the number of operations.</p><p>The second line contains $n$ integers $a_1,a_2,\dots,a_n$ ($0\leq a_i\leq 1$) — the description of the array $a$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>If the desired probability is $0$, print $0$, otherwise print the value $P\cdot Q^{-1}$ ($mod\ 10^9+7$), where $P$ and $Q$ are defined above.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="inpus1"><a href="#inpus1" class="headerlink" title="inpus1"></a>inpus1</h4><p>3 2</p><p>0 1 0</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>333333336</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>5 1</p><p>1 1 1 0 0</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>0</p><h4 id="input3"><a href="#input3" class="headerlink" title="input3"></a>input3</h4><p>6 4</p><p>1 0 0 1 1 0</p><h4 id="output3"><a href="#output3" class="headerlink" title="output3"></a>output3</h4><p>968493834</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example, all possible variants of the final array $a$, after applying exactly two operations: $(0,1,0)$, $(0,0,1)$, $(1,0,0)$, $(1,0,0)$, $(0,1,0)$, $(0,0,1)$, $(0,0,1)$, $(1,0,0)$, $(0,1,0)$. Therefore, the answer is $\frac{3}{9}=\frac{1}{3}$.</p><p>In the second example, the array will not be sorted in non-decreasing order after one operation, therefore the answer is 0.</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个长度为n的01序列，每次随机从中选择两个出来，交换一下，一共这样操作k次，问你经过k次交换之后，序列变成不降($00\dots 0011\dots 11$)的概率是？</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先序列里面的$0$和$1$的数量是固定的，不妨设分别有$len_a$和$len_b$个。</p><p>也就是说在交换$k$次之后要保证前$len_a$个为$0$，后$len_b$个为$1$,如下<br>$$\underbrace{00\dots 00}_{len_a} \underbrace{11\dots 11}_{len_b}$$</p><p>然后我们分别统计前半段后半段$0$和$1$的数量，分别定义为$a_0,a_1,b_0,b_1$。例如<br>$$\underbrace{\underbrace{\overbrace{01010000101110100}^{a_1=7}}_{a_0=10}}_{len_a=17}\underbrace{\underbrace{\overbrace{000101111101010}^{b_1=8}}_{b_0=7}}_{len_b=15}\tag{3}$$</p><p>然后考虑一次交换产生的效果：</p><ul><li><p>$b_1$增加：$a_1$和$b_0$交换，使得后半段多了一个1，例如<br>$$\underbrace{\underbrace{\overbrace{01010000101110000}^{a_1=6}}_{a_0=11}}_{len_a=17}\underbrace{\underbrace{\overbrace{010101111101010}^{b_1=9}}_{b_0=6}}_{len_b=15}\tag{2}$$</p></li><li><p>$b_1$减少：$a_0$和$b_1$交换，使得后半段少了一个1，例如<br>$$\underbrace{\underbrace{\overbrace{01010000101110101}^{a_1=8}}_{a_0=9}}_{len_a=17}\underbrace{\underbrace{\overbrace{000101111101000}^{b_1=7}}_{b_0=8}}_{len_b=15}\tag{1}$$</p></li><li><p>其他情况不影响$0$和$1$的数量。</p></li></ul><p>然后多次操作和一次操作怎么联系起来呢？</p><p>看到这个数据量$n = 100$，一次变多次，一个自然的想法就是快速幂啊啊啊啊啊啊啊啊啊啊。</p><p>然后就用上面的式子构造转移矩阵，然后快速幂，就能得到有解的方案数，然后除掉总方案数就行了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> (a+b)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> a*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b = mod<span class="number">-2</span>)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = mul(ret,a);</span><br><span class="line">a = mul(a,a);</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">105</span>,inv_2 = qpow(<span class="number">2</span>);</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mul(inv_2,mul(a,add(a,mod<span class="number">-1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,k,len_a,len_b;</span><br><span class="line"><span class="keyword">int</span> num[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[maxm][maxm];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">matrix <span class="title">mul</span><span class="params">(matrix a,matrix b)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">matrix c;</span><br><span class="line"><span class="built_in">memset</span>(c.num,<span class="number">0</span>,<span class="keyword">sizeof</span>(c.num));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=len_b;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=len_b;j++)</span><br><span class="line"><span class="keyword">if</span>(a.num[i][j])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;=len_b;k++) c.num[i][k] = add(c.num[i][k],mul(a.num[i][j],b.num[j][k]));</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function">matrix <span class="title">qpow</span><span class="params">(matrix a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">matrix e;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=len_b;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=len_b;j++) e.num[i][j]=(i==j);</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) e = mul(e,a);</span><br><span class="line">a = mul(a,a);</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">int</span> all = C(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,num+i);</span><br><span class="line"><span class="keyword">if</span>(num[i]) len_b++;</span><br><span class="line"><span class="keyword">else</span> len_a++;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line">matrix base;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=len_b;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = max(<span class="number">0</span>,i<span class="number">-1</span>);j&lt;=min(len_b,i+<span class="number">1</span>);j++)&#123;</span><br><span class="line"><span class="keyword">int</span> b1 = j,b0 = len_b - j,a0 = len_a - b0,a1 = len_a - a0;</span><br><span class="line"><span class="keyword">if</span>(i==j<span class="number">-1</span>) base.num[i][j] = a0*b1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==j+<span class="number">1</span>) base.num[i][j] = a1*b0;</span><br><span class="line"><span class="keyword">else</span> base.num[i][j] = add(all,add(mod - a0*b1,mod - a1*b0));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len_a;i&lt;n;i++) <span class="keyword">if</span>(num[i]) cnt++;</span><br><span class="line">matrix ano;</span><br><span class="line"><span class="built_in">memset</span>(ano.num,<span class="number">0</span>,<span class="keyword">sizeof</span>(ano.num));</span><br><span class="line">ano.num[cnt][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">base = mul(qpow(base,k),ano);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = base.num[len_b][<span class="number">0</span>];</span><br><span class="line">ans = mul(ans,qpow(qpow(C(n),k)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;F-Sonya-and-Informatics&quot;&gt;&lt;a href=&quot;#F-Sonya-and-Informatics&quot; class=&quot;headerlink&quot; title=&quot;F. Sonya and Informatics&quot;&gt;&lt;/a&gt;F. Sonya and Informatics&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1151/problem/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 552</title>
    <link href="http://zuhiul.github.io/2019/04/17/CF/Codeforces_Round_552/"/>
    <id>http://zuhiul.github.io/2019/04/17/CF/Codeforces_Round_552/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-07-22T09:58:56.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-Shovels-Shop"><a href="#F-Shovels-Shop" class="headerlink" title="F. Shovels Shop"></a>F. Shovels Shop</h2><p><a href="http://codeforces.com/contest/1154/problem/F" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>There are $n$ shovels in the nearby shop. The $i$-th shovel costs $a_i$ bourles.</p><p>Misha has to buy <strong>exactly $k$</strong> shovels. Each shovel can be bought <strong>no more than once</strong>.</p><p>Misha can buy shovels by several purchases. During one purchase he can choose any subset of remaining (non-bought) shovels and buy this subset.</p><p>There are also $m$ special offers in the shop. The $j$-th of them is given as a pair $(x_j,y_j)$, and it means that if Misha buys <strong>exactly</strong> $x_j$ shovels <strong>during one purchase</strong> then $y_j$ <strong>most cheapest</strong> of them are for free (i.e. he will not pay for $y_j$ most cheapest shovels during the current purchase).</p><p>Misha can use any offer any (possibly, zero) number of times, but he cannot use <strong>more than one</strong> offer during <strong>one purchase</strong> (but he can buy shovels without using any offers).</p><p>Your task is to calculate the minimum cost of buying $k$ shovels, if Misha buys them optimally.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains three integers $n,m$ and $k$ ($1\leq n,m\leq 2\cdot 10^5,1\leq k\leq min(n,2000)$) - the number of shovels in the shop, the number of special offers and the number of shovels Misha has to buy, correspondingly.</p><p>The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_1\leq 2\cdot 10^5$), where $a_i$ is the cost of the $i$-th shovel.</p><p>The next $m$ lines contain special offers. The $j$-th of them is given as a pair of integers ($x_i,y_i$) ($1\leq y_i\leq x_i\leq n$) and means that if Misha buys exactly $x_i$ shovels during some purchase, then he can take $y_i$ most cheapest of them for free.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print one integer $-$ the minimum cost of buying $k$ shovels if Misha buys them optimally.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="inpus1"><a href="#inpus1" class="headerlink" title="inpus1"></a>inpus1</h4><p>7 4 5</p><p>2 5 4 2 6 3 1</p><p>2 1</p><p>6 5</p><p>2 1</p><p>3 1</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>7</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>9 4 8</p><p>6 8 5 1 8 1 1 2 1</p><p>9 2</p><p>8 4</p><p>5 3</p><p>9 7</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>17</p><h4 id="input3"><a href="#input3" class="headerlink" title="input3"></a>input3</h4><p>5 1 4</p><p>2 5 7 4 6</p><p>5 4</p><h4 id="output3"><a href="#output3" class="headerlink" title="output3"></a>output3</h4><p>17</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example Misha can buy shovels on positions 1 and 4 (both with costs 2) during the first purchase and get one of them for free using the first or the third special offer. And then he can buy shovels on positions 3 and 6 (with costs 4 and 3) during the second purchase and get the second one for free using the first or the third special offer. Then he can buy the shovel on a position 7 with cost 1. So the total cost is 4+2+1=7.</p><p>In the second example Misha can buy shovels on positions 1, 2, 3, 4 and 8 (costs are 6, 8, 5, 1 and 2) and get three cheapest (with costs 5, 1 and 2) for free. And then he can buy shovels on positions 6, 7 and 9 (all with costs 1) without using any special offers. So the total cost is 6+8+1+1+1=17.</p><p>In the third example Misha can buy four cheapest shovels without using any special offers and get the total cost 17.</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>zuhiul 都20了，还没有对象，然后家里人给安排了n个菇凉和他相亲，他需要挑出k个来相亲。相亲当然是男方请客，和每个妹子相亲的成本是不一样的，每个妹子都有一个固定成本，为了促进zuhiul相亲，家里人说，如果一次邀约了$x_i$个菇凉，家里就给报销这次相亲的所有菇凉中，成本最低的$y_i$个菇凉的花费，现在zuhiul想花最少的钱相完所有的亲，他最少要花多少钱呢？</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先可以确定的是，我们一定找n个中最便宜的k个来相亲，因为如果不是这k个，我们一定可以合理的交换，得到一个不劣的解。</p><p>然后排序，干掉贵的那一部分。</p><p>那么如果不考虑报销的话，成本是固定的，所以剩下的问题就是怎么得到尽可能多的报销。</p><p>然后，显然是一个$n^2$的dp了。</p><p>我们可以预处理出，如果一次约j个女孩的话，可以省掉多少个女孩的费用，设为sub[j]</p><p>假设每个女孩的费用为values[i]</p><p>考虑转移，设dp[i]表示邀约前n个妹子的最小花费，那么可以得到$$dp[i] = \min_{j=1}^{i} (dp[i-j] + \sum_{k=i-j+sub[j]+1}^{i} values[k])$$</p><p>然后对于后面的求和，可以搞一个前缀和来维护，复杂度$O(n^2)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sub[maxk];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> values[maxm];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxm];</span><br><span class="line"><span class="keyword">int</span> ans[maxk];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cost[maxk];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,values+i);</span><br><span class="line">sort(values+<span class="number">1</span>,values+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i<span class="number">-1</span>]+values[i];</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(a&gt;k) <span class="keyword">continue</span>;</span><br><span class="line">sub[a] = max(sub[a],b);</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=k;i++) sub[i] = max(sub[i],sub[i<span class="number">-1</span>]);</span><br><span class="line"><span class="built_in">memset</span>(cost,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(cost));</span><br><span class="line">cost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">cost[i] = sum[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">cost[i] = min(cost[i],cost[i-j]+sum[i]-sum[i-j+sub[j]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,cost[k]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Minimum-Possible-LCM"><a href="#G-Minimum-Possible-LCM" class="headerlink" title="G. Minimum Possible LCM"></a>G. Minimum Possible LCM</h2><p><a href="http://codeforces.com/contest/1154/problem/G" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given an array $a$ consisting of $n$ integers $a_1,a_2,\dots,a_n$.</p><p>Your problem is to find such pair of indices $i,j (1\leq i&lt;j\leq n)$ that $lcm(a_i,a_j)$ is minimum possible.</p><p>$lcm(x,y)$ is the least common multiple of $x$ and $y$ (minimum positive number such that both $x$ and $y$ are divisors of this number).</p><p>###Input</p><p>The first line of the input contains one integer $n$ ($2\leq n\leq10^6$) — the number of elements in $a$.</p><p>The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_i\leq 10^7$), where $a_i$ is the $i$-th element of $a$.</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>Print two integers $i$ and $j$ ($1\leq i&lt;j\leq n$) such that the value of $lcm(a_i,a_j)$ is minimum among all valid pairs $i,j$. If there are multiple answers, you can print any.</p><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><h4 id="inpus1-1"><a href="#inpus1-1" class="headerlink" title="inpus1"></a>inpus1</h4><p>5</p><p>2 4 8 3 6</p><h4 id="output1-1"><a href="#output1-1" class="headerlink" title="output1"></a>output1</h4><p>1 2</p><h4 id="input2-1"><a href="#input2-1" class="headerlink" title="input2"></a>input2</h4><p>5</p><p>5 2 11 3 7</p><h4 id="output2-1"><a href="#output2-1" class="headerlink" title="output2"></a>output2</h4><p>2 4</p><h4 id="input3-1"><a href="#input3-1" class="headerlink" title="input3"></a>input3</h4><p>6</p><p>2 5 10 1 10 2 </p><h4 id="output3-1"><a href="#output3-1" class="headerlink" title="output3"></a>output3</h4><p>1 4</p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>zuhiul有很多妹子，今天他想找两个妹子出去吃饭，每个妹子都有一个权值，他今天要花的钱等于这两个妹子权值的lcm，他想花尽可能少的钱，他该约哪两个妹子呢？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>我们考虑一下那种情况可以构成解。</p><p>首先对于重复的数据，我们可以干掉，因为相同值的lcm等于本身，所以我们可以把相同的权值干掉，然后剩下的数据都是不同的。</p><p>然后我们考虑权值都不相同的时候怎么构成解。</p><p>首先，这两个数肯定有一个gcd，哪怕gcd = 1，然后我们考虑一下，这$n*(n-1)&gt;&gt;1$这么多对数中，哪些对可以构成解，一个显而易见的想法就是，我们可以枚举gcd。</p><p>然后我们枚举这个gcd的所有倍数，这样能不重不漏的枚举出所有对数，然后我们考虑怎么减少枚举量。假设当前的$gcd=x$,因为前一步保证了没有相同的数据，所以我们只要找到最小的$i,j$使得$i\%x==0\&amp;\&amp;j\%x==0$，然后就用这两个数更新一下答案就行了。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> app[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">int</span> ind1,ind2;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> p a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ans&lt;a.ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">p ans = &#123;<span class="number">1000000000000000000l</span>l,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,buf;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;buf);</span><br><span class="line"><span class="keyword">if</span>(app[buf]) ans = min(ans,&#123;buf,app[buf],i&#125;);</span><br><span class="line">app[buf] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;maxm;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;maxm;j+=i)&#123;</span><br><span class="line"><span class="keyword">if</span>(app[j])&#123;</span><br><span class="line">buf[++buf[<span class="number">0</span>]] = j;</span><br><span class="line"><span class="keyword">if</span>(buf[<span class="number">0</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">ans = min(ans,&#123;<span class="number">1l</span>l*buf[<span class="number">1</span>]*buf[<span class="number">2</span>]/i,app[buf[<span class="number">1</span>]],app[buf[<span class="number">2</span>]]&#125;);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans.ind1&gt;ans.ind2) swap(ans.ind1,ans.ind2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans.ind1,ans.ind2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;F-Shovels-Shop&quot;&gt;&lt;a href=&quot;#F-Shovels-Shop&quot; class=&quot;headerlink&quot; title=&quot;F. Shovels Shop&quot;&gt;&lt;/a&gt;F. Shovels Shop&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1154/problem/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 551</title>
    <link href="http://zuhiul.github.io/2019/04/14/CF/Codeforces_Round_551/"/>
    <id>http://zuhiul.github.io/2019/04/14/CF/Codeforces_Round_551/</id>
    <published>2019-04-13T16:00:00.000Z</published>
    <updated>2019-07-22T09:58:57.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-Serval-and-Bus"><a href="#A-Serval-and-Bus" class="headerlink" title="A. Serval and Bus"></a>A. Serval and Bus</h2><p><a href="http://codeforces.com/contest/1153/problem/A" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>It is raining heavily. But this is the first day for Serval, who just became 3 years old, to go to the kindergarten. Unfortunately, he lives far from kindergarten, and his father is too busy to drive him there. The only choice for this poor little boy is to wait for a bus on this rainy day. Under such circumstances, the poor boy will use the first bus he sees no matter where it goes. If several buses come at the same time, he will choose one randomly.</p><p>Serval will go to the bus station at time $t$, and there are $n$ bus routes which stop at this station. For the $i$-th bus route, the first bus arrives at time $s_i$ minutes, and each bus of this route comes $d_i$ minutes later than the previous one.</p><p>As Serval’s best friend, you wonder which bus route will he get on. If several buses arrive at the same time, you can print any of them.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station.</p><p>Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1"><a href="#input1" class="headerlink" title="input1"></a>input1</h4><p>2 2</p><p>6 4</p><p>9 5</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>1</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>5 5</p><p>3 3</p><p>2 5</p><p>5 6</p><p>4 9</p><p>6 1</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>3</p><h4 id="input3"><a href="#input3" class="headerlink" title="input3"></a>input3</h4><p>3 7</p><p>2 2</p><p>2 3</p><p>2 4</p><h4 id="output3"><a href="#output3" class="headerlink" title="output3"></a>output3</h4><p>1</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>zuhiul很忙，他要约妹子，他一共有$n$个妹子要约，但是他$t$天后才有空，妹子们也不是每天都有时间，但是妹子都是周期性有时间，比如，第$i$个妹子，$s_i$天之后才有时间，而且每$d_i$天就会再次出线，现在问你，zuhiul最早会和哪个妹子约会，如果会和多个妹子约会，只需要输出任意一个妹子就行了。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>只需要枚举每个妹子，然后看一下这个妹子什么时候最早可以邀约，然后算一下min就可以了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> s[maxm],d[maxm];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;t;</span><br><span class="line"><span class="keyword">int</span> ind,sum = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s[i]&gt;&gt;d[i];</span><br><span class="line"><span class="keyword">if</span>(s[i]&gt;=t)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;s[i])&#123;</span><br><span class="line">sum = s[i];</span><br><span class="line">ind = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> nee = t-s[i];</span><br><span class="line"><span class="keyword">if</span>(nee%d[i]!=<span class="number">0</span>) nee = (nee/d[i]+<span class="number">1</span>)*d[i];</span><br><span class="line">nee+=s[i];</span><br><span class="line"><span class="keyword">if</span>(nee&lt;sum)&#123;</span><br><span class="line">sum = nee;</span><br><span class="line">ind = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ind&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Serval-and-Toy-Bricks"><a href="#B-Serval-and-Toy-Bricks" class="headerlink" title="B. Serval and Toy Bricks"></a>B. Serval and Toy Bricks</h2><p><a href="http://codeforces.com/contest/1153/problem/B" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>Luckily, Serval got onto the right bus, and he came to the kindergarten on time. After coming to kindergarten, he found the toy bricks very funny.</p><p>He has a special interest to create difficult problems for others to solve. This time, with many $1\times 1\times 1$ toy bricks, he builds up a 3-dimensional object. We can describe this object with a $n\times m$ matrix, such that in each cell $(i,j)$ , there are $h_{i,j}$ bricks standing on the top of each other.</p><p>However, Serval doesn’t give you any $h_{i,j}$, and just give you the front view, left view, and the top view of this object, and he is now asking you to restore the object. Note that in the front view, there are $m$ columns, and in the $i$-th of them, the height is the maximum of $h_{1,i},h_{2,i},\dots,h_{n,i}$. It is similar for the left view, where there are $n$ columns. And in the top view, there is an 𝑛×𝑚 matrix $t_{i,j}$, where $t_{i,j}$ is 0 or 1. If $t_{i,j}$ equals 1, that means $h_{i,j}$&gt;0, otherwise, $h_{i,j}$=0.</p><p>However, Serval is very lonely because others are bored about his unsolvable problems before, and refused to solve this one, although this time he promises there will be at least one object satisfying all the views. As his best friend, can you have a try?</p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station.</p><p>Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route.</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>Print one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them.</p><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1-1"><a href="#input1-1" class="headerlink" title="input1"></a>input1</h4><p>3 7 3</p><p>2 3 0 0 2 0 1</p><p>2 1 3</p><p>1 0 0 0 1 0 0</p><p>0 0 0 0 0 0 1</p><p>1 1 0 0 0 0 0</p><h4 id="output1-1"><a href="#output1-1" class="headerlink" title="output1"></a>output1</h4><p>1 0 0 0 2 0 0</p><p>0 0 0 0 0 0 1</p><p>2 3 0 0 0 0 0</p><h4 id="input2-1"><a href="#input2-1" class="headerlink" title="input2"></a>input2</h4><p>4 5 5</p><p>3 5 2 0 4</p><p>4 2 5 4</p><p>0 0 0 0 1</p><p>1 0 1 0 0</p><p>0 1 0 0 0</p><p>1 1 1 0 0</p><h4 id="output2-1"><a href="#output2-1" class="headerlink" title="output2"></a>output2</h4><p>0 0 0 0 4</p><p>1 0 2 0 0</p><p>0 5 0 0 0</p><p>3 4 1 0 0</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p><img src="/img/cf_1153_b_1.png" alt=""></p><p>The graph above illustrates the object in the first example.</p><p><img src="/img/cf_1153_b_2.png" alt=""></p><p>The first graph illustrates the object in the example output for the second example, and the second graph shows the three-view drawing of it.</p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>zuhiul和妹子玩游戏，妹子搭了一个积木，然后zuhiul猜积木长啥样，zuhiul必然不会，于是小姐姐放过了他，告诉了他现在的主视图，侧视图和俯视图，然后让zuhiul猜，zuhiul还是不会，但是为了脸面不能说不会，然后来问你了。你需要输出一种可能的解满足这个三视图。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>告诉了主视图和左视图，相当于限制了最大值，告诉俯视图相当于告诉哪里可能有方块。然后枚举俯视图的每个位置，输出答案即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> hang[maxm],lie[maxm],nouse;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;nouse;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++) <span class="built_in">cin</span>&gt;&gt;hang[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;lie[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>,a;j&lt;m;j++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"><span class="keyword">if</span>(a) <span class="built_in">cout</span>&lt;&lt;min(lie[i],hang[j])&lt;&lt;<span class="string">' '</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Serval-and-Parenthesis-Sequence"><a href="#C-Serval-and-Parenthesis-Sequence" class="headerlink" title="C. Serval and Parenthesis Sequence"></a>C. Serval and Parenthesis Sequence</h2><p><a href="http://codeforces.com/contest/1153/problem/C" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>Serval soon said goodbye to Japari kindergarten, and began his life in Japari Primary School.</p><p>In his favorite math class, the teacher taught him the following interesting definitions.</p><p>A parenthesis sequence is a string, containing only characters “(“ and “)”.</p><p>A correct parenthesis sequence is a parenthesis sequence that can be transformed into a correct arithmetic expression by inserting characters “1” and “+” between the original characters of the sequence. For example, parenthesis sequences “()()”, “(())” are correct (the resulting expressions are: “(1+1)+(1+1)”, “((1+1)+1)”), while “)(“ and “)” are not. Note that the empty string is a correct parenthesis sequence by definition.</p><p>We define that $|s|$ as the length of string $s$. A strict prefix $s[1\dots l]$ (1 ≤ $l$ &lt; $|s|$) of a string $s=s_{1}s_{2}\dots s_{|s|}$ is string $s_{1}s_{2}\dots s_{l}$. Note that the empty string and the whole string are not strict prefixes of any string by the definition.</p><p>Having learned these definitions, he comes up with a new problem. He writes down a string $s$ containing only characters “(“, “)” and “?”. And what he is going to do, is to replace each of the “?” in $s$ independently by one of “(“ and “)” to make all strict prefixes of the new sequence not a correct parenthesis sequence, while the new sequence should be a correct parenthesis sequence.</p><p>After all, he is just a primary school student so this problem is too hard for him to solve. As his best friend, can you help him to replace the question marks? If there are many solutions, any of them is acceptable.</p><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>The first line contains a single integer $|s|$ (1≤$|s|$≤$3\cdot 10^5$), the length of the string.</p><p>The second line contains a string $s$, containing only “(“, “)” and “?”.</p><h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>A single line contains a string representing the answer.</p><p>If there are many solutions, any of them is acceptable.</p><p>If there is no answer, print a single line containing “:(“ (without the quotes).</p><h3 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1-2"><a href="#input1-2" class="headerlink" title="input1"></a>input1</h4><p>6<br>(?????</p><h4 id="output1-2"><a href="#output1-2" class="headerlink" title="output1"></a>output1</h4><p>(()())</p><h4 id="input2-2"><a href="#input2-2" class="headerlink" title="input2"></a>input2</h4><p>10<br>(???(???(?</p><h4 id="output2-2"><a href="#output2-2" class="headerlink" title="output2"></a>output2</h4><p>:(</p><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>It can be proved that there is no solution for the second sample, so print “:(“.</p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给你一堆左括号右括号和问号，问你能否把问号变成左括号或者右括号，使得这个变成一个括号匹配的序列，并且序列的任何前缀不是一个括号匹配序列。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>显然对于后一个条件，我们只需要让最左边的左括号和最右边的右括号匹配就行了，然后中间是一个括号匹配序列就行了。然后填充的时候贪心的让左边填充左括号,右边填充右括号,然后check一下就行了.</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> que[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NO</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">":("</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;len&gt;&gt;que;</span><br><span class="line"><span class="keyword">if</span>(len&amp;<span class="number">1</span>) NO();</span><br><span class="line"><span class="keyword">if</span>(que[<span class="number">0</span>]==<span class="string">'?'</span>) que[<span class="number">0</span>] = <span class="string">'('</span>;</span><br><span class="line"><span class="keyword">if</span>(que[len<span class="number">-1</span>]==<span class="string">'?'</span>) que[len<span class="number">-1</span>] = <span class="string">')'</span>;</span><br><span class="line"><span class="keyword">if</span>(que[<span class="number">0</span>]!=<span class="string">'('</span>) NO();</span><br><span class="line"><span class="keyword">if</span>(que[len<span class="number">-1</span>]!=<span class="string">')'</span>) NO();</span><br><span class="line"><span class="keyword">if</span>(len==<span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"()"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>,has = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(que[i]==<span class="string">'('</span>) l++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(que[i]==<span class="string">')'</span>) r++;</span><br><span class="line"><span class="keyword">else</span> has++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(l-r)&gt;has) NO();</span><br><span class="line">l = (len<span class="number">-2</span>)/<span class="number">2</span> - l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(que[i]==<span class="string">'?'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(l)&#123;</span><br><span class="line">que[i] = <span class="string">'('</span>;</span><br><span class="line">l--;</span><br><span class="line">&#125;<span class="keyword">else</span> que[i] = <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">has = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(que[i]==<span class="string">'('</span>) has++;</span><br><span class="line"><span class="keyword">else</span> has--;</span><br><span class="line"><span class="keyword">if</span>(has&lt;<span class="number">0</span>) NO();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(que);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Serval-and-Rooted-Tree"><a href="#D-Serval-and-Rooted-Tree" class="headerlink" title="D. Serval and Rooted Tree"></a>D. Serval and Rooted Tree</h2><p><a href="http://codeforces.com/contest/1153/problem/D" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>Now Serval is a junior high school student in Japari Middle School, and he is still thrilled on math as before.</p><p>As a talented boy in mathematics, he likes to play with numbers. This time, he wants to play with numbers on a rooted tree.</p><p>A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a node $v$ is the last different from $v$ vertex on the path from the root to the vertex $v$. Children of vertex $v$ are all nodes for which $v$ is the parent. A vertex is a leaf if it has no children.</p><p>The rooted tree Serval owns has $n$ nodes, node 1 is the root. Serval will write some numbers into all nodes of the tree. However, there are some restrictions. Each of the nodes except leaves has an operation max or min written in it, indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons, respectively.</p><p>Assume that there are $k$ leaves in the tree. Serval wants to put integers $1,2,\dots,k$ to the $k$ leaves (each number should be used exactly once). He loves large numbers, so he wants to maximize the number in the root. As his best friend, can you help him?</p><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer $n$ (2≤$n$≤$3\cdot 10^5$), the size of the tree.</p><p>The second line contains $n$ integers, the $i$-th of them represents the operation in the node $i$. 0 represents min and 1 represents max. If the node is a leaf, there is still a number of 0 or 1, but you can ignore it.</p><p>The third line contains $n-1$ integers $f_2,f_3,\dots,f_n$ (1≤$f_i≤$i-1$), where $f_i$ represents the parent of the node $i$.</p><h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>Output one integer $-$ the maximum possible number in the root of the tree.</p><h3 id="Examples-3"><a href="#Examples-3" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1-3"><a href="#input1-3" class="headerlink" title="input1"></a>input1</h4><p>6</p><p>1 0 1 1 0 1</p><p>1 2 2 2 2</p><h4 id="output1-3"><a href="#output1-3" class="headerlink" title="output1"></a>output1</h4><p>1</p><h4 id="input2-3"><a href="#input2-3" class="headerlink" title="input2"></a>input2</h4><p>5</p><p>1 0 1 0 1</p><p>1 1 1 1</p><h4 id="output2-3"><a href="#output2-3" class="headerlink" title="output2"></a>output2</h4><p>4</p><h4 id="input3-1"><a href="#input3-1" class="headerlink" title="input3"></a>input3</h4><p>8</p><p>1 0 0 1 0 1 1 0</p><p>1 1 2 2 3 3 3</p><h4 id="output3-1"><a href="#output3-1" class="headerlink" title="output3"></a>output3</h4><p>4</p><h4 id="input4"><a href="#input4" class="headerlink" title="input4"></a>input4</h4><p>9</p><p>1 1 0 0 1 0 1 0 1</p><p>1 1 2 2 3 3 4 4</p><h4 id="output4"><a href="#output4" class="headerlink" title="output4"></a>output4</h4><p>5</p><h3 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h3><p>Pictures below explain the examples. The numbers written in the middle of the nodes are their indices, and the numbers written on the top are the numbers written in the nodes.</p><p>In the first example, no matter how you arrange the numbers, the answer is $1$.</p><p><img src="/img/cf_1153_d_1.png" alt=""></p><p>In the second example, no matter how you arrange the numbers, the answer is $4$.</p><p><img src="/img/cf_1153_d_2.png" alt=""></p><p>In the third example, one of the best solution to achieve $4$ is to arrange $4$ and $5$ to nodes $4$ and $5$.</p><p><img src="/img/cf_1153_d_3.png" alt=""></p><p>In the fourth example, the best solution is to arrange $5$ to node $5$.</p><p><img src="/img/cf_1153_d_4.png" alt=""></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给你一颗有根树，每个非叶节点上有一个函数，可能为min或者max，你需要在k个叶节点上填上$1,2,\dots,k$,使得经过非叶节点的操作之后，根节点的值最大。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>显然是要分析函数的作用。</p><p>如果是取max，说明所有的子节点中，我们可以把某一个子节点的值取到最大，然后其他的节点全塞垃圾值。</p><p>如果是取min，说明所有子节点都起作用，说明我们对于每个子节点都要尽可能的大。</p><p>然后就可以得到，max的策略是，找到孙子节点最少的子节点，填充大值，min的策略是，对所有子节点求和。</p><p>然后这样得到的就是所有对答案有贡献的节点数，然后用总结点数减去贡献节点数就是答案。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line"><span class="keyword">int</span> maxn[maxm];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[maxm];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(son[a].size()==<span class="number">0</span>)&#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxn[a])&#123;</span><br><span class="line"><span class="keyword">int</span> minm = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:son[a]) minm = min(minm,dfs(i));</span><br><span class="line"><span class="keyword">return</span> minm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:son[a]) sum+=dfs(i);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;maxn[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,pre;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;pre;</span><br><span class="line">son[pre].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nouse = dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;cnt - nouse+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Serval-and-Snake"><a href="#E-Serval-and-Snake" class="headerlink" title="E. Serval and Snake"></a>E. Serval and Snake</h2><p><a href="http://codeforces.com/contest/1153/problem/E" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p><em>This is an interactive problem.</em></p><p>Now Serval is a senior high school student in Japari Middle School. However, on the way to the school, he must go across a pond, in which there is a dangerous snake. The pond can be represented as a $n\times n$ grid. The snake has a head and a tail in different cells, and its body is a series of adjacent cells connecting the head and the tail without self-intersecting. If Serval hits its head or tail, the snake will bite him and he will die.</p><p>Luckily, he has a special device which can answer the following question: you can pick a rectangle, it will tell you the number of times one needs to cross the border of the rectangle walking cell by cell along the snake from the head to the tail. The pictures below show a possible snake and a possible query to it, which will get an answer of $4$.</p><p><img src="/img/cf_1153_e_1.png" alt=""><br><img src="/img/cf_1153_e_2.png" alt=""></p><p>Today Serval got up too late and only have time to make 2019 queries. As his best friend, can you help him find the positions of the head and the tail?</p><p>Note that two cells are adjacent if and only if they have a common edge in the grid, and a snake can have a body of length 0, that means it only has adjacent head and tail.</p><p>Also note that the snake is sleeping, so it won’t move while Serval using his device. And what’s obvious is that the snake position does not depend on your queries.</p><h3 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h3><p>The first line contains a single integer $n$ (2≤$n$≤1000) $-$ the size of the grid.</p><h3 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h3><p>When you are ready to answer, you should print <strong>! x1 y1 x2 y2</strong>, where $(x_1,y_1)$ represents the position of the head and $(x_2,y_2)$ represents the position of the tail. You can print head and tail in any order.</p><h3 id="Interaction"><a href="#Interaction" class="headerlink" title="Interaction"></a>Interaction</h3><p>To make a query, you should print <strong>? x1 y1 x2 y2</strong> (1≤$x_1$≤$x_2$≤𝑛, 1≤$y_1$≤$y_2$≤$n$), representing a rectangle consisting of all cells $(x,y)$ such that $x_1$≤$x$≤$x_2$ and $y_1$≤$y$≤$y_2$. You will get a single integer as the answer.</p><p>After printing a query, do not forget to output the end of line and flush the output, otherwise you will get <strong>Idleness limit exceeded</strong>. To do this, use:</p><ul><li><strong>fflush(stdout)</strong> or <strong>cout.flush()</strong> in C++;</li><li><strong>System.out.flush()</strong> in Java;</li><li><strong>flush(output)</strong> in Pascal;</li><li><strong>stdout.flush()</strong> in Python;<br>see documentation for other languages.</li></ul><p>Answer $-1$ instead of a valid answer means that you made an invalid query or exceeded the maximum number of queries. Exit immediately after receiving $-1$ and you will see <strong>Wrong answer</strong> verdict. Otherwise you can get an arbitrary verdict because your solution will continue to read from a closed stream.</p><p>If your program cannot find out the head and tail of the snake correctly, you will also get a <strong>Wrong Answer</strong> verdict.</p><h3 id="Hacks"><a href="#Hacks" class="headerlink" title="Hacks"></a>Hacks</h3><p>To make a hack, print a single integer $n$ (2≤$n$≤1000) in the first line, indicating the size of the grid.</p><p>Then print an integer $k$ (2≤$k$≤𝑛2) in the second line, indicating the length of the snake.</p><p>In the next $k$ lines, print $k$ pairs of integers $x_i,y_i$ (1≤$x_i,y_i$≤𝑛), each pair in a single line, indicating the $i$-th cell of snake, such that the adjacent pairs are adjacent, and all $k$ pairs are distinct.</p><h3 id="Examples-4"><a href="#Examples-4" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1-4"><a href="#input1-4" class="headerlink" title="input1"></a>input1</h4><p>2</p><p>1</p><p>0</p><p>0</p><h4 id="output1-4"><a href="#output1-4" class="headerlink" title="output1"></a>output1</h4><p>? 1 1 1 1</p><p>? 1 2 1 2</p><p>? 2 2 2 2</p><p>! 1 1 2 1</p><h4 id="input2-4"><a href="#input2-4" class="headerlink" title="input2"></a>input2</h4><p>3</p><p>2</p><p>0</p><h4 id="output2-4"><a href="#output2-4" class="headerlink" title="output2"></a>output2</h4><p>? 2 2 2 2</p><p>? 2 1 2 3</p><p>! 2 1 2 3</p><h3 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h3><p><img src="/img/cf_1153_e_3.png" alt=""><br><img src="/img/cf_1153_e_4.png" alt=""><br><img src="/img/cf_1153_e_5.png" alt=""><br><img src="/img/cf_1153_e_6.png" alt=""></p><p>The pictures above show our queries and the answers in the first example. We first made a query for (1,1) and got an answer 1, then found that it must be connected to exactly one other cell. Then we made a query for (1,2) and got an answer of 0, then knew that the snake never entered it. So the cell connected to (1,1) must be (2,1). Then we made a query for (2,2) and got an answer 0, then knew that it never entered (2,2) as well. So the snake cannot leave (2,1), which implies that the answer is (1,1) and (2,1).</p><p><img src="/img/cf_1153_e_7.png" alt=""><br><img src="/img/cf_1153_e_8.png" alt=""><br><img src="/img/cf_1153_e_9.png" alt=""></p><p>The pictures above show our queries and the answers in the second example. By making query to (2,2) and receiving 2, we found that the snake occupies (2,2). And by making query to rectangle from (2,1) to (2,3) and receiving answer 0, we knew that it never goes out of the rectangle from (2,1) to (2,3). Since the first answer is 2, both (2,1) and (2,3) must be occupied but none of others, so the answer is (2,1) and (2,3).</p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>现在有一条蛇在一个方格图中，你可以给出不超过2019次询问，每次询问一个矩形，回答是，你用这个矩形去切蛇，可以得到这个蛇被切了多少刀，现在问你蛇头和蛇尾的位置。</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>首先我们可以观察到，当一个矩形切下去之后发现切了奇数刀，那么可以有必然存在一个头或者尾在矩形中。</p><p>然后我们可以用$(n-1)&lt;&lt;1$次询问得到所有的行和列对应的切的次数。</p><p>然后可以证明的是，所有的数据中必然存在奇数。反证法易得。</p><p>然后可以证明奇数对应的行或者列左右必然存在头或者尾。</p><p>所以可以得到一个很直观的$O(6n)$的做法，$2n$用来寻找，剩下的$4n$来搜索答案。但是这必然会超过2019.</p><p>考虑哪些步骤可以优化？</p><p>$2n$不可优化，必然就只能优化搜索过程。</p><p>需要注意的是，可能存在行或者列不存在奇数的情况，稍微分析可以得到这种情况的特点了，头和尾在同一行或者同一列中。</p><p>我们考虑到，我们只用考虑奇偶的情况，而不用考虑具体值。</p><p>因为奇偶的加减特性，我们可以二分这个答案。</p><p>除此之外，如果行和列都有奇数值，那么可以得到行和列对应的四个点中，两个点是答案，枚举任何一个就可以得到答案。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r,c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"? %d %d %d %d\n"</span>,u,l,d,r);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> nouse;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nouse);</span><br><span class="line"><span class="keyword">return</span> nouse&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(que(i,i,<span class="number">1</span>,n)) r.push_back(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(que(<span class="number">1</span>,n,i,i)) c.push_back(i);</span><br><span class="line">assert(r.size()+c.size()&gt;=<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(c.empty()||r.empty())&#123;</span><br><span class="line"><span class="keyword">bool</span> change = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(c.empty()) &#123;</span><br><span class="line">swap(r,c);</span><br><span class="line">change = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = n;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> upper = l,down = mid,left = c[<span class="number">0</span>],right = c[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(change) swap(left,upper),swap(down,right);</span><br><span class="line"><span class="keyword">if</span>(que(upper,down,left,right)) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!change) <span class="built_in">printf</span>(<span class="string">"! %d %d %d %d\n"</span>,l,c[<span class="number">1</span>],l,c[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"! %d %d %d %d\n"</span>,c[<span class="number">0</span>],l,c[<span class="number">1</span>],l);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(que(r[<span class="number">0</span>],r[<span class="number">0</span>],c[<span class="number">0</span>],c[<span class="number">0</span>])) <span class="built_in">printf</span>(<span class="string">"! %d %d %d %d\n"</span>,r[<span class="number">0</span>],c[<span class="number">0</span>],r[<span class="number">1</span>],c[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"! %d %d %d %d\n"</span>,r[<span class="number">0</span>],c[<span class="number">1</span>],r[<span class="number">1</span>],c[<span class="number">0</span>]);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Serval-and-Bonus-Problem"><a href="#F-Serval-and-Bonus-Problem" class="headerlink" title="F. Serval and Bonus Problem"></a>F. Serval and Bonus Problem</h2><p><a href="https://codeforces.com/contest/1153/problem/F" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>Getting closer and closer to a mathematician, Serval becomes a university student on math major in Japari University. On the Calculus class, his teacher taught him how to calculate the expected length of a random subsegment of a given segment. Then he left a bonus problem as homework, with the award of a garage kit from IOI. The bonus is to extend this problem to the general case as follows.</p><p>You are given a segment with length $l$. We randomly choose $n$ segments by choosing two points (maybe with non-integer coordinates) from the given segment equiprobably and the interval between the two points forms a segment. You are given the number of random segments $n$, and another integer $k$. The $2n$ endpoints of the chosen segments split the segment into ($2n+1$) intervals. Your task is to calculate the expected total length of those intervals that are covered by at least $k$ segments of the $n$ random segments.</p><p>You should find the answer modulo $998244353$.</p><h3 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h3><p>First line contains three space-separated positive integers 𝑛, 𝑘 and 𝑙 ($1\leq k\leq n\leq 2000,1\leq l\leq 10^9$).</p><h3 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h3><p>Output one integer — the expected total length of all the intervals covered by at least $k$ segments of the $n$ random segments modulo $998244353$.</p><p>Formally, let $M=998244353$. It can be shown that the answer can be expressed as an irreducible fraction $\frac{p}{q}$, where $p$ and $q$ are integers and $q\not\equiv0(modM)$. Output the integer equal to $p\cdot q^{-1}mod\ M$. In other words, output such an integer $x$ that $0\leq x&lt;M$ and $x\cdot q\equiv p(mod\ M)$.</p><h3 id="Examples-5"><a href="#Examples-5" class="headerlink" title="Examples"></a>Examples</h3><h4 id="inpus1"><a href="#inpus1" class="headerlink" title="inpus1"></a>inpus1</h4><p>1 1 1</p><h4 id="output1-5"><a href="#output1-5" class="headerlink" title="output1"></a>output1</h4><p>332748118</p><h4 id="input2-5"><a href="#input2-5" class="headerlink" title="input2"></a>input2</h4><p>6 2 1</p><h4 id="output2-5"><a href="#output2-5" class="headerlink" title="output2"></a>output2</h4><p>760234711</p><h4 id="input3-2"><a href="#input3-2" class="headerlink" title="input3"></a>input3</h4><p>7 5 3</p><h4 id="output3-2"><a href="#output3-2" class="headerlink" title="output3"></a>output3</h4><p>223383352</p><h4 id="input4-1"><a href="#input4-1" class="headerlink" title="input4"></a>input4</h4><p>97 31 9984524</p><h4 id="output4-1"><a href="#output4-1" class="headerlink" title="output4"></a>output4</h4><p>267137618</p><h3 id="Note-4"><a href="#Note-4" class="headerlink" title="Note"></a>Note</h3><p>In the first example, the expected total length is $\int_0^1 \int_0^1 |x-y|\ dx\ dy = \frac{1}{3} $, and $\frac{1}{3}$ modulo $998244353$ is $332748118$.</p><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>长度为l的线段，随机选取n个线段，线段中至少被n个线段中k个线段覆盖的长度期望。</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>说实话我当时没做出来，看了题解才知道怎么做的，所以强烈建议看官方的题解。我这里也贴出来，感兴趣的可以看一下。</p><p>Without loss of generality, assume that $l$=1. For a segment covering, the total length of the legal intervals is the probability that we choose another point $P$ on this segment randomly such that it is in the legal intervals. Since all $2n+1$ points ($P$ and the endpoints of each segment) are chosen randomly and independently, we only need to find the probability that point $P$ is in the legal intervals. Note that only the order of these $2n+1$ points make sense. Because the points are chosen in the segment, the probability that some of them coincide is $0$, so we can assume that all points do not coincide.</p><p>Now the problem is, how to calculate the number of arrangements that $P$ is between at least $k$ pairs of endpoints. It can be solved by dynamic programming in time complexity of $O(n^2)$. We define $f(i,j,x)$ as the number of arrangements for the first $i$ positions, with $j$ points haven’t been matched, and $P$ appeared $x$ times (obviously $x=0$ or $1$). So we can get three different types of transition for the $i$-th position below:</p><ul><li>Place $P$ at $i$-th position (if $j\geq k$): $f(i-1,j,0)\rightarrow f(i,j,1)$</li><li>Start a new segment (if $i+j+x&lt;2n$): $f(i-1,j-1,x)\rightarrow f(i,j,x)$</li><li>Match a started segment, note that we have 𝑗 choices of segments:$f(i-1,j+1,x)\times(j+1)\rightarrow f(i,j,x)$</li></ul><p>Then $f(2n+1,0,1)$ is the number of legal arrangements. Obviously, the total number of arrangements is $(2n+1)!$. However, there are 𝑛 pairs of endpoints whose indices can be swapped, and the indices 𝑛 segments can be rearranged. So the final answer is $\frac{f(2n+1,0,1)\times n!\times 2^n}{(2n+1)!}$.</p><p>可能是受了题解的影响，后来也没想出来其他解法。</p><p>这里讲一下题解怎么做的。</p><p>首先我们可以发现，长度和答案成正比，也就是说如果长度为1的时候答案是a，那么长度为2的时候答案就是2a%mod.</p><p>然后我们不妨设长度为1，最后答案乘上l就行了。</p><p>然后因为我们要找到至少被线段覆盖k次的所有点，所以我们不如加上一个虚拟点，这样就一共有了$(n&lt;&lt;1|1)$个点，然后需要判断这个虚拟点被多少条线段覆盖了，如果覆盖次数超过k次，就说明可以统计进答案。然后就可以发现，所有点是随机取的，所以我们假设所有点不会重合，那么所有点就可以离散成一个序列。然后就可以统计k的覆盖次数。</p><p>接下来就是dp，我们设$dp[i][j][flag]$表示序列中前i个点，其中到目前为止有j条线段左节点出线了，但是右节点没有出现，也就是说当前这个点被覆盖了j次，flag表示虚拟点是否出现了。然后考虑转移：</p><ul><li>当前节点是虚拟节点<ul><li>如果这个需要统计进入答案，也就是说明当前节点需要被覆盖k次及以上，所以 $j\geq k$</li><li>$dp[i][j][1]+=dp[i-1][j][0]$</li></ul></li><li>当前节点是一个线段的左端点<ul><li>也就是说左节点数量增加，被覆盖次数增加，但是不会影响虚拟节点的状态</li><li>$dp[i][j+1][flag]+=dp[i-1][j][flag]$</li></ul></li><li>当前节点是一个线段的右端点<ul><li>也就是说右节点数量增加，被覆盖次数减少，但是不会影响虚拟节点的状态,注意右端点可能会有j个可能</li><li>$dp[i][j-1][flag]+=dp[i-1][j][flag]*j$</li></ul></li></ul><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2345</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> (a+b)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> a*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span> </span>&#123;<span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:mul(a,fac(a<span class="number">-1</span>));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b = mod<span class="number">-2</span>)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = mul(ret,a);</span><br><span class="line">a = mul(a,a);</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,k,l;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxm&lt;&lt;<span class="number">1</span>][maxm][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;k,&amp;l);</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=k) dp[i][j][<span class="number">1</span>] = add(dp[i][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> flag = <span class="number">0</span>;flag&lt;<span class="number">2</span>;flag++)</span><br><span class="line"><span class="keyword">if</span>(dp[i<span class="number">-1</span>][j][flag])&#123;</span><br><span class="line"><span class="keyword">if</span>(j) dp[i][j<span class="number">-1</span>][flag] = add(dp[i][j<span class="number">-1</span>][flag],mul(dp[i<span class="number">-1</span>][j][flag],j));</span><br><span class="line"><span class="keyword">if</span>(i+(j+<span class="number">1</span>)-(<span class="number">1</span>-flag)&lt;=(n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) dp[i][j+<span class="number">1</span>][flag] = add(dp[i][j+<span class="number">1</span>][flag],dp[i<span class="number">-1</span>][j][flag]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = mul(dp[n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>],qpow(<span class="number">2</span>,n));</span><br><span class="line">ans = mul(mul(ans,l),mul(fac(n),qpow(fac(n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>))));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-Serval-and-Bus&quot;&gt;&lt;a href=&quot;#A-Serval-and-Bus&quot; class=&quot;headerlink&quot; title=&quot;A. Serval and Bus&quot;&gt;&lt;/a&gt;A. Serval and Bus&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1153/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>factorio</title>
    <link href="http://zuhiul.github.io/2019/03/31/factorio/"/>
    <id>http://zuhiul.github.io/2019/03/31/factorio/</id>
    <published>2019-03-30T16:00:00.000Z</published>
    <updated>2019-05-23T10:29:28.234Z</updated>
    
    <content type="html"><![CDATA[<h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><a id="more"></a><p><img src="../img/chepter1.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;level-1&quot;&gt;&lt;a href=&quot;#level-1&quot; class=&quot;headerlink&quot; title=&quot;level 1&quot;&gt;&lt;/a&gt;level 1&lt;/h3&gt;
    
    </summary>
    
    
      <category term="factorio" scheme="http://zuhiul.github.io/tags/factorio/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://zuhiul.github.io/2019/02/21/gluten/gluten_tt/"/>
    <id>http://zuhiul.github.io/2019/02/21/gluten/gluten_tt/</id>
    <published>2019-02-20T16:00:00.000Z</published>
    <updated>2019-04-14T08:32:10.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="头条面试回忆录"><a href="#头条面试回忆录" class="headerlink" title="头条面试回忆录"></a>头条面试回忆录</h2><h3 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h3><p>这两天参加了头条的面试,总体来说,感觉不错,公司效率很高…<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>当天上午投的简历,下午让我第二天面试,时间很紧,很多东西都没来得及准备….</p><p>1.自我介绍一下(balabalabala)</p><p>2.学过操作系统和计算机网络吗?(网络学了,操作系统下学期开,其实我很想说操作系统自学了,您可以问……)</p><p>3.说一下tcp和udp的区别(balabalabala)</p><ul><li>2.1那个快?为什么?(udp快,因为三次握手四次挥手会占用cpu时间?)</li><li>2.2去掉三次握手四次挥手那个快?(不知道)</li></ul><p>4.写两个题吧</p><ul><li>3.1 给你一个数字矩阵,每行每列都是增序,问你某个值是否存在(剑指offer原题,我100%做过,但是我忘了怎么做的,只知道从角上枚举,然后先说了一下从右下角枚举,说不对,然后换成右上角,没啥问题….)</li><li>3.2 给一个矩阵,四联通,找到一个最长上升子序列(简单dp,写完就过了)<ul><li>3.2.1 能把路径输出一下吗?(记录前驱….)</li><li>3.2.2 能把前驱数组去掉吗?(可以,瞎搞一下就行了…..)</li></ul></li></ul><p>4.闲聊(emmmmm)</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面感觉更严格,感觉答的不好…..</p><p>1.自我介绍(balabalabala)</p><p>2.有什么数据结构可以做到查询和插入都是o(1)的?(第一反映,显然不可能啊,这不是不可调和的矛盾吗?面试官说:知道hash吗?哇,感觉被鄙视了,确实傻了)</p><p>3.给你n个有序链表(从大到小),怎么找到这n个链表的前K大,(先取出每个链表的最大,然后建最大堆,然后每次取出堆顶,然后取出对应链表的后续元素,加入堆,然后一次操作,直到有k个元素)</p><ul><li>3.1 复杂度多少?(o(n+klogn))</li><li>3.2 n是怎么来的?(建堆时间)</li><li>3.3 能证明一下吗?(假设堆是用类树状数组的结构维护,先把数据随机放进来,然后每次从大到小枚举一个下标ind,比较当前位置ind和(ind&gt;&gt;1),然后根据大小关系交换一下,可以证明每次都是两个数比较,并且最多有n次比较,所以o(n))</li></ul><p>4.写两个题吧</p><ul><li>2.1 给你一个字典,给你一个询问串,问你能否用字典中的某些单词(每个单词只能用一次),构成询问串.(想复杂了,一直在想怎么优化,后来才知道直接暴力就行,我当时还傻乎乎的用了lower_bound企图缩小范围,结果返回结果还死活不对,搞了30分钟才搞定,感觉要凉)</li><li>2.2 可能是看我太菜,没问第二道题,感觉好像对我不感兴趣就溜了???</li></ul><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>不知道自己怎么活过二面的…….</p><p>1.聊天,纯聊天,可能是怕我太紧张,感觉面试官很好</p><p>2.提出自我介绍被拒绝…….</p><p>3.简单说一下项目,(也不用详细说,因为项目就是很简单……)</p><p>4.有啥很厉害的技术要说明的吗?(没有……)</p><p>5.我们写两个题吧</p><ul><li>5.1 给你一个无根树,让你转化成有根树,使得树的深度最小(一眼直径的中点,写了一下,好像有点问题,我问他我是调一下还是?他说不用调了,想法没啥大问题)</li><li>5.2 初始位置0,速度1,两个操作<ul><li>1.position+=spead,spead*=2</li><li>2.spead&gt;0,spead = -1;else spead = 1</li><li>问你最少操作几次,使得,从0到x</li><li>我第一想法二进制拆分,然后瞎搞,写了一下,没啥大问题</li><li>复杂度?(32^2?)</li><li>怎么证明,我说每次考虑最高位的1,然后瞎搞一下balabalabala</li><li>说正解是dp,比我复杂,emmmmm……..</li></ul></li></ul><p>6.浏览器输入baidu.com会发生啥?(balabalabala,昨天看过,不知道说的对不对)</p><p>7.你有啥觉得自己的技术亮点要说吗?(感觉瞎bb都能加分,但是我怂,老老实实说自己没啥技能点……)</p><p>8.你想过一些大的厂商,背后的技术部门都是怎么运行的吗?(不知道……..)</p><p>9.面试官可能觉得没啥聊的了,就放我走了……</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说,面试官还是很和蔼的,有些问题还会引导你向正确的方向思考,问题都不难,好好准备应该好过,就这样吧…….</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;头条面试回忆录&quot;&gt;&lt;a href=&quot;#头条面试回忆录&quot; class=&quot;headerlink&quot; title=&quot;头条面试回忆录&quot;&gt;&lt;/a&gt;头条面试回忆录&lt;/h2&gt;&lt;h3 id=&quot;废话&quot;&gt;&lt;a href=&quot;#废话&quot; class=&quot;headerlink&quot; title=&quot;废话&quot;&gt;&lt;/a&gt;废话&lt;/h3&gt;&lt;p&gt;这两天参加了头条的面试,总体来说,感觉不错,公司效率很高…&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://zuhiul.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
