<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>睡到二三更时      凡荣华皆成幻境</title>
  
  <subtitle>每份努力,必有回报</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zuhiul.github.io/"/>
  <updated>2019-05-09T01:28:35.396Z</updated>
  <id>http://zuhiul.github.io/</id>
  
  <author>
    <name>zuhiul</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>就怕我感动了自己，却没有感动你</title>
    <link href="http://zuhiul.github.io/2019/12/23/story/"/>
    <id>http://zuhiul.github.io/2019/12/23/story/</id>
    <published>2019-12-22T16:00:00.000Z</published>
    <updated>2019-05-09T01:28:35.396Z</updated>
    
    <content type="html"><![CDATA[<p>我爱你，像蚁溃洪堤，一泻千里。</p><a id="more"></a><h2 id="201905"><a href="#201905" class="headerlink" title="201905"></a>201905</h2><h3 id="20190501"><a href="#20190501" class="headerlink" title="20190501"></a>20190501</h3><h4 id="20190501-09-00-AM-update"><a href="#20190501-09-00-AM-update" class="headerlink" title="20190501 09:00 AM update"></a>20190501 09:00 AM update</h4><p>今天开始我想记录下和她的所有故事。</p><h4 id="20190501-06-15-PM-update"><a href="#20190501-06-15-PM-update" class="headerlink" title="20190501 06:15 PM update"></a>20190501 06:15 PM update</h4><p>今天终于见到了心仪的小姐姐了，然后在天津逛了一大圈，刚下高铁，吃了个饭，然后逛了会街，然后就去听相声，然后逛了逛他们学校，在图书馆坐了一会就这样，哈哈哈哈哈哈哈，巨开心</p><h4 id="20190501-11-52-PM-update"><a href="#20190501-11-52-PM-update" class="headerlink" title="20190501 11:52 PM update"></a>20190501 11:52 PM update</h4><p>下午的时候和她一起去吃了个饭。然后我回宾馆把东西放下后就拉着她各种溜达，但是感觉她兴致不高。可能是她要考研的缘故。确实，感觉拉着一个想考研的人也挺罪恶的。但是我是真的很开心，哇，真的是只要想到和她一起，真的是压马路都巨开心<em>^_^</em></p><h3 id="20190502"><a href="#20190502" class="headerlink" title="20190502"></a>20190502</h3><h4 id="20190502-00-31-AM-update"><a href="#20190502-00-31-AM-update" class="headerlink" title="20190502 00:31 AM update"></a>20190502 00:31 AM update</h4><p>君子爱玉如将帅熬鹰，我不急，对你我有无限的耐心。</p><h4 id="20190502-09-56-AM-update"><a href="#20190502-09-56-AM-update" class="headerlink" title="20190502 09:56 AM update"></a>20190502 09:56 AM update</h4><p>看来你昨天是真的累了，以至于你现在才醒，我倒是挺担心的，7点半就醒了，然后给你发消息没回，就知道你是累着了。哎，心疼。准备去找你的，被你拒绝了。非说你来找我，也行吧。</p><p>有时候我还挺惶恐的，万一就是南柯一梦就尴尬了，不过我现在是真的开心呀呀呀呀呀呀。</p><h4 id="20190502-11-26-PM-update"><a href="#20190502-11-26-PM-update" class="headerlink" title="20190502 11:26 PM update"></a>20190502 11:26 PM update</h4><p>晚上约你吃晚饭，然后顺气自然的表白了？说实话是准备留到明天说的，但是一不小心漏嘴了，天真以为会挺顺利的。自认为还是不错的？但是好像有点出乎意料？巨难受？</p><h3 id="20190503"><a href="#20190503" class="headerlink" title="20190503"></a>20190503</h3><h4 id="20190503-00-42-AM-update"><a href="#20190503-00-42-AM-update" class="headerlink" title="20190503 00:42 AM update"></a>20190503 00:42 AM update</h4><p>还是没想明白到底是哪个环节出问题了？而且我都明说了不逼你？我可以等234天啊啊啊啊啊啊啊啊啊啊，难受！</p><h4 id="20190503-10-04-AM-update"><a href="#20190503-10-04-AM-update" class="headerlink" title="20190503 10:04 AM update"></a>20190503 10:04 AM update</h4><p>混进了你们学校，然后又混进了你们图书馆，哈哈哈哈，当时门卫看了我一眼我都有一种做贼的感觉，真刺激。坐在图书馆写下这一段文字，还是略难受？反正还没缓过来？其实吧，你之前拒绝我的时候我都安慰自己，我还不够优秀啊，我要更优秀一点，所以我之前一直很怂啊，这段时间才敢和你说话，但是好像啊，你还是这样啊，说明啊，我还得努力啊，冲鸭。</p><h4 id="20190503-10-26-AM-update"><a href="#20190503-10-26-AM-update" class="headerlink" title="20190503 10:26 AM update"></a>20190503 10:26 AM update</h4><p>还记得昨天去失恋博物展，记得当时我两感受都相同，别人的故事始终是别人的故事，打动不了自己，现在想来就是这种感受，一直都是我的一厢情愿，还奢望你的回应，说到底还是自己感动了自己，却没有感动你。</p><h4 id="20190503-06-52-PM-update"><a href="#20190503-06-52-PM-update" class="headerlink" title="20190503 06:52 PM update"></a>20190503 06:52 PM update</h4><p>你去上厕所去了，我偷偷码一点。</p><p>每每想到你连一点妄想都不给我就巨难受，看着你画了一下午的画，你认真画画的样子真的很美。但是我还是不知道你到底是啥意思，还是单纯的难过。</p><h4 id="20190503-09-08-PM-update"><a href="#20190503-09-08-PM-update" class="headerlink" title="20190503 09:08 PM update"></a>20190503 09:08 PM update</h4><p>09:05开的高铁，我们8:55还没看到车站，我估计是赶不上了，当时我们两一起在大马路上跑，我真的有一种私奔的感觉。当时过安检的时候，我真的好难受，感觉自己像失去了你一样，但是都没有得到过何谈失去呢？</p><p>我当时就想啊，如果我还能赶上车，那就是老天真的不帮我了，如果赶不上我就赖上你了，但是好死不活晚点了？真的是气哭了。看来还是我心急了，贼老天都不帮我了，所以爱情这东西啊，还得时间沉淀，所以啊，我不急啊，所以啊，我可以等啊，所以啊，我唯一怕的就是你不见了啊。</p><p>就这样吧，再见了。</p><h3 id="20190504"><a href="#20190504" class="headerlink" title="20190504"></a>20190504</h3><h4 id="20190504-00-54-AM-update"><a href="#20190504-00-54-AM-update" class="headerlink" title="20190504 00:54 AM update"></a>20190504 00:54 AM update</h4><p>估计你睡了，写好的东西最后还是发给你了，也不管你看不看了，反正肺腑之言，不吐不快。</p><p>果然你没睡着，和你说了两句，看你没兴趣我就溜了。</p><h4 id="20190504-1-37-AM-update"><a href="#20190504-1-37-AM-update" class="headerlink" title="20190504 1:37 AM update"></a>20190504 1:37 AM update</h4><p>看了你是真的了，今天就不等了，毕竟我又不是你的谁，劳累你三天了，本来就挺过意不去的，就这样也好，是你说的，好歹还能保存美好的回忆不是？</p><p>让你填志愿和考完研和我说一声，不知道你会不会说，232天，会有多少变数呢？谁都不知道，我现在唯一能做的就是更努力吧。</p><h4 id="20190504-01-00-PM-update"><a href="#20190504-01-00-PM-update" class="headerlink" title="20190504 01:00 PM update"></a>20190504 01:00 PM update</h4><p>队友看我实在是太难受了，拉着我去打球了，打了一个小时，我实在是不想动了。就拉着他回公司了，码下这一段了，你猜我想开需要多久？估计你不敢和我打赌了？</p><h4 id="20190504-05-44-PM-update"><a href="#20190504-05-44-PM-update" class="headerlink" title="20190504 05:44 PM update"></a>20190504 05:44 PM update</h4><p>我现在突然挺后悔当时没有定三晚上酒店，那样的话，我们至少还能多待一起一天不是吗？虽然可能没那么开心，但是至少还能看到你不是吗？我现在真的是啥都不想干了。</p><h4 id="20190504-10-45-PM-update"><a href="#20190504-10-45-PM-update" class="headerlink" title="20190504 10:45 PM update"></a>20190504 10:45 PM update</h4><p>我现在挺想和你打个赌的，你猜232天能否冲淡我对你的想法呢？我赌不会。如果真的淡了，我也不知道该说好还是不好，ok，我现在就数日子等我赢，刚刚给你发了日报，没有别的意思，只是希望你每天能整理整理，希望你好，（可能也有不甘心作祟？），不知道啦，我也很茫然的好伐。</p><h3 id="20190505"><a href="#20190505" class="headerlink" title="20190505"></a>20190505</h3><h4 id="20190505-10-24-AM-update"><a href="#20190505-10-24-AM-update" class="headerlink" title="20190505 10:24 AM update"></a>20190505 10:24 AM update</h4><p>劝自己暂时放下，安心搬砖，好好学习。唯一能让我安慰的就是我们组另外一个人表白也被拒绝了，但是我还是很难受，我果然是个loser，连同组的人都和我一样惨，哭了。</p><h4 id="20190505-12-13-AM-update"><a href="#20190505-12-13-AM-update" class="headerlink" title="20190505 12:13 AM update"></a>20190505 12:13 AM update</h4><p>emmmm,前几天，天天中午吃饭很早，以至于我现在饿了，但是还有半个小时才吃饭，饿得不行。哇，我还想和你一起吃饭。231天，我要是约饭，你不来，打你呦。</p><h4 id="20190505-12-57-AM-update"><a href="#20190505-12-57-AM-update" class="headerlink" title="20190505 12:57 AM update"></a>20190505 12:57 AM update</h4><p>刚刚和老大他们聊了一下，他们的意思都是劝我放弃，说我还年轻，不值得，同样的人还会遇到很多，但是我目前还不这样想，有时间确实需要好好整理一下，并不知道自己到底想要的是什么，这不像我，我一直以为自己想要的东西很明确，但是这件事上，确实还有疑惑的地方。让我想到了以前看到的一句话：</p><p>“无论是朋友，工作还是恋爱，如果你感到与对方特别契合，沟通愉悦甚至时时让你灵光乍现，你知道这说明什么吗？<br>99%的可能是你遇到了阅历智商情商都在你之上的人，而且对方因为什么目的在向下兼容而已，只要TA愿意，TA可以和每个跟你一样级别的人，打到这种心有灵犀，<br>剩下的1%就是你遇到了SOULMATE。”</p><p>我并不知道我遇到的到底是什么，按照你前几天的意思是：我对你了解太多了，所以你的意思是我是你的99%？可能吧，可能只有我觉得我们是那1%，我一直以为我们不需要言语的交流是默契，现在看来可能不是？可能只是大家见的多了，就明白了，懂得察言观色？我并不知道，但是我很习惯这种感觉。</p><p>他们都说，人这个东西啊，很奇怪，可能你现在看到的人，喜欢的人，愿意放弃一切为了的人，可能过几年再看就不过如此了。我不知道，但是我现在确实很放不下。我一直觉得，这种人，可能十年都遇不到一个，放弃太难了。我想过几次，到底是为啥，你会拒绝，我暂时的理解是，我还不够优秀，所以我还要努力。他们说，等你变的优秀了，你就会明白，什么才是你想要的人。说真的，我不懂，不知道谁说的是对的。所以我选择让时间筛选，没有什么是时间搞不定的。231天后，一切都会有答案，如果你真的讨厌我，我就离开了，就当做是一场年少无知的梦。</p><h4 id="20190505-04-47-PM-update"><a href="#20190505-04-47-PM-update" class="headerlink" title="20190505 04:47 PM update"></a>20190505 04:47 PM update</h4><p>他们说让我忙起来，忙起来就不会想你了，但是我现在好闲啊，也不想忙起来，今天有比赛，但是已经没心情打了，怪只怪自己太年轻了，以前居然会觉得比赛比你有意思。老大说，错过了就是错过了，有些时候不能强求，我不知道，不知道该怎么做，不敢强求。</p><h4 id="20190505-09-36-PM-update"><a href="#20190505-09-36-PM-update" class="headerlink" title="20190505 09:36 PM update"></a>20190505 09:36 PM update</h4><p>开发的东西很快就做完了，所以今天一直很闲，然后复习的事也就随便搞了搞，反正也不怎么想搞学习了，然后和队友商量了一下考研的事，他们建议不要冲动读医，说是时间可能耽误不起，不太清楚，感觉涉及到他们的利益问题了，所以谁都说不清楚。然后下午到现在都在杂七杂八的看，配了配博客，看了看latex，看了看vim，学了学haskell，反而是感觉啥都没干，其实我还挺怕这种感觉的，挺怕时间真的将我们冲淡了，很奇怪的是，我今天很平静，异常平静，没有难受也没有开心，我不知道这是不是变淡的原因，反正时间真的在一点点冲淡吧，然后后天有考试，索性把明天的假也给请了，明天好好休息一下，有些东西也确实需要理一理。</p><p>emmmm，但是说自己对医学感兴趣是骗你的，是因为我对你感兴趣罢了，但是我确实是真的耐着性子读了一半的卫生统计学，无论是简单还是难，我都耐着性子读了。在你拒绝我两次之后，那本书就放在角落接灰了。确实提不起兴趣读下去。偶尔想想自己目的性其实也很强的，emmmm，可能是功利性很强，没有用的事情就不做了。暂时还不清楚，可能等着这三周考完试之后会重新捡起来接着读？然后整理整理笔记？然后假装很早之前整理的，然后发给你？然后试图感动你？呵呵，渣男！反正现在暂时是这么想的吧。妈呀，从来没想过为了哄一个女孩子开心，我居然这么有心机，太恐怖了。</p><p>哎，反正这两天想的挺多的，暂时也不知道自己在想啥，很多时候都是没想明白搞得错，反正以后三思而行吧，也不敢太打扰你了，日报今天还是决定接着发，发21天就溜了，能对你造成多少好的坏的影响我也不知道，我也不敢说这一套在你这是否是对的，只求心安罢了。</p><h3 id="20190506"><a href="#20190506" class="headerlink" title="20190506"></a>20190506</h3><h4 id="20190506-10-44-AM-update"><a href="#20190506-10-44-AM-update" class="headerlink" title="20190506 10:44 AM update"></a>20190506 10:44 AM update</h4><p>今天虽然请假了，还是来公司玩了会，刚喝了口水，现在开始码这段文字。</p><p>这几天睡眠质量特别不好，应该是从5.1晚上开始的，可能是担心你身体状态，我应该和你说过，当时第二天我六点就行了，怎么也睡不着，也不敢给你发消息，怕你还在休息，我以为只是这个原因，现在看来不是，已经三天没见你了，但是还是基本六点多就醒了，然后也不怎么睡得着，因为队友还在睡觉也不敢起床，偶尔躺在床上会背背单词，偶尔也会想想你，偶尔也不知道自己在干啥。</p><p>五点钟的票回学校，暂时还没定下来啥时候走，我应该和你说过，我不想赶路，所以一般会有预留，地铁大概是一个小时，所以我打算提前两个小时走，就算走错了，好歹还有挽回的余地。</p><p>哎，其实一个人赶路还挺无聊的，还是两个人在一起比较好玩，旅途寂寞鸭。昨天给你发日报了，你还是没回我，可能是把我拉黑了？不知道，没有别的意思，只是想让你养成一个（我也不知道是好是坏的）习惯罢了。别太敏感啊。</p><h4 id="20190506-03-53-PM-update"><a href="#20190506-03-53-PM-update" class="headerlink" title="20190506 03:53 PM update"></a>20190506 03:53 PM update</h4><p>现在闲下来了，就等高铁了，然后就想了想之前几天发生的事，其实我还是觉得挺玄学的，首先就是失恋博物展的那个球，说好都是脱单呢，怎么就咱两是单身了，不过说的也对，12.23才考完研，今年是不指望脱单了。</p><p>还有就是单车那个事，都10点四十了，还有四十分钟的路程，显然是赶不回去的啊，怎们回事啊，居然还能遇到各种单车，还有就是我为啥骑车那么慢，你真的不知道？怎么可能是因为累了，还不是不像你回学校吗。这样好歹有一晚上的时间，哪怕是纯聊聊天也行啊，你咋回事啊，看不出来？哇，就两三分钟就进不去了，你可真的赶啊，话说我还真不知道你是不懂还是装不懂，可能二者兼有，不清楚啊。但是我宁愿是前者吧。</p><p>230天，我离你又进了一步，但是你退后了多少呢？</p><h4 id="20190506-10-05-PM-update"><a href="#20190506-10-05-PM-update" class="headerlink" title="20190506 10:05 PM update"></a>20190506 10:05 PM update</h4><p>马上就要到学校了，想到了当时去你们学校的时候，当时在你们图书馆歇息的时候，你应该是真的困了，都怪我当时不知道关心，让你受累了。现在想想当时怎么着也得让你休息休息啊。真的是迂腐之极。哇，不行了，想起的细节越多，越觉得自己是真的蠢。</p><p>今天一天都在赶路，所以整个人的状态不是很好。而且也不太喜欢这种放松的感觉，但是还是不想学习。话说现在心态真的是变了好多了，今天我队友还在劝我放弃，我不知道，可能还是当局者迷的缘故，但是还是没和你说，今天还是照旧把日报发给你了，今天是第三天，还剩18天，然后就应该不会给你发消息了，让你安心考研了，考完研有的是时间不是吗？</p><h3 id="20190507"><a href="#20190507" class="headerlink" title="20190507"></a>20190507</h3><h4 id="20190507-10-35-AM-update"><a href="#20190507-10-35-AM-update" class="headerlink" title="20190507 10:35 AM update"></a>20190507 10:35 AM update</h4><p>229天了，今天突然有一种报复心理，我一定要让你后悔。</p><p>突然想到当时和你一起听相声的时候那个哥说了一句“我对于这种人，没有羡慕没有嫉妒，只有恨”，哈哈哈，说实话，这就是传说中的由爱生恨吗？反正我现在挺难受的，突然也想让你难受一下，哈哈哈，开个玩笑。</p><p>最后悔莫过于因为年少无能而放下。我拼命成长不过是为了你回眸一笑。他们说等你以后长大了会遇到不一样的人，不一样的景，而我只想记住每一个不一样的你。</p><h3 id="20190508"><a href="#20190508" class="headerlink" title="20190508"></a>20190508</h3><h4 id="20190508-10-38-AM-update"><a href="#20190508-10-38-AM-update" class="headerlink" title="20190508 10:38 AM update"></a>20190508 10:38 AM update</h4><p>228天。</p><p>昨天晚上的时候，你终于是回复我了，说是怕我考试有影响，这件事怎么说呢，你要是早点回复我的话，我可能还会开心一点。但是还是挺开心的，好歹回复我了。</p><p>昨天晚上聊了一下，应该再不会打扰你了，然后以后真有啥想说的，就更新到这里了，确实不该打扰你的，扰菇凉良久，菇凉莫怪啊。</p><p>昨天你和我说，哎，算了不评价，怎么说呢，大家都在慢慢成长吧。</p><p>不过有句话你说的还是挺对的，等待会让东西变质，或许应该换句话说：时间会让东西变质。没有什么可以敌得过时间。我深知我也不行，但是我觉得200+天还是不难的吧。</p><p>还有就是你说的对，拒绝就应该拒绝到底，你做的很好，但是我还是很难过，毕竟当一个人真正拒绝你的帮助的时候就是真的想和你断了吧。至少没有钓着你的心思，或许我应该开心？</p><p>后来仔细思考了这段时间的经历，感觉确实有些自作多情了，很多时候都是自己一厢情愿罢了。</p><p>emmmm，大概就是这样了，可能真的是告一段落了，也不会找你聊天了，大家都松口气，如果真的是有缘，再见吧。</p><p>当我码下这段文字，无悲无喜，甚至有一种完成任务的感觉，轻松？算不上吧。只是觉得暂时放下了一些东西，可以安心前行了。</p><p>可能也和我老大说的对，他说我纯粹是大学时候没干什么，然后大学快结束了想干点什么，我不知道，当然也可能是自己飘了，觉得世界尽在掌握中，所以开始有恃无恐了。还好，你让我明白，自己还有很多的努力方向，还是不够优秀啊。所以继续努力吧。</p><p>现在也不敢随便立flag了，但是还是想说一下，如果你真的准备二战的话，我就准备考研了，和你一起，哪怕你不理我，我也要强求一把。当然如果你真的考上了的话，我也要准备跳槽了，反正能近一点就近一点吧。真的是怕了。</p><h4 id="20190508-12-55-PM-update"><a href="#20190508-12-55-PM-update" class="headerlink" title="20190508 12:55 PM update"></a>20190508 12:55 PM update</h4><p>刚刚吃饭聊了一下，反正我感觉我还好啊，没有你说的那种腼腆的感觉，可能很多时候在想事情所以没怎么说话，或者说是很多话不太好意思说，或者是感觉说出来不好，可能你觉得我在欲言又止？或者说是“腼腆”。不太清楚，哇，第一天我可是嗓子都说哑了，你居然会觉得我腼腆。不过说真的，刚见到你的一瞬间真的是有好多话想说但是真的是，虽有千万肺腑之言，却又无语凌噎。emmmm，刚见到你的时候是在瓷房子门口，当时还挺想抱你一下的，但是当时咱们前面有一个围栏，不知道你注意了没有，然后就放弃了。哎，还是太怂了。</p><p>昨天你给我发消息之后真的是好晚才睡着，本来12点钟就放下手机啦，硬是拉着舍友聊天，聊我和你，硬拉这聊到了一点半。哎，回想这几天发生的事，还是有些地方没有做好。还是有很多事挺后悔的，用我队友的话来说就是我太怂了。很多时候都过于胆怯。</p><p>我脑子里突然蹦出一个词来——自卑，其实仔细回想一下，很多时候我大概都是自卑心作祟。你也说了，你觉得我很优秀，其实我一直不这么觉得，反正每次觉得自己还行的时候总能遇到一些吊人，然后看看他们的经历，然后就觉得自己还有很多地方需要努力。</p><p>还有就是你觉得我把你美化了，这个不好评价，自古有云：情人眼里出西施。我不知道是不是因为某些奇奇怪怪的原因导致的。所以暂不做评价。但是真的是觉得你是个挺好的菇凉啊，一直觉得你值得世间上最美好的东西。有时候，看着你皱眉头真的是还略有难受？反正感觉你要是真能无忧无虑的生活还是挺好的。这段时间你应该是为我烦了，我也就暂时不打扰你了，等你安心考完研吧。反正这个事不急，咱们还年轻，有大把时间可以挥霍。哈哈哈哈哈。</p><p>还有就是这段时间准备开始锻炼了，主要是当时第一天我们都走累了，我想了一下，要不要公主抱你，后来估计了一下自己的身体状态，还是觉得太虚了，所以这段时间准备好好锻炼一下。还有就是学习的事，这段时间我考试实在是太多了，工作时间也压得很紧，所以暂时不考虑接着读卫统了，先把考试糊弄过去再说，之前看过的一半也没有整理笔记，题目也是杂七杂八做了，没有系统的整理，还是准备从头开始读，然后顺便整理整理笔记，题目也暂时不做了。先读完再说。感觉东西不是很难，所以希望你不要着急，慢慢复习就行。现在时间虽说不多了，但是也不用太着急，估计你这几天都没有在12点之前睡过觉，还是要早些歇息为好。</p><p>对了，你画的那幅画，我暂时还没有挂起来，因为房间里的那幅画是竖的，你画的是横的，不太好弄，所以准备抽时间去买个钉子，重新钉一下，然后再挂起来，不过你也别担心会弄坏了，我保存的老好了。偶尔学习累了会看看那幅画，你画的真好看，当然，你也好看。</p><p>还有就是那天我真的没有占你便宜啊，我说的都是心里话，你不是也没反驳吗？我就当你默许了。反正等你考完研我就非要缠着你，和你一起准备复试。至于我考研？暂时还没定，等省赛结束之后再说吧。看省赛情况，其实吧，我还挺想省赛打的不太好的，这样就能安心学习了。感觉比赛真的已经没有了当年的激情了。</p><p>还有就是舍友昨天晚上和我聊了关于感情会随着时间的延长而降低。他说如果你真是我对象，可能两个月我就没有了现在的感觉了。我不知道，但是你看你，就做的很好啊，直接拒绝了我，让我有时间去思考和解释这件事，等我想的差不多了，咱们就在一起了？</p><p>说到底还是得抽时间想一想这件事，下周就省赛了，省赛结束应该会有时间思考这个问题，就这样。</p><h4 id="20190508-06-22-PM-update"><a href="#20190508-06-22-PM-update" class="headerlink" title="20190508 06:22 PM update"></a>20190508 06:22 PM update</h4><p>今天活干完了，现在算是比较闲了，不知道干啥了。</p><p>所以就过来bb两句。这两天的状态不是很好，一部分是舟车劳顿的缘故，另外一部分原因就是突然有了迷茫的感觉：突然不知道了自己真正想要的是什么。是工作？是考研？是恋爱？我不知道，一直以来都很讨厌这种感觉，不知道自己想要什么可能是一种病态的迷茫，也很容易变成空洞的人。其实我还挺羡慕你的目的性的，能知道自己想要什么真的是一种很好的状态。它会至少让你有个目标，然后剩下要做的就很简单了，细化目标，完成目标。</p><p>好像说这些在这里不合适，说一点和你有关的。</p><p>你说我很多时候能一眼看穿你，emmm，这件事怎么说呢，我的解释是，咱两有天然的默契，这种默契与生俱来，不用培养，不用磨合。我最爱的就是这种状态。我一直以为这种情况是天作之合，很少有人能这样默契吧？这辈子能遇到一个真的很不容易，或许没了这份默契就不那么喜欢你了？我不知道，但是我是真的喜欢这种默契，你也知道，我情商很低，说明咱两都没耍心眼，所以这种与生俱来的默契难道不值得被珍惜吗？反正我是不打算就这么错过了。他们说这种默契，一个人一辈子会遇到很多，我不信，真的不信。反正这一次，我一定要抓住。</p><h4 id="20190508-7-24-PM-update"><a href="#20190508-7-24-PM-update" class="headerlink" title="20190508 7:24 PM update"></a>20190508 7:24 PM update</h4><p>他们说的其实挺对的，人啊一旦忙起来什么都忘了，所以当时他们劝我忙起来就好了，这几天确实渐渐忙起来了。但是偶尔还是做事做到一半被打断，然后就神游太虚了。。。当然也可能是还不够忙。就是偶尔闲下来连个聊天的人都没有，还是挺难受的，之前还能和你聊聊天，现在都不敢给你发消息了。就这样吧。真有啥想说的，我就写这里了。</p><p>其实我一直都没想好 自己到底为啥要写这个东西，或者说写这个东西的目的是什么，虽然不怎么花时间，一天大概也就半小时，但是确实不明白写这个的目的是啥，写给50年后的自己看？那也太矫情了。还是写给228天后的你看？那也太无耻了。暂时没想好，只是单纯的觉得，能遇见你还是一件挺幸运的事，挺值得怀恋和回忆的事，所以就这样记录下来了，就算以后真的不能在一起了，想到以前喜欢过这么可爱一个菇凉，也是一件随时回忆起来都能让人开心的事吧？</p><h4 id="20190508-11-30-PM-update"><a href="#20190508-11-30-PM-update" class="headerlink" title="20190508 11:30 PM update"></a>20190508 11:30 PM update</h4><p>还好当时没有公主抱你，突然感觉自己好虚啊，不行了，接下来一段时间准备好好锻炼一下了，等下一次见面给你一个惊喜，到时候抱你没跑。</p><h3 id="20190509"><a href="#20190509" class="headerlink" title="20190509"></a>20190509</h3><h4 id="20190509-09-19-AM-update"><a href="#20190509-09-19-AM-update" class="headerlink" title="20190509 09:19 AM update"></a>20190509 09:19 AM update</h4><p>今天早起了，背了会单词，然后就来公司学习了，复习时间就剩下今天和明天了。</p><p>早上的时候看到公交车让了一个老人过马路，不禁想起了我从天津回来的时候，当时晚上11点多了，我其实还挺累的，当时我后面是一对夫妻，带着两个孩子，两个孩子都睡着了，当时因为你拒绝我，我真的挺难受的，犹豫了一段时间还是让他们排在我前面，当时我想了好长时间，我都这么惨了，为啥还要对世界抱有善意？再后来，也就是上周考完试了，我回北京的时候，当时我身上还有一点现金，北京地铁现在好像还不让用微信？反正一个人在那干着急，想了想还是帮助了一下。我真的不清楚，为啥自己还要对陌生人抱有善意，真的是，自己过的就已经够惨了。后来想想还是为自己积福吧。所以我就想啊，我都以德报怨了，你总不能拒绝一个商量的小男孩吧。</p><p>今天北京天气很好，早上八点钟就已经有了太阳，真的很想出去逛逛，后来想想一个人还是挺无聊的。突然想到了当时给你打伞的日子，哈哈，我记得当时有一段时间，当时人流拥挤，你头都不回就往前冲，哇，当时还是太怂了，当时就应该拉住你，让你等等我的，后来好像因为打伞不及时被你吐槽了？哈哈，感觉你当时委屈的抱怨的时候的样子真的很可爱。哎，当时太直男了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我爱你，像蚁溃洪堤，一泻千里。&lt;/p&gt;
    
    </summary>
    
    
      <category term="story" scheme="http://zuhiul.github.io/tags/story/"/>
    
  </entry>
  
  <entry>
    <title>Haskell学习笔记</title>
    <link href="http://zuhiul.github.io/2019/05/05/haskell/"/>
    <id>http://zuhiul.github.io/2019/05/05/haskell/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-05T13:34:24.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h2><a id="more"></a><ul><li>变量不可修改，中途修改，后续的操作实际上是另外一个变量。</li><li>不显式的给类型，可能解释为不同类型，导致出错。</li><li>函数定义 let functionName var1,…,varn = var1 operation var2,…,varn</li><li>函数中的变量不受外部变量的影响，哪怕重名。</li></ul><h2 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h2><ul><li>列表元素必须为同一类型。</li><li>使用(:)cons操作符可以很容易的创建列表，但是需要注意只能适用于something:someList形式。用中括号创建。</li><li>元组可以是不同元素的集合。用小括号创建。可用来支持函数多返回值。可用fst和snd取二元组第一第二元素。</li><li>用元组来构成的列表，各元组类型必须相同。</li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li>函数可以写在文件中，然后用   <strong>:load</strong>   命令来读取文件。</li><li>同一个变量不应该被创建多次，所以意味着顺序不重要。</li><li>和py相同，靠缩进判别代码块，所以要注意缩进。</li><li>支持重复调用，用   <strong>.</strong> 来实现，例如:<strong>(f.square)</strong> 表示先调用 <strong>square</strong> 返回结果传给 <strong>f</strong> ，再返回结果。</li></ul><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><ul><li>函数类型 <ul><li>not :: Bool -&gt; Bool</li><li>unlines :: [string] -&gt; string</li><li>unwords :: [string] -&gt; string</li><li>chr :: Int -&gt; Char</li><li>ord :: Char -&gt; Int</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量和函数&quot;&gt;&lt;a href=&quot;#变量和函数&quot; class=&quot;headerlink&quot; title=&quot;变量和函数&quot;&gt;&lt;/a&gt;变量和函数&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Haskell" scheme="http://zuhiul.github.io/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 63</title>
    <link href="http://zuhiul.github.io/2019/04/28/Educational%20Codeforces%20Round%2063/"/>
    <id>http://zuhiul.github.io/2019/04/28/Educational Codeforces Round 63/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-04-29T06:37:03.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-Delivery-Oligopoly"><a href="#F-Delivery-Oligopoly" class="headerlink" title="F. Delivery Oligopoly"></a>F. Delivery Oligopoly</h2><p><a href="https://codeforces.com/contest/1155/problem/F" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>The whole delivery market of Berland is controlled by two rival companies: BerEx and BerPS. They both provide fast and reliable delivery services across all the cities of Berland.</p><p>The map of Berland can be represented as an <strong>undirected</strong> graph. The cities are vertices and the roads are edges between them. Each pair of cities has no more than one road between them. Each road connects different cities.</p><p>BerEx and BerPS are so competitive that for each pair of cities $(v,u)$ they have set up their paths from $v$ to $u$ in such a way that <strong>these two paths don’t share a single road.</strong> It is guaranteed that it was possible.</p><p>Now Berland government decided to cut down the road maintenance cost by abandoning some roads. Obviously, they want to maintain as little roads as possible. However, they don’t want to break the entire delivery system. So BerEx and BerPS should still be able to have their paths between every pair of cities non-intersecting.</p><p>What is the minimal number of roads Berland government can maintain?</p><p><em>More formally, given a 2-edge connected undirected graph, what is the minimum number of edges that can be left in it so that the resulting graph is also 2-edge connected?</em></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two integers $n$ and $m$ ($3\leq n\leq14$, $n\leq m\leq \frac{n(n-1)}{2}$) — the number of cities and the number of roads between them.</p><p>Each of the next 𝑚 lines contains two integers $v$ and $u$ ($1\leq v,u\leq n,v\neq u$) — the cities connected by the next road.</p><p>It is guaranteed that each pair of cities has no more than one road between them. It is guaranteed that each pair of cities have at least two paths between them that don’t share a single road.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The first line should contain a single integer $k$ — the minimum number of roads Berland government can maintain so that BerEx and BerPS are still able to have their paths between every pair of cities non-intersecting.</p><p>The next $k$ lines should contain the list of roads which are being maintained. Each line of form “$v\ u$”, where $v$ and $u$ are cities connected by the next road.</p><p>If there are multiple lists of minimum size, print any of them. The order of roads in the list doesn’t matter.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1"><a href="#input1" class="headerlink" title="input1"></a>input1</h4><p>3 3<br>1 2<br>2 3<br>3 1</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>3<br>1 3<br>3 2<br>1 2</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>4 5<br>1 2<br>1 4<br>2 3<br>4 3<br>1 3</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>4<br>1 4<br>4 3<br>3 2<br>1 2</p><h4 id="input3"><a href="#input3" class="headerlink" title="input3"></a>input3</h4><p>6 10<br>1 2<br>2 3<br>3 1<br>3 4<br>4 5<br>5 6<br>4 6<br>2 5<br>1 6<br>3 5</p><h4 id="output3"><a href="#output3" class="headerlink" title="output3"></a>output3</h4><p>6<br>1 6<br>6 5<br>5 4<br>4 3<br>3 2<br>1 2</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>Here are graphs from the examples, red edges are the maintained ones.</p><p><img src="/img/cf_1155_f_1.png" alt="cf_1155_f_1.png"></p><p><img src="/img/cf_1155_f_2.png" alt="cf_1155_f_1.png"></p><p><img src="/img/cf_1155_f_3.png" alt="cf_1155_f_1.png"></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个不超过14个节点的无向图，让你找到满足一下条件的一个子图：</p><ul><li>包含所有点</li><li>包含尽可能少的边</li><li>子图中任意两个点存在两条完全不交的路径</li></ul><p>让你输出一个任意符合题意的子图。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>当时没做出来，看题解才做出来的。建议先看原题解。如下：</p><p>  Let’s use dynamic programming to solve this problem. We will start with a single biconnected component consisting of vertex $0$, and connect other vertices to it. So, the state of our dynamic programming will be a $mask$ of vertices that are in the same biconnected component with $0$.</p><p>  How can we extend a biconnected component in such a way that some other vertices are added into it, but it is still biconnected? We will add a path (possibly cyclic) that starts in some vertex $x$ belonging to the $mask$, goes through some vertices not belonging to the $mask$, and ends in some vertex $y$ belonging to the $mask$ (possibly $x=y$). If for every triple ($x,y,addmask$) we precalculate some path that starts in $x$, goes through vertices from $addmask$ and ends in $y$ (and $addmask$ does not contain neither $x$ nor $y$), then we can solve the problem in $O(3^nn^2)$: there will be $2^n$ states, for every state we will iterate on two vertices $x$ and $y$ belonging to the $mask$, and the number of possible pairs of non-intersecting masks $mask$ and $addmask$ is $O(3^n)$.</p><p>  The only thing that’s left is precalculating the paths for triples ($x,y,addmask$). That can be done with auxiliary dynamic programming $dp2[x][y][addmask]$ which will denote whether such a path exists. For every edge ($u,v$) of the original graph, $dp2[u][v][0]$ is true, and we can go from $dp2[x][y][addmask]$ to some state $dp2[x][z][addmask^{‘}]$, where $addmask^{‘}$ will contain all vertices from $addmask$ and vertex $y$ (and we should ensure that there is an edge ($y,z$) in the graph and the $addmask$ didn’t contain vertex $y$ earlier). We should also somehow be able to restore the paths from this dp, and we also should be careful not to choose the same edge twice (for example, if we start a path by edge ($x,y$), we should not use the same edge to return to $x$) — both these things can be done, for example, by storing next-to-last vertex in the path.</p><p>我基本是看完题解才有想法的，和题解写的一模一样，（其实不一样，我写的比标程丑）。</p><p>大体思路还是很清晰的。</p><p>首先，我们可以很轻松的发现，答案一定是很多环交在了一起构成了答案对应的子图，然后对于任何一个存在很多环相交的图来说，我们可以拆成一个环和很多很多边构成的，如下图：</p><p><img src="/img/edu_cf_63_f_1.png" alt="edu_cf_63_f_1.png"></p><p>同样的我们可以很轻松的得到，任何一个环都可以作为拆分后唯一的环。剩下的问题就是我们怎么找到所有的边了。也即怎么找到我们需要的所有路径。我们做以下定义。</p><p>我们找到一条从$a$到$b$的路径，并且其中包括$mask$对应的其他点，我们假设$dp2[a][b][mask]$表示是否存在一条从$a$到$b$的路径，并且还包含了$mask$点，例如：</p><p>$dp2[1][3][1] = 1$表示存在一条$1-0-3$的路径</p><p>$dp2[3][5][3] = 1$表示存在一条从$3$到$5$的路径，其中包含$0$号点和$1$号点，路径可能是$3-0-1-5$，也可能是$3-1-0-5$。</p><p>对于他的转移显然比较好想，直接枚举下一个点是谁就行了。</p><p>然后我们取出任意一个节点表示当前符合答案的子图的子图。因为一个点的时候显然符合答案（因为一对都没有）。然后我们在这个子图的子图中不断的添加边构成环，最后判断得到的全图是否满足答案就行了。。。。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1</span>&lt;&lt;maxn;</span><br><span class="line"><span class="keyword">int</span> n,m,upper;</span><br><span class="line"><span class="keyword">int</span> dp[maxm|<span class="number">10</span>];<span class="comment">//记录答案是否存在，也即当前子图是否满足条件（子图中任意两个点存在两条完全不交的路径）</span></span><br><span class="line"><span class="keyword">bool</span> dp2[maxn][maxn][maxm];<span class="comment">//表示是否存在一条从i到j，包含mask对应点的路径</span></span><br><span class="line"><span class="keyword">int</span> last[maxn][maxn][maxm];<span class="comment">//用来记录i到j中上一个点是谁，用来输出路径</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit[maxm|<span class="number">10</span>];<span class="comment">//表示mask中对应的点的编号</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mat[maxm|<span class="number">10</span>];<span class="comment">//存输入的图</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; con[maxm|<span class="number">10</span>];<span class="comment">//表示mask对应的两个外部点，也就是路径的起点终点</span></span><br><span class="line"><span class="keyword">int</span> addmask[maxm|<span class="number">10</span>];<span class="comment">//mask对应的外部边对应的mask</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bit</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a) show_bit(a&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(a&amp;<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">upper = <span class="number">1</span>&lt;&lt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,a,b;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">a--,b--;</span><br><span class="line">mat[a].push_back(b);</span><br><span class="line">mat[b].push_back(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="built_in">memset</span>(dp2,<span class="literal">false</span>,<span class="keyword">sizeof</span> dp2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j: mat[i])&#123;</span><br><span class="line">dp2[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">last[i][j][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">0</span>;mask&lt;upper;mask++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++) <span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;j)) bit[mask].push_back(j);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">0</span>;mask&lt;upper;mask++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;i)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;j)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(i==j||dp2[i][j][mask]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> z:mat[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;z)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(z==last[i][j][mask]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dp2[i][z][mask|(<span class="number">1</span>&lt;&lt;j)]==<span class="literal">false</span>)&#123;</span><br><span class="line">last[i][z][mask|(<span class="number">1</span>&lt;&lt;j)] = j;</span><br><span class="line">dp2[i][z][mask|(<span class="number">1</span>&lt;&lt;j)] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">0</span>;mask &lt; upper;mask++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> add = mask;add;add = (add<span class="number">-1</span>)&amp;mask)&#123;</span><br><span class="line"><span class="keyword">int</span> pre = add^mask;</span><br><span class="line"><span class="keyword">int</span> cnt = __builtin_popcount(add)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[pre]+cnt&gt;=dp[mask]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:bit[pre])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> y: bit[pre])&#123;</span><br><span class="line"><span class="keyword">if</span>(dp2[x][y][add])&#123;</span><br><span class="line">dp[mask] = dp[pre]+cnt;</span><br><span class="line">con[mask] = make_pair(x,y);</span><br><span class="line">addmask[mask] = add;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]==inf) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> cur = (<span class="number">1</span>&lt;&lt;n) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> add = addmask[cur];</span><br><span class="line"><span class="keyword">int</span> x = con[cur].first;</span><br><span class="line"><span class="keyword">int</span> y = con[cur].second;</span><br><span class="line">cur^=add;</span><br><span class="line"><span class="keyword">while</span>(add)&#123;</span><br><span class="line"><span class="keyword">int</span> ny = last[x][y][add];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;y+<span class="number">1</span>&lt;&lt;<span class="string">' '</span>&lt;&lt;ny+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">y = ny;</span><br><span class="line">add^=(<span class="number">1</span>&lt;&lt;ny);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x+<span class="number">1</span>&lt;&lt;<span class="string">' '</span>&lt;&lt;y+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;F-Delivery-Oligopoly&quot;&gt;&lt;a href=&quot;#F-Delivery-Oligopoly&quot; class=&quot;headerlink&quot; title=&quot;F. Delivery Oligopoly&quot;&gt;&lt;/a&gt;F. Delivery Oligopoly&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1155/problem/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 553</title>
    <link href="http://zuhiul.github.io/2019/04/19/Codeforces_Round_553/"/>
    <id>http://zuhiul.github.io/2019/04/19/Codeforces_Round_553/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-19T10:51:16.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-Sonya-and-Informatics"><a href="#F-Sonya-and-Informatics" class="headerlink" title="F. Sonya and Informatics"></a>F. Sonya and Informatics</h2><p><a href="https://codeforces.com/contest/1151/problem/F" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>A girl named Sonya is studying in the scientific lyceum of the Kingdom of Kremland. The teacher of computer science (Sonya’s favorite subject!) invented a task for her.</p><p>Given an array $a$ of length $n$, <strong>consisting only of the numbers</strong> $0$ <strong>and</strong> $1$, and the number $k$. Exactly $k$ times the following happens:</p><ul><li>Two numbers $i$ and $j$ are chosen equiprobable such that ($1\leq i&lt;j\leq n$).</li><li>The numbers in the $i$ and $j$ positions are swapped.</li></ul><p>Sonya’s task is to find the probability that after all the operations are completed, the $a$ array will be <strong>sorted in non-decreasing order</strong>. She turned to you for help. Help Sonya solve this problem.</p><p>It can be shown that the desired probability is either $0$ or it can be represented as $\frac{P}{Q}$, where $P$ and $Q$ are coprime integers and $Q\not\equiv0(mod\ 10^9+7)\textscA$.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two integers $n$ and $k$ ($2\leq n\leq 100,1\leq k\leq 10^9$) — the length of the array $a$ and the number of operations.</p><p>The second line contains $n$ integers $a_1,a_2,\dots,a_n$ ($0\leq a_i\leq 1$) — the description of the array $a$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>If the desired probability is $0$, print $0$, otherwise print the value $P\cdot Q^{-1}$ ($mod\ 10^9+7$), where $P$ and $Q$ are defined above.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="inpus1"><a href="#inpus1" class="headerlink" title="inpus1"></a>inpus1</h4><p>3 2</p><p>0 1 0</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>333333336</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>5 1</p><p>1 1 1 0 0</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>0</p><h4 id="input3"><a href="#input3" class="headerlink" title="input3"></a>input3</h4><p>6 4</p><p>1 0 0 1 1 0</p><h4 id="output3"><a href="#output3" class="headerlink" title="output3"></a>output3</h4><p>968493834</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example, all possible variants of the final array $a$, after applying exactly two operations: $(0,1,0)$, $(0,0,1)$, $(1,0,0)$, $(1,0,0)$, $(0,1,0)$, $(0,0,1)$, $(0,0,1)$, $(1,0,0)$, $(0,1,0)$. Therefore, the answer is $\frac{3}{9}=\frac{1}{3}$.</p><p>In the second example, the array will not be sorted in non-decreasing order after one operation, therefore the answer is 0.</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个长度为n的01序列，每次随机从中选择两个出来，交换一下，一共这样操作k次，问你经过k次交换之后，序列变成不降($00\dots 0011\dots 11$)的概率是？</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先序列里面的$0$和$1$的数量是固定的，不妨设分别有$len_a$和$len_b$个。</p><p>也就是说在交换$k$次之后要保证前$len_a$个为$0$，后$len_b$个为$1$,如下<br>$$\underbrace{00\dots 00}_{len_a} \underbrace{11\dots 11}_{len_b}$$</p><p>然后我们分别统计前半段后半段$0$和$1$的数量，分别定义为$a_0,a_1,b_0,b_1$。例如<br>$$\underbrace{\underbrace{\overbrace{01010000101110100}^{a_1=7}}_{a_0=10}}_{len_a=17}\underbrace{\underbrace{\overbrace{000101111101010}^{b_1=8}}_{b_0=7}}_{len_b=15}\tag{3}$$</p><p>然后考虑一次交换产生的效果：</p><ul><li><p>$b_1$增加：$a_1$和$b_0$交换，使得后半段多了一个1，例如<br>$$\underbrace{\underbrace{\overbrace{01010000101110000}^{a_1=6}}_{a_0=11}}_{len_a=17}\underbrace{\underbrace{\overbrace{010101111101010}^{b_1=9}}_{b_0=6}}_{len_b=15}\tag{2}$$</p></li><li><p>$b_1$减少：$a_0$和$b_1$交换，使得后半段少了一个1，例如<br>$$\underbrace{\underbrace{\overbrace{01010000101110101}^{a_1=8}}_{a_0=9}}_{len_a=17}\underbrace{\underbrace{\overbrace{000101111101000}^{b_1=7}}_{b_0=8}}_{len_b=15}\tag{1}$$</p></li><li><p>其他情况不影响$0$和$1$的数量。</p></li></ul><p>然后多次操作和一次操作怎么联系起来呢？</p><p>看到这个数据量$n = 100$，一次变多次，一个自然的想法就是快速幂啊啊啊啊啊啊啊啊啊啊。</p><p>然后就用上面的式子构造转移矩阵，然后快速幂，就能得到有解的方案数，然后除掉总方案数就行了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> (a+b)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> a*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b = mod<span class="number">-2</span>)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = mul(ret,a);</span><br><span class="line">a = mul(a,a);</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">105</span>,inv_2 = qpow(<span class="number">2</span>);</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mul(inv_2,mul(a,add(a,mod<span class="number">-1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,k,len_a,len_b;</span><br><span class="line"><span class="keyword">int</span> num[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[maxm][maxm];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">matrix <span class="title">mul</span><span class="params">(matrix a,matrix b)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line">matrix c;</span><br><span class="line"><span class="built_in">memset</span>(c.num,<span class="number">0</span>,<span class="keyword">sizeof</span>(c.num));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=len_b;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=len_b;j++)</span><br><span class="line"><span class="keyword">if</span>(a.num[i][j])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;=len_b;k++) c.num[i][k] = add(c.num[i][k],mul(a.num[i][j],b.num[j][k]));</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="function">matrix <span class="title">qpow</span><span class="params">(matrix a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">matrix e;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=len_b;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=len_b;j++) e.num[i][j]=(i==j);</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) e = mul(e,a);</span><br><span class="line">a = mul(a,a);</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">int</span> all = C(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,num+i);</span><br><span class="line"><span class="keyword">if</span>(num[i]) len_b++;</span><br><span class="line"><span class="keyword">else</span> len_a++;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line">matrix base;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=len_b;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = max(<span class="number">0</span>,i<span class="number">-1</span>);j&lt;=min(len_b,i+<span class="number">1</span>);j++)&#123;</span><br><span class="line"><span class="keyword">int</span> b1 = j,b0 = len_b - j,a0 = len_a - b0,a1 = len_a - a0;</span><br><span class="line"><span class="keyword">if</span>(i==j<span class="number">-1</span>) base.num[i][j] = a0*b1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==j+<span class="number">1</span>) base.num[i][j] = a1*b0;</span><br><span class="line"><span class="keyword">else</span> base.num[i][j] = add(all,add(mod - a0*b1,mod - a1*b0));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len_a;i&lt;n;i++) <span class="keyword">if</span>(num[i]) cnt++;</span><br><span class="line">matrix ano;</span><br><span class="line"><span class="built_in">memset</span>(ano.num,<span class="number">0</span>,<span class="keyword">sizeof</span>(ano.num));</span><br><span class="line">ano.num[cnt][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">base = mul(qpow(base,k),ano);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = base.num[len_b][<span class="number">0</span>];</span><br><span class="line">ans = mul(ans,qpow(qpow(C(n),k)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;F-Sonya-and-Informatics&quot;&gt;&lt;a href=&quot;#F-Sonya-and-Informatics&quot; class=&quot;headerlink&quot; title=&quot;F. Sonya and Informatics&quot;&gt;&lt;/a&gt;F. Sonya and Informatics&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1151/problem/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 552</title>
    <link href="http://zuhiul.github.io/2019/04/17/Codeforces_Round_552/"/>
    <id>http://zuhiul.github.io/2019/04/17/Codeforces_Round_552/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-18T04:17:26.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-Shovels-Shop"><a href="#F-Shovels-Shop" class="headerlink" title="F. Shovels Shop"></a>F. Shovels Shop</h2><p><a href="http://codeforces.com/contest/1154/problem/F" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>There are $n$ shovels in the nearby shop. The $i$-th shovel costs $a_i$ bourles.</p><p>Misha has to buy <strong>exactly $k$</strong> shovels. Each shovel can be bought <strong>no more than once</strong>.</p><p>Misha can buy shovels by several purchases. During one purchase he can choose any subset of remaining (non-bought) shovels and buy this subset.</p><p>There are also $m$ special offers in the shop. The $j$-th of them is given as a pair $(x_j,y_j)$, and it means that if Misha buys <strong>exactly</strong> $x_j$ shovels <strong>during one purchase</strong> then $y_j$ <strong>most cheapest</strong> of them are for free (i.e. he will not pay for $y_j$ most cheapest shovels during the current purchase).</p><p>Misha can use any offer any (possibly, zero) number of times, but he cannot use <strong>more than one</strong> offer during <strong>one purchase</strong> (but he can buy shovels without using any offers).</p><p>Your task is to calculate the minimum cost of buying $k$ shovels, if Misha buys them optimally.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains three integers $n,m$ and $k$ ($1\leq n,m\leq 2\cdot 10^5,1\leq k\leq min(n,2000)$) - the number of shovels in the shop, the number of special offers and the number of shovels Misha has to buy, correspondingly.</p><p>The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_1\leq 2\cdot 10^5$), where $a_i$ is the cost of the $i$-th shovel.</p><p>The next $m$ lines contain special offers. The $j$-th of them is given as a pair of integers ($x_i,y_i$) ($1\leq y_i\leq x_i\leq n$) and means that if Misha buys exactly $x_i$ shovels during some purchase, then he can take $y_i$ most cheapest of them for free.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print one integer $-$ the minimum cost of buying $k$ shovels if Misha buys them optimally.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="inpus1"><a href="#inpus1" class="headerlink" title="inpus1"></a>inpus1</h4><p>7 4 5</p><p>2 5 4 2 6 3 1</p><p>2 1</p><p>6 5</p><p>2 1</p><p>3 1</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>7</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>9 4 8</p><p>6 8 5 1 8 1 1 2 1</p><p>9 2</p><p>8 4</p><p>5 3</p><p>9 7</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>17</p><h4 id="input3"><a href="#input3" class="headerlink" title="input3"></a>input3</h4><p>5 1 4</p><p>2 5 7 4 6</p><p>5 4</p><h4 id="output3"><a href="#output3" class="headerlink" title="output3"></a>output3</h4><p>17</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example Misha can buy shovels on positions 1 and 4 (both with costs 2) during the first purchase and get one of them for free using the first or the third special offer. And then he can buy shovels on positions 3 and 6 (with costs 4 and 3) during the second purchase and get the second one for free using the first or the third special offer. Then he can buy the shovel on a position 7 with cost 1. So the total cost is 4+2+1=7.</p><p>In the second example Misha can buy shovels on positions 1, 2, 3, 4 and 8 (costs are 6, 8, 5, 1 and 2) and get three cheapest (with costs 5, 1 and 2) for free. And then he can buy shovels on positions 6, 7 and 9 (all with costs 1) without using any special offers. So the total cost is 6+8+1+1+1=17.</p><p>In the third example Misha can buy four cheapest shovels without using any special offers and get the total cost 17.</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>zuhiul 都20了，还没有对象，然后家里人给安排了n个菇凉和他相亲，他需要挑出k个来相亲。相亲当然是男方请客，和每个妹子相亲的成本是不一样的，每个妹子都有一个固定成本，为了促进zuhiul相亲，家里人说，如果一次邀约了$x_i$个菇凉，家里就给报销这次相亲的所有菇凉中，成本最低的$y_i$个菇凉的花费，现在zuhiul想花最少的钱相完所有的亲，他最少要花多少钱呢？</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先可以确定的是，我们一定找n个中最便宜的k个来相亲，因为如果不是这k个，我们一定可以合理的交换，得到一个不劣的解。</p><p>然后排序，干掉贵的那一部分。</p><p>那么如果不考虑报销的话，成本是固定的，所以剩下的问题就是怎么得到尽可能多的报销。</p><p>然后，显然是一个$n^2$的dp了。</p><p>我们可以预处理出，如果一次约j个女孩的话，可以省掉多少个女孩的费用，设为sub[j]</p><p>假设每个女孩的费用为values[i]</p><p>考虑转移，设dp[i]表示邀约前n个妹子的最小花费，那么可以得到$$dp[i] = \min_{j=1}^{i} (dp[i-j] + \sum_{k=i-j+sub[j]+1}^{i} values[k])$$</p><p>然后对于后面的求和，可以搞一个前缀和来维护，复杂度$O(n^2)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sub[maxk];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> values[maxm];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxm];</span><br><span class="line"><span class="keyword">int</span> ans[maxk];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cost[maxk];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,values+i);</span><br><span class="line">sort(values+<span class="number">1</span>,values+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i<span class="number">-1</span>]+values[i];</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(a&gt;k) <span class="keyword">continue</span>;</span><br><span class="line">sub[a] = max(sub[a],b);</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=k;i++) sub[i] = max(sub[i],sub[i<span class="number">-1</span>]);</span><br><span class="line"><span class="built_in">memset</span>(cost,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(cost));</span><br><span class="line">cost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">cost[i] = sum[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">cost[i] = min(cost[i],cost[i-j]+sum[i]-sum[i-j+sub[j]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,cost[k]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Minimum-Possible-LCM"><a href="#G-Minimum-Possible-LCM" class="headerlink" title="G. Minimum Possible LCM"></a>G. Minimum Possible LCM</h2><p><a href="http://codeforces.com/contest/1154/problem/G" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given an array $a$ consisting of $n$ integers $a_1,a_2,\dots,a_n$.</p><p>Your problem is to find such pair of indices $i,j (1\leq i&lt;j\leq n)$ that $lcm(a_i,a_j)$ is minimum possible.</p><p>$lcm(x,y)$ is the least common multiple of $x$ and $y$ (minimum positive number such that both $x$ and $y$ are divisors of this number).</p><p>###Input</p><p>The first line of the input contains one integer $n$ ($2\leq n\leq10^6$) — the number of elements in $a$.</p><p>The second line of the input contains $n$ integers $a_1,a_2,\dots,a_n$ ($1\leq a_i\leq 10^7$), where $a_i$ is the $i$-th element of $a$.</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>Print two integers $i$ and $j$ ($1\leq i&lt;j\leq n$) such that the value of $lcm(a_i,a_j)$ is minimum among all valid pairs $i,j$. If there are multiple answers, you can print any.</p><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><h4 id="inpus1-1"><a href="#inpus1-1" class="headerlink" title="inpus1"></a>inpus1</h4><p>5</p><p>2 4 8 3 6</p><h4 id="output1-1"><a href="#output1-1" class="headerlink" title="output1"></a>output1</h4><p>1 2</p><h4 id="input2-1"><a href="#input2-1" class="headerlink" title="input2"></a>input2</h4><p>5</p><p>5 2 11 3 7</p><h4 id="output2-1"><a href="#output2-1" class="headerlink" title="output2"></a>output2</h4><p>2 4</p><h4 id="input3-1"><a href="#input3-1" class="headerlink" title="input3"></a>input3</h4><p>6</p><p>2 5 10 1 10 2 </p><h4 id="output3-1"><a href="#output3-1" class="headerlink" title="output3"></a>output3</h4><p>1 4</p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>zuhiul有很多妹子，今天他想找两个妹子出去吃饭，每个妹子都有一个权值，他今天要花的钱等于这两个妹子权值的lcm，他想花尽可能少的钱，他该约哪两个妹子呢？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>我们考虑一下那种情况可以构成解。</p><p>首先对于重复的数据，我们可以干掉，因为相同值的lcm等于本身，所以我们可以把相同的权值干掉，然后剩下的数据都是不同的。</p><p>然后我们考虑权值都不相同的时候怎么构成解。</p><p>首先，这两个数肯定有一个gcd，哪怕gcd = 1，然后我们考虑一下，这$n*(n-1)&gt;&gt;1$这么多对数中，哪些对可以构成解，一个显而易见的想法就是，我们可以枚举gcd。</p><p>然后我们枚举这个gcd的所有倍数，这样能不重不漏的枚举出所有对数，然后我们考虑怎么减少枚举量。假设当前的$gcd=x$,因为前一步保证了没有相同的数据，所以我们只要找到最小的$i,j$使得$i\%x==0\&amp;\&amp;j\%x==0$，然后就用这两个数更新一下答案就行了。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> app[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">int</span> ind1,ind2;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> p a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ans&lt;a.ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">p ans = &#123;<span class="number">1000000000000000000l</span>l,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,buf;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;buf);</span><br><span class="line"><span class="keyword">if</span>(app[buf]) ans = min(ans,&#123;buf,app[buf],i&#125;);</span><br><span class="line">app[buf] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;maxm;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;maxm;j+=i)&#123;</span><br><span class="line"><span class="keyword">if</span>(app[j])&#123;</span><br><span class="line">buf[++buf[<span class="number">0</span>]] = j;</span><br><span class="line"><span class="keyword">if</span>(buf[<span class="number">0</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">ans = min(ans,&#123;<span class="number">1l</span>l*buf[<span class="number">1</span>]*buf[<span class="number">2</span>]/i,app[buf[<span class="number">1</span>]],app[buf[<span class="number">2</span>]]&#125;);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans.ind1&gt;ans.ind2) swap(ans.ind1,ans.ind2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans.ind1,ans.ind2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;F-Shovels-Shop&quot;&gt;&lt;a href=&quot;#F-Shovels-Shop&quot; class=&quot;headerlink&quot; title=&quot;F. Shovels Shop&quot;&gt;&lt;/a&gt;F. Shovels Shop&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1154/problem/F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 551</title>
    <link href="http://zuhiul.github.io/2019/04/14/Codeforces_Round_551/"/>
    <id>http://zuhiul.github.io/2019/04/14/Codeforces_Round_551/</id>
    <published>2019-04-13T16:00:00.000Z</published>
    <updated>2019-04-18T11:28:35.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-Serval-and-Bus"><a href="#A-Serval-and-Bus" class="headerlink" title="A. Serval and Bus"></a>A. Serval and Bus</h2><p><a href="http://codeforces.com/contest/1153/problem/A" target="_blank" rel="noopener">开启传送门</a></p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>It is raining heavily. But this is the first day for Serval, who just became 3 years old, to go to the kindergarten. Unfortunately, he lives far from kindergarten, and his father is too busy to drive him there. The only choice for this poor little boy is to wait for a bus on this rainy day. Under such circumstances, the poor boy will use the first bus he sees no matter where it goes. If several buses come at the same time, he will choose one randomly.</p><p>Serval will go to the bus station at time $t$, and there are $n$ bus routes which stop at this station. For the $i$-th bus route, the first bus arrives at time $s_i$ minutes, and each bus of this route comes $d_i$ minutes later than the previous one.</p><p>As Serval’s best friend, you wonder which bus route will he get on. If several buses arrive at the same time, you can print any of them.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station.</p><p>Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1"><a href="#input1" class="headerlink" title="input1"></a>input1</h4><p>2 2</p><p>6 4</p><p>9 5</p><h4 id="output1"><a href="#output1" class="headerlink" title="output1"></a>output1</h4><p>1</p><h4 id="input2"><a href="#input2" class="headerlink" title="input2"></a>input2</h4><p>5 5</p><p>3 3</p><p>2 5</p><p>5 6</p><p>4 9</p><p>6 1</p><h4 id="output2"><a href="#output2" class="headerlink" title="output2"></a>output2</h4><p>3</p><h4 id="input3"><a href="#input3" class="headerlink" title="input3"></a>input3</h4><p>3 7</p><p>2 2</p><p>2 3</p><p>2 4</p><h4 id="output3"><a href="#output3" class="headerlink" title="output3"></a>output3</h4><p>1</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>zuhiul很忙，他要约妹子，他一共有$n$个妹子要约，但是他$t$天后才有空，妹子们也不是每天都有时间，但是妹子都是周期性有时间，比如，第$i$个妹子，$s_i$天之后才有时间，而且每$d_i$天就会再次出线，现在问你，zuhiul最早会和哪个妹子约会，如果会和多个妹子约会，只需要输出任意一个妹子就行了。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>只需要枚举每个妹子，然后看一下这个妹子什么时候最早可以邀约，然后算一下min就可以了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> s[maxm],d[maxm];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;t;</span><br><span class="line"><span class="keyword">int</span> ind,sum = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s[i]&gt;&gt;d[i];</span><br><span class="line"><span class="keyword">if</span>(s[i]&gt;=t)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;s[i])&#123;</span><br><span class="line">sum = s[i];</span><br><span class="line">ind = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> nee = t-s[i];</span><br><span class="line"><span class="keyword">if</span>(nee%d[i]!=<span class="number">0</span>) nee = (nee/d[i]+<span class="number">1</span>)*d[i];</span><br><span class="line">nee+=s[i];</span><br><span class="line"><span class="keyword">if</span>(nee&lt;sum)&#123;</span><br><span class="line">sum = nee;</span><br><span class="line">ind = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ind&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Serval-and-Toy-Bricks"><a href="#B-Serval-and-Toy-Bricks" class="headerlink" title="B. Serval and Toy Bricks"></a>B. Serval and Toy Bricks</h2><p><a href="http://codeforces.com/contest/1153/problem/B" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>Luckily, Serval got onto the right bus, and he came to the kindergarten on time. After coming to kindergarten, he found the toy bricks very funny.</p><p>He has a special interest to create difficult problems for others to solve. This time, with many $1\times 1\times 1$ toy bricks, he builds up a 3-dimensional object. We can describe this object with a $n\times m$ matrix, such that in each cell $(i,j)$ , there are $h_{i,j}$ bricks standing on the top of each other.</p><p>However, Serval doesn’t give you any $h_{i,j}$, and just give you the front view, left view, and the top view of this object, and he is now asking you to restore the object. Note that in the front view, there are $m$ columns, and in the $i$-th of them, the height is the maximum of $h_{1,i},h_{2,i},\dots,h_{n,i}$. It is similar for the left view, where there are $n$ columns. And in the top view, there is an 𝑛×𝑚 matrix $t_{i,j}$, where $t_{i,j}$ is 0 or 1. If $t_{i,j}$ equals 1, that means $h_{i,j}$&gt;0, otherwise, $h_{i,j}$=0.</p><p>However, Serval is very lonely because others are bored about his unsolvable problems before, and refused to solve this one, although this time he promises there will be at least one object satisfying all the views. As his best friend, can you have a try?</p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two space-separated integers $n$ and $t$ (1≤$n$≤100, 1≤$t$≤$10^5$) $-$ the number of bus routes and the time Serval goes to the station.</p><p>Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ (1≤$s_i,d_i$≤$10^5$) $-$ the time when the first bus of this route arrives and the interval between two buses of this route.</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>Print one number $-$ what bus route Serval will use. If there are several possible answers, you can print any of them.</p><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1-1"><a href="#input1-1" class="headerlink" title="input1"></a>input1</h4><p>3 7 3</p><p>2 3 0 0 2 0 1</p><p>2 1 3</p><p>1 0 0 0 1 0 0</p><p>0 0 0 0 0 0 1</p><p>1 1 0 0 0 0 0</p><h4 id="output1-1"><a href="#output1-1" class="headerlink" title="output1"></a>output1</h4><p>1 0 0 0 2 0 0</p><p>0 0 0 0 0 0 1</p><p>2 3 0 0 0 0 0</p><h4 id="input2-1"><a href="#input2-1" class="headerlink" title="input2"></a>input2</h4><p>4 5 5</p><p>3 5 2 0 4</p><p>4 2 5 4</p><p>0 0 0 0 1</p><p>1 0 1 0 0</p><p>0 1 0 0 0</p><p>1 1 1 0 0</p><h4 id="output2-1"><a href="#output2-1" class="headerlink" title="output2"></a>output2</h4><p>0 0 0 0 4</p><p>1 0 2 0 0</p><p>0 5 0 0 0</p><p>3 4 1 0 0</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p><img src="/img/cf_1153_b_1.png" alt=""></p><p>The graph above illustrates the object in the first example.</p><p><img src="/img/cf_1153_b_2.png" alt=""></p><p>The first graph illustrates the object in the example output for the second example, and the second graph shows the three-view drawing of it.</p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>zuhiul和妹子玩游戏，妹子搭了一个积木，然后zuhiul猜积木长啥样，zuhiul必然不会，于是小姐姐放过了他，告诉了他现在的主视图，侧视图和俯视图，然后让zuhiul猜，zuhiul还是不会，但是为了脸面不能说不会，然后来问你了。你需要输出一种可能的解满足这个三视图。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>告诉了主视图和左视图，相当于限制了最大值，告诉俯视图相当于告诉哪里可能有方块。然后枚举俯视图的每个位置，输出答案即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> hang[maxm],lie[maxm],nouse;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;nouse;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++) <span class="built_in">cin</span>&gt;&gt;hang[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;lie[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>,a;j&lt;m;j++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"><span class="keyword">if</span>(a) <span class="built_in">cout</span>&lt;&lt;min(lie[i],hang[j])&lt;&lt;<span class="string">' '</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Serval-and-Parenthesis-Sequence"><a href="#C-Serval-and-Parenthesis-Sequence" class="headerlink" title="C. Serval and Parenthesis Sequence"></a>C. Serval and Parenthesis Sequence</h2><p><a href="http://codeforces.com/contest/1153/problem/C" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>Serval soon said goodbye to Japari kindergarten, and began his life in Japari Primary School.</p><p>In his favorite math class, the teacher taught him the following interesting definitions.</p><p>A parenthesis sequence is a string, containing only characters “(“ and “)”.</p><p>A correct parenthesis sequence is a parenthesis sequence that can be transformed into a correct arithmetic expression by inserting characters “1” and “+” between the original characters of the sequence. For example, parenthesis sequences “()()”, “(())” are correct (the resulting expressions are: “(1+1)+(1+1)”, “((1+1)+1)”), while “)(“ and “)” are not. Note that the empty string is a correct parenthesis sequence by definition.</p><p>We define that $|s|$ as the length of string $s$. A strict prefix $s[1\dots l]$ (1 ≤ $l$ &lt; $|s|$) of a string $s=s_{1}s_{2}\dots s_{|s|}$ is string $s_{1}s_{2}\dots s_{l}$. Note that the empty string and the whole string are not strict prefixes of any string by the definition.</p><p>Having learned these definitions, he comes up with a new problem. He writes down a string $s$ containing only characters “(“, “)” and “?”. And what he is going to do, is to replace each of the “?” in $s$ independently by one of “(“ and “)” to make all strict prefixes of the new sequence not a correct parenthesis sequence, while the new sequence should be a correct parenthesis sequence.</p><p>After all, he is just a primary school student so this problem is too hard for him to solve. As his best friend, can you help him to replace the question marks? If there are many solutions, any of them is acceptable.</p><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>The first line contains a single integer $|s|$ (1≤$|s|$≤$3\cdot 10^5$), the length of the string.</p><p>The second line contains a string $s$, containing only “(“, “)” and “?”.</p><h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>A single line contains a string representing the answer.</p><p>If there are many solutions, any of them is acceptable.</p><p>If there is no answer, print a single line containing “:(“ (without the quotes).</p><h3 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1-2"><a href="#input1-2" class="headerlink" title="input1"></a>input1</h4><p>6<br>(?????</p><h4 id="output1-2"><a href="#output1-2" class="headerlink" title="output1"></a>output1</h4><p>(()())</p><h4 id="input2-2"><a href="#input2-2" class="headerlink" title="input2"></a>input2</h4><p>10<br>(???(???(?</p><h4 id="output2-2"><a href="#output2-2" class="headerlink" title="output2"></a>output2</h4><p>:(</p><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>It can be proved that there is no solution for the second sample, so print “:(“.</p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给你一堆左括号右括号和问号，问你能否把问号变成左括号或者右括号，使得这个变成一个括号匹配的序列，并且序列的任何前缀不是一个括号匹配序列。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>显然对于后一个条件，我们只需要让最左边的左括号和最右边的右括号匹配就行了，然后中间是一个括号匹配序列就行了。然后填充的时候贪心的让左边填充左括号,右边填充右括号,然后check一下就行了.</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> que[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NO</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">":("</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;len&gt;&gt;que;</span><br><span class="line"><span class="keyword">if</span>(len&amp;<span class="number">1</span>) NO();</span><br><span class="line"><span class="keyword">if</span>(que[<span class="number">0</span>]==<span class="string">'?'</span>) que[<span class="number">0</span>] = <span class="string">'('</span>;</span><br><span class="line"><span class="keyword">if</span>(que[len<span class="number">-1</span>]==<span class="string">'?'</span>) que[len<span class="number">-1</span>] = <span class="string">')'</span>;</span><br><span class="line"><span class="keyword">if</span>(que[<span class="number">0</span>]!=<span class="string">'('</span>) NO();</span><br><span class="line"><span class="keyword">if</span>(que[len<span class="number">-1</span>]!=<span class="string">')'</span>) NO();</span><br><span class="line"><span class="keyword">if</span>(len==<span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"()"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>,has = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(que[i]==<span class="string">'('</span>) l++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(que[i]==<span class="string">')'</span>) r++;</span><br><span class="line"><span class="keyword">else</span> has++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(l-r)&gt;has) NO();</span><br><span class="line">l = (len<span class="number">-2</span>)/<span class="number">2</span> - l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(que[i]==<span class="string">'?'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(l)&#123;</span><br><span class="line">que[i] = <span class="string">'('</span>;</span><br><span class="line">l--;</span><br><span class="line">&#125;<span class="keyword">else</span> que[i] = <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">has = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(que[i]==<span class="string">'('</span>) has++;</span><br><span class="line"><span class="keyword">else</span> has--;</span><br><span class="line"><span class="keyword">if</span>(has&lt;<span class="number">0</span>) NO();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(que);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Serval-and-Rooted-Tree"><a href="#D-Serval-and-Rooted-Tree" class="headerlink" title="D. Serval and Rooted Tree"></a>D. Serval and Rooted Tree</h2><p><a href="http://codeforces.com/contest/1153/problem/D" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>Now Serval is a junior high school student in Japari Middle School, and he is still thrilled on math as before.</p><p>As a talented boy in mathematics, he likes to play with numbers. This time, he wants to play with numbers on a rooted tree.</p><p>A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a node $v$ is the last different from $v$ vertex on the path from the root to the vertex $v$. Children of vertex $v$ are all nodes for which $v$ is the parent. A vertex is a leaf if it has no children.</p><p>The rooted tree Serval owns has $n$ nodes, node 1 is the root. Serval will write some numbers into all nodes of the tree. However, there are some restrictions. Each of the nodes except leaves has an operation max or min written in it, indicating that the number in this node should be equal to the maximum or minimum of all the numbers in its sons, respectively.</p><p>Assume that there are $k$ leaves in the tree. Serval wants to put integers $1,2,\dots,k$ to the $k$ leaves (each number should be used exactly once). He loves large numbers, so he wants to maximize the number in the root. As his best friend, can you help him?</p><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer $n$ (2≤$n$≤$3\cdot 10^5$), the size of the tree.</p><p>The second line contains $n$ integers, the $i$-th of them represents the operation in the node $i$. 0 represents min and 1 represents max. If the node is a leaf, there is still a number of 0 or 1, but you can ignore it.</p><p>The third line contains $n-1$ integers $f_2,f_3,\dots,f_n$ (1≤$f_i≤$i-1$), where $f_i$ represents the parent of the node $i$.</p><h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>Output one integer $-$ the maximum possible number in the root of the tree.</p><h3 id="Examples-3"><a href="#Examples-3" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1-3"><a href="#input1-3" class="headerlink" title="input1"></a>input1</h4><p>6</p><p>1 0 1 1 0 1</p><p>1 2 2 2 2</p><h4 id="output1-3"><a href="#output1-3" class="headerlink" title="output1"></a>output1</h4><p>1</p><h4 id="input2-3"><a href="#input2-3" class="headerlink" title="input2"></a>input2</h4><p>5</p><p>1 0 1 0 1</p><p>1 1 1 1</p><h4 id="output2-3"><a href="#output2-3" class="headerlink" title="output2"></a>output2</h4><p>4</p><h4 id="input3-1"><a href="#input3-1" class="headerlink" title="input3"></a>input3</h4><p>8</p><p>1 0 0 1 0 1 1 0</p><p>1 1 2 2 3 3 3</p><h4 id="output3-1"><a href="#output3-1" class="headerlink" title="output3"></a>output3</h4><p>4</p><h4 id="input4"><a href="#input4" class="headerlink" title="input4"></a>input4</h4><p>9</p><p>1 1 0 0 1 0 1 0 1</p><p>1 1 2 2 3 3 4 4</p><h4 id="output4"><a href="#output4" class="headerlink" title="output4"></a>output4</h4><p>5</p><h3 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h3><p>Pictures below explain the examples. The numbers written in the middle of the nodes are their indices, and the numbers written on the top are the numbers written in the nodes.</p><p>In the first example, no matter how you arrange the numbers, the answer is $1$.</p><p><img src="/img/cf_1153_d_1.png" alt=""></p><p>In the second example, no matter how you arrange the numbers, the answer is $4$.</p><p><img src="/img/cf_1153_d_2.png" alt=""></p><p>In the third example, one of the best solution to achieve $4$ is to arrange $4$ and $5$ to nodes $4$ and $5$.</p><p><img src="/img/cf_1153_d_3.png" alt=""></p><p>In the fourth example, the best solution is to arrange $5$ to node $5$.</p><p><img src="/img/cf_1153_d_4.png" alt=""></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给你一颗有根树，每个非叶节点上有一个函数，可能为min或者max，你需要在k个叶节点上填上$1,2,\dots,k$,使得经过非叶节点的操作之后，根节点的值最大。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>显然是要分析函数的作用。</p><p>如果是取max，说明所有的子节点中，我们可以把某一个子节点的值取到最大，然后其他的节点全塞垃圾值。</p><p>如果是取min，说明所有子节点都起作用，说明我们对于每个子节点都要尽可能的大。</p><p>然后就可以得到，max的策略是，找到孙子节点最少的子节点，填充大值，min的策略是，对所有子节点求和。</p><p>然后这样得到的就是所有对答案有贡献的节点数，然后用总结点数减去贡献节点数就是答案。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line"><span class="keyword">int</span> maxn[maxm];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[maxm];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(son[a].size()==<span class="number">0</span>)&#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxn[a])&#123;</span><br><span class="line"><span class="keyword">int</span> minm = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:son[a]) minm = min(minm,dfs(i));</span><br><span class="line"><span class="keyword">return</span> minm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:son[a]) sum+=dfs(i);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;maxn[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,pre;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;pre;</span><br><span class="line">son[pre].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nouse = dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;cnt - nouse+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Serval-and-Snake"><a href="#E-Serval-and-Snake" class="headerlink" title="E. Serval and Snake"></a>E. Serval and Snake</h2><p><a href="http://codeforces.com/contest/1153/problem/E" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p><em>This is an interactive problem.</em></p><p>Now Serval is a senior high school student in Japari Middle School. However, on the way to the school, he must go across a pond, in which there is a dangerous snake. The pond can be represented as a $n\times n$ grid. The snake has a head and a tail in different cells, and its body is a series of adjacent cells connecting the head and the tail without self-intersecting. If Serval hits its head or tail, the snake will bite him and he will die.</p><p>Luckily, he has a special device which can answer the following question: you can pick a rectangle, it will tell you the number of times one needs to cross the border of the rectangle walking cell by cell along the snake from the head to the tail. The pictures below show a possible snake and a possible query to it, which will get an answer of $4$.</p><p><img src="/img/cf_1153_e_1.png" alt=""><br><img src="/img/cf_1153_e_2.png" alt=""></p><p>Today Serval got up too late and only have time to make 2019 queries. As his best friend, can you help him find the positions of the head and the tail?</p><p>Note that two cells are adjacent if and only if they have a common edge in the grid, and a snake can have a body of length 0, that means it only has adjacent head and tail.</p><p>Also note that the snake is sleeping, so it won’t move while Serval using his device. And what’s obvious is that the snake position does not depend on your queries.</p><h3 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h3><p>The first line contains a single integer $n$ (2≤$n$≤1000) $-$ the size of the grid.</p><h3 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h3><p>When you are ready to answer, you should print <strong>! x1 y1 x2 y2</strong>, where $(x_1,y_1)$ represents the position of the head and $(x_2,y_2)$ represents the position of the tail. You can print head and tail in any order.</p><h3 id="Interaction"><a href="#Interaction" class="headerlink" title="Interaction"></a>Interaction</h3><p>To make a query, you should print <strong>? x1 y1 x2 y2</strong> (1≤$x_1$≤$x_2$≤𝑛, 1≤$y_1$≤$y_2$≤$n$), representing a rectangle consisting of all cells $(x,y)$ such that $x_1$≤$x$≤$x_2$ and $y_1$≤$y$≤$y_2$. You will get a single integer as the answer.</p><p>After printing a query, do not forget to output the end of line and flush the output, otherwise you will get <strong>Idleness limit exceeded</strong>. To do this, use:</p><ul><li><strong>fflush(stdout)</strong> or <strong>cout.flush()</strong> in C++;</li><li><strong>System.out.flush()</strong> in Java;</li><li><strong>flush(output)</strong> in Pascal;</li><li><strong>stdout.flush()</strong> in Python;<br>see documentation for other languages.</li></ul><p>Answer $-1$ instead of a valid answer means that you made an invalid query or exceeded the maximum number of queries. Exit immediately after receiving $-1$ and you will see <strong>Wrong answer</strong> verdict. Otherwise you can get an arbitrary verdict because your solution will continue to read from a closed stream.</p><p>If your program cannot find out the head and tail of the snake correctly, you will also get a <strong>Wrong Answer</strong> verdict.</p><h3 id="Hacks"><a href="#Hacks" class="headerlink" title="Hacks"></a>Hacks</h3><p>To make a hack, print a single integer $n$ (2≤$n$≤1000) in the first line, indicating the size of the grid.</p><p>Then print an integer $k$ (2≤$k$≤𝑛2) in the second line, indicating the length of the snake.</p><p>In the next $k$ lines, print $k$ pairs of integers $x_i,y_i$ (1≤$x_i,y_i$≤𝑛), each pair in a single line, indicating the $i$-th cell of snake, such that the adjacent pairs are adjacent, and all $k$ pairs are distinct.</p><h3 id="Examples-4"><a href="#Examples-4" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input1-4"><a href="#input1-4" class="headerlink" title="input1"></a>input1</h4><p>2</p><p>1</p><p>0</p><p>0</p><h4 id="output1-4"><a href="#output1-4" class="headerlink" title="output1"></a>output1</h4><p>? 1 1 1 1</p><p>? 1 2 1 2</p><p>? 2 2 2 2</p><p>! 1 1 2 1</p><h4 id="input2-4"><a href="#input2-4" class="headerlink" title="input2"></a>input2</h4><p>3</p><p>2</p><p>0</p><h4 id="output2-4"><a href="#output2-4" class="headerlink" title="output2"></a>output2</h4><p>? 2 2 2 2</p><p>? 2 1 2 3</p><p>! 2 1 2 3</p><h3 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h3><p><img src="/img/cf_1153_e_3.png" alt=""><br><img src="/img/cf_1153_e_4.png" alt=""><br><img src="/img/cf_1153_e_5.png" alt=""><br><img src="/img/cf_1153_e_6.png" alt=""></p><p>The pictures above show our queries and the answers in the first example. We first made a query for (1,1) and got an answer 1, then found that it must be connected to exactly one other cell. Then we made a query for (1,2) and got an answer of 0, then knew that the snake never entered it. So the cell connected to (1,1) must be (2,1). Then we made a query for (2,2) and got an answer 0, then knew that it never entered (2,2) as well. So the snake cannot leave (2,1), which implies that the answer is (1,1) and (2,1).</p><p><img src="/img/cf_1153_e_7.png" alt=""><br><img src="/img/cf_1153_e_8.png" alt=""><br><img src="/img/cf_1153_e_9.png" alt=""></p><p>The pictures above show our queries and the answers in the second example. By making query to (2,2) and receiving 2, we found that the snake occupies (2,2). And by making query to rectangle from (2,1) to (2,3) and receiving answer 0, we knew that it never goes out of the rectangle from (2,1) to (2,3). Since the first answer is 2, both (2,1) and (2,3) must be occupied but none of others, so the answer is (2,1) and (2,3).</p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>现在有一条蛇在一个方格图中，你可以给出不超过2019次询问，每次询问一个矩形，回答是，你用这个矩形去切蛇，可以得到这个蛇被切了多少刀，现在问你蛇头和蛇尾的位置。</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>首先我们可以观察到，当一个矩形切下去之后发现切了奇数刀，那么可以有必然存在一个头或者尾在矩形中。</p><p>然后我们可以用$(n-1)&lt;&lt;1$次询问得到所有的行和列对应的切的次数。</p><p>然后可以证明的是，所有的数据中必然存在奇数。反证法易得。</p><p>然后可以证明奇数对应的行或者列左右必然存在头或者尾。</p><p>所以可以得到一个很直观的$O(6n)$的做法，$2n$用来寻找，剩下的$4n$来搜索答案。但是这必然会超过2019.</p><p>考虑哪些步骤可以优化？</p><p>$2n$不可优化，必然就只能优化搜索过程。</p><p>需要注意的是，可能存在行或者列不存在奇数的情况，稍微分析可以得到这种情况的特点了，头和尾在同一行或者同一列中。</p><p>我们考虑到，我们只用考虑奇偶的情况，而不用考虑具体值。</p><p>因为奇偶的加减特性，我们可以二分这个答案。</p><p>除此之外，如果行和列都有奇数值，那么可以得到行和列对应的四个点中，两个点是答案，枚举任何一个就可以得到答案。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r,c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"? %d %d %d %d\n"</span>,u,l,d,r);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> nouse;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nouse);</span><br><span class="line"><span class="keyword">return</span> nouse&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(que(i,i,<span class="number">1</span>,n)) r.push_back(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(que(<span class="number">1</span>,n,i,i)) c.push_back(i);</span><br><span class="line">assert(r.size()+c.size()&gt;=<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(c.empty()||r.empty())&#123;</span><br><span class="line"><span class="keyword">bool</span> change = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(c.empty()) &#123;</span><br><span class="line">swap(r,c);</span><br><span class="line">change = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = n;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> upper = l,down = mid,left = c[<span class="number">0</span>],right = c[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(change) swap(left,upper),swap(down,right);</span><br><span class="line"><span class="keyword">if</span>(que(upper,down,left,right)) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!change) <span class="built_in">printf</span>(<span class="string">"! %d %d %d %d\n"</span>,l,c[<span class="number">1</span>],l,c[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"! %d %d %d %d\n"</span>,c[<span class="number">0</span>],l,c[<span class="number">1</span>],l);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(que(r[<span class="number">0</span>],r[<span class="number">0</span>],c[<span class="number">0</span>],c[<span class="number">0</span>])) <span class="built_in">printf</span>(<span class="string">"! %d %d %d %d\n"</span>,r[<span class="number">0</span>],c[<span class="number">0</span>],r[<span class="number">1</span>],c[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"! %d %d %d %d\n"</span>,r[<span class="number">0</span>],c[<span class="number">1</span>],r[<span class="number">1</span>],c[<span class="number">0</span>]);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Serval-and-Bonus-Problem"><a href="#F-Serval-and-Bonus-Problem" class="headerlink" title="F. Serval and Bonus Problem"></a>F. Serval and Bonus Problem</h2><p><a href="https://codeforces.com/contest/1153/problem/F" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>Getting closer and closer to a mathematician, Serval becomes a university student on math major in Japari University. On the Calculus class, his teacher taught him how to calculate the expected length of a random subsegment of a given segment. Then he left a bonus problem as homework, with the award of a garage kit from IOI. The bonus is to extend this problem to the general case as follows.</p><p>You are given a segment with length $l$. We randomly choose $n$ segments by choosing two points (maybe with non-integer coordinates) from the given segment equiprobably and the interval between the two points forms a segment. You are given the number of random segments $n$, and another integer $k$. The $2n$ endpoints of the chosen segments split the segment into ($2n+1$) intervals. Your task is to calculate the expected total length of those intervals that are covered by at least $k$ segments of the $n$ random segments.</p><p>You should find the answer modulo $998244353$.</p><h3 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h3><p>First line contains three space-separated positive integers 𝑛, 𝑘 and 𝑙 ($1\leq k\leq n\leq 2000,1\leq l\leq 10^9$).</p><h3 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h3><p>Output one integer — the expected total length of all the intervals covered by at least $k$ segments of the $n$ random segments modulo $998244353$.</p><p>Formally, let $M=998244353$. It can be shown that the answer can be expressed as an irreducible fraction $\frac{p}{q}$, where $p$ and $q$ are integers and $q\not\equiv0(modM)$. Output the integer equal to $p\cdot q^{-1}mod\ M$. In other words, output such an integer $x$ that $0\leq x&lt;M$ and $x\cdot q\equiv p(mod\ M)$.</p><h3 id="Examples-5"><a href="#Examples-5" class="headerlink" title="Examples"></a>Examples</h3><h4 id="inpus1"><a href="#inpus1" class="headerlink" title="inpus1"></a>inpus1</h4><p>1 1 1</p><h4 id="output1-5"><a href="#output1-5" class="headerlink" title="output1"></a>output1</h4><p>332748118</p><h4 id="input2-5"><a href="#input2-5" class="headerlink" title="input2"></a>input2</h4><p>6 2 1</p><h4 id="output2-5"><a href="#output2-5" class="headerlink" title="output2"></a>output2</h4><p>760234711</p><h4 id="input3-2"><a href="#input3-2" class="headerlink" title="input3"></a>input3</h4><p>7 5 3</p><h4 id="output3-2"><a href="#output3-2" class="headerlink" title="output3"></a>output3</h4><p>223383352</p><h4 id="input4-1"><a href="#input4-1" class="headerlink" title="input4"></a>input4</h4><p>97 31 9984524</p><h4 id="output4-1"><a href="#output4-1" class="headerlink" title="output4"></a>output4</h4><p>267137618</p><h3 id="Note-4"><a href="#Note-4" class="headerlink" title="Note"></a>Note</h3><p>In the first example, the expected total length is $\int_0^1 \int_0^1 |x-y|\ dx\ dy = \frac{1}{3} $, and $\frac{1}{3}$ modulo $998244353$ is $332748118$.</p><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>长度为l的线段，随机选取n个线段，线段中至少被n个线段中k个线段覆盖的长度期望。</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>说实话我当时没做出来，看了题解才知道怎么做的，所以强烈建议看官方的题解。我这里也贴出来，感兴趣的可以看一下。</p><p>Without loss of generality, assume that $l$=1. For a segment covering, the total length of the legal intervals is the probability that we choose another point $P$ on this segment randomly such that it is in the legal intervals. Since all $2n+1$ points ($P$ and the endpoints of each segment) are chosen randomly and independently, we only need to find the probability that point $P$ is in the legal intervals. Note that only the order of these $2n+1$ points make sense. Because the points are chosen in the segment, the probability that some of them coincide is $0$, so we can assume that all points do not coincide.</p><p>Now the problem is, how to calculate the number of arrangements that $P$ is between at least $k$ pairs of endpoints. It can be solved by dynamic programming in time complexity of $O(n^2)$. We define $f(i,j,x)$ as the number of arrangements for the first $i$ positions, with $j$ points haven’t been matched, and $P$ appeared $x$ times (obviously $x=0$ or $1$). So we can get three different types of transition for the $i$-th position below:</p><ul><li>Place $P$ at $i$-th position (if $j\geq k$): $f(i-1,j,0)\rightarrow f(i,j,1)$</li><li>Start a new segment (if $i+j+x&lt;2n$): $f(i-1,j-1,x)\rightarrow f(i,j,x)$</li><li>Match a started segment, note that we have 𝑗 choices of segments:$f(i-1,j+1,x)\times(j+1)\rightarrow f(i,j,x)$</li></ul><p>Then $f(2n+1,0,1)$ is the number of legal arrangements. Obviously, the total number of arrangements is $(2n+1)!$. However, there are 𝑛 pairs of endpoints whose indices can be swapped, and the indices 𝑛 segments can be rearranged. So the final answer is $\frac{f(2n+1,0,1)\times n!\times 2^n}{(2n+1)!}$.</p><p>可能是受了题解的影响，后来也没想出来其他解法。</p><p>这里讲一下题解怎么做的。</p><p>首先我们可以发现，长度和答案成正比，也就是说如果长度为1的时候答案是a，那么长度为2的时候答案就是2a%mod.</p><p>然后我们不妨设长度为1，最后答案乘上l就行了。</p><p>然后因为我们要找到至少被线段覆盖k次的所有点，所以我们不如加上一个虚拟点，这样就一共有了$(n&lt;&lt;1|1)$个点，然后需要判断这个虚拟点被多少条线段覆盖了，如果覆盖次数超过k次，就说明可以统计进答案。然后就可以发现，所有点是随机取的，所以我们假设所有点不会重合，那么所有点就可以离散成一个序列。然后就可以统计k的覆盖次数。</p><p>接下来就是dp，我们设$dp[i][j][flag]$表示序列中前i个点，其中到目前为止有j条线段左节点出线了，但是右节点没有出现，也就是说当前这个点被覆盖了j次，flag表示虚拟点是否出现了。然后考虑转移：</p><ul><li>当前节点是虚拟节点<ul><li>如果这个需要统计进入答案，也就是说明当前节点需要被覆盖k次及以上，所以 $j\geq k$</li><li>$dp[i][j][1]+=dp[i-1][j][0]$</li></ul></li><li>当前节点是一个线段的左端点<ul><li>也就是说左节点数量增加，被覆盖次数增加，但是不会影响虚拟节点的状态</li><li>$dp[i][j+1][flag]+=dp[i-1][j][flag]$</li></ul></li><li>当前节点是一个线段的右端点<ul><li>也就是说右节点数量增加，被覆盖次数减少，但是不会影响虚拟节点的状态,注意右端点可能会有j个可能</li><li>$dp[i][j-1][flag]+=dp[i-1][j][flag]*j$</li></ul></li></ul><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2345</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> (a+b)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> a*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span> </span>&#123;<span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:mul(a,fac(a<span class="number">-1</span>));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b = mod<span class="number">-2</span>)</span></span>&#123;<span class="comment">/*&#123;&#123;&#123;*/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = mul(ret,a);</span><br><span class="line">a = mul(a,a);</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;<span class="comment">/*&#125;&#125;&#125;*/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,k,l;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxm&lt;&lt;<span class="number">1</span>][maxm][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;k,&amp;l);</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=k) dp[i][j][<span class="number">1</span>] = add(dp[i][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> flag = <span class="number">0</span>;flag&lt;<span class="number">2</span>;flag++)</span><br><span class="line"><span class="keyword">if</span>(dp[i<span class="number">-1</span>][j][flag])&#123;</span><br><span class="line"><span class="keyword">if</span>(j) dp[i][j<span class="number">-1</span>][flag] = add(dp[i][j<span class="number">-1</span>][flag],mul(dp[i<span class="number">-1</span>][j][flag],j));</span><br><span class="line"><span class="keyword">if</span>(i+(j+<span class="number">1</span>)-(<span class="number">1</span>-flag)&lt;=(n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) dp[i][j+<span class="number">1</span>][flag] = add(dp[i][j+<span class="number">1</span>][flag],dp[i<span class="number">-1</span>][j][flag]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = mul(dp[n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>],qpow(<span class="number">2</span>,n));</span><br><span class="line">ans = mul(mul(ans,l),mul(fac(n),qpow(fac(n&lt;&lt;<span class="number">1</span>|<span class="number">1</span>))));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-Serval-and-Bus&quot;&gt;&lt;a href=&quot;#A-Serval-and-Bus&quot; class=&quot;headerlink&quot; title=&quot;A. Serval and Bus&quot;&gt;&lt;/a&gt;A. Serval and Bus&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/contest/1153/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="http://zuhiul.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>factorio</title>
    <link href="http://zuhiul.github.io/2019/03/31/factorio/"/>
    <id>http://zuhiul.github.io/2019/03/31/factorio/</id>
    <published>2019-03-30T16:00:00.000Z</published>
    <updated>2019-04-14T08:30:14.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><a id="more"></a><p><img src="../img/chepter1.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;level-1&quot;&gt;&lt;a href=&quot;#level-1&quot; class=&quot;headerlink&quot; title=&quot;level 1&quot;&gt;&lt;/a&gt;level 1&lt;/h3&gt;
    
    </summary>
    
    
      <category term="factorio" scheme="http://zuhiul.github.io/tags/factorio/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://zuhiul.github.io/2019/02/21/gluten/"/>
    <id>http://zuhiul.github.io/2019/02/21/gluten/</id>
    <published>2019-02-20T16:00:00.000Z</published>
    <updated>2019-04-14T08:32:10.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="头条面试回忆录"><a href="#头条面试回忆录" class="headerlink" title="头条面试回忆录"></a>头条面试回忆录</h2><h3 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h3><p>这两天参加了头条的面试,总体来说,感觉不错,公司效率很高…<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>当天上午投的简历,下午让我第二天面试,时间很紧,很多东西都没来得及准备….</p><p>1.自我介绍一下(balabalabala)</p><p>2.学过操作系统和计算机网络吗?(网络学了,操作系统下学期开,其实我很想说操作系统自学了,您可以问……)</p><p>3.说一下tcp和udp的区别(balabalabala)</p><ul><li>2.1那个快?为什么?(udp快,因为三次握手四次挥手会占用cpu时间?)</li><li>2.2去掉三次握手四次挥手那个快?(不知道)</li></ul><p>4.写两个题吧</p><ul><li>3.1 给你一个数字矩阵,每行每列都是增序,问你某个值是否存在(剑指offer原题,我100%做过,但是我忘了怎么做的,只知道从角上枚举,然后先说了一下从右下角枚举,说不对,然后换成右上角,没啥问题….)</li><li>3.2 给一个矩阵,四联通,找到一个最长上升子序列(简单dp,写完就过了)<ul><li>3.2.1 能把路径输出一下吗?(记录前驱….)</li><li>3.2.2 能把前驱数组去掉吗?(可以,瞎搞一下就行了…..)</li></ul></li></ul><p>4.闲聊(emmmmm)</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面感觉更严格,感觉答的不好…..</p><p>1.自我介绍(balabalabala)</p><p>2.有什么数据结构可以做到查询和插入都是o(1)的?(第一反映,显然不可能啊,这不是不可调和的矛盾吗?面试官说:知道hash吗?哇,感觉被鄙视了,确实傻了)</p><p>3.给你n个有序链表(从大到小),怎么找到这n个链表的前K大,(先取出每个链表的最大,然后建最大堆,然后每次取出堆顶,然后取出对应链表的后续元素,加入堆,然后一次操作,直到有k个元素)</p><ul><li>3.1 复杂度多少?(o(n+klogn))</li><li>3.2 n是怎么来的?(建堆时间)</li><li>3.3 能证明一下吗?(假设堆是用类树状数组的结构维护,先把数据随机放进来,然后每次从大到小枚举一个下标ind,比较当前位置ind和(ind&gt;&gt;1),然后根据大小关系交换一下,可以证明每次都是两个数比较,并且最多有n次比较,所以o(n))</li></ul><p>4.写两个题吧</p><ul><li>2.1 给你一个字典,给你一个询问串,问你能否用字典中的某些单词(每个单词只能用一次),构成询问串.(想复杂了,一直在想怎么优化,后来才知道直接暴力就行,我当时还傻乎乎的用了lower_bound企图缩小范围,结果返回结果还死活不对,搞了30分钟才搞定,感觉要凉)</li><li>2.2 可能是看我太菜,没问第二道题,感觉好像对我不感兴趣就溜了???</li></ul><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>不知道自己怎么活过二面的…….</p><p>1.聊天,纯聊天,可能是怕我太紧张,感觉面试官很好</p><p>2.提出自我介绍被拒绝…….</p><p>3.简单说一下项目,(也不用详细说,因为项目就是很简单……)</p><p>4.有啥很厉害的技术要说明的吗?(没有……)</p><p>5.我们写两个题吧</p><ul><li>5.1 给你一个无根树,让你转化成有根树,使得树的深度最小(一眼直径的中点,写了一下,好像有点问题,我问他我是调一下还是?他说不用调了,想法没啥大问题)</li><li>5.2 初始位置0,速度1,两个操作<ul><li>1.position+=spead,spead*=2</li><li>2.spead&gt;0,spead = -1;else spead = 1</li><li>问你最少操作几次,使得,从0到x</li><li>我第一想法二进制拆分,然后瞎搞,写了一下,没啥大问题</li><li>复杂度?(32^2?)</li><li>怎么证明,我说每次考虑最高位的1,然后瞎搞一下balabalabala</li><li>说正解是dp,比我复杂,emmmmm……..</li></ul></li></ul><p>6.浏览器输入baidu.com会发生啥?(balabalabala,昨天看过,不知道说的对不对)</p><p>7.你有啥觉得自己的技术亮点要说吗?(感觉瞎bb都能加分,但是我怂,老老实实说自己没啥技能点……)</p><p>8.你想过一些大的厂商,背后的技术部门都是怎么运行的吗?(不知道……..)</p><p>9.面试官可能觉得没啥聊的了,就放我走了……</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说,面试官还是很和蔼的,有些问题还会引导你向正确的方向思考,问题都不难,好好准备应该好过,就这样吧…….</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;头条面试回忆录&quot;&gt;&lt;a href=&quot;#头条面试回忆录&quot; class=&quot;headerlink&quot; title=&quot;头条面试回忆录&quot;&gt;&lt;/a&gt;头条面试回忆录&lt;/h2&gt;&lt;h3 id=&quot;废话&quot;&gt;&lt;a href=&quot;#废话&quot; class=&quot;headerlink&quot; title=&quot;废话&quot;&gt;&lt;/a&gt;废话&lt;/h3&gt;&lt;p&gt;这两天参加了头条的面试,总体来说,感觉不错,公司效率很高…&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://zuhiul.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Project Euler 276 Primitive Triangles</title>
    <link href="http://zuhiul.github.io/2019/01/17/PE276/"/>
    <id>http://zuhiul.github.io/2019/01/17/PE276/</id>
    <published>2019-01-16T16:00:00.000Z</published>
    <updated>2019-04-14T08:29:20.624Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=276" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>Consider the triangles with integer sides $a, b$ and $c$ with $a \leq b \leq c$.<br>An integer sided triangle $(a,b,c)$ is called primitive if $gcd(a,b,c)=1$.<br>How many primitive integer sided triangles exist with a perimeter not exceeding $10,000,000$?</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>问你存在多少个边长是整数的三角形,并且满足三边长的gcd为1,周长不超过$1e7$.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有一个比较奇奇怪怪的<a href="http://mathworld.wolfram.com/IntegerTriangle.html" target="_blank" rel="noopener">结论</a></p><p>我直接把结论搬过来$\dots$</p><p>\begin{eqnarray}<br>    F(n) =<br>    \begin{cases}<br>    \lfloor\frac{(n+3)^2+24}{48}\rfloor\ \ \ \ &amp;n\ \ is\ \ odd\\<br>    \lfloor\frac{n^2+24}{48}\rfloor\ \ \ \ &amp;n\ \ is\ \ even\<br>    \end{cases}<br>\end{eqnarray}</p><p>这个结论说的是,周长为$n$的边长都是整数的三角形的数量.然后我们可以预处理出所有的周长为$n$的数量出来,然后我们怎么保证gcd呢,比较好想的就是容斥,我们容斥掉所有gcd不是1的就行了,也就是说我们用周长为$2\cdot n,3\cdot n,\dots$的减去周长为$n$的就行啦啦啦</p><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e7</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[maxm];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&amp;<span class="number">1</span>) <span class="keyword">return</span> ((a+<span class="number">3</span>)*(a+<span class="number">3</span>)+<span class="number">24</span>)/<span class="number">48</span>;</span><br><span class="line"><span class="keyword">return</span> (a*a+<span class="number">24</span>)/<span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//预处理出每个周长对应的三角形数量,容斥得到正确的数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;maxm;i++) num[i] = get(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;maxm;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i&lt;&lt;<span class="number">1</span>;j&lt;maxm;j+=i) num[j]-=num[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;maxm;i++) ans+=num[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=276&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>Project Euler 643 2-Friendly</title>
    <link href="http://zuhiul.github.io/2019/01/09/PE643/"/>
    <id>http://zuhiul.github.io/2019/01/09/PE643/</id>
    <published>2019-01-08T16:00:00.000Z</published>
    <updated>2019-04-14T08:27:44.498Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=643" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>Two positive integers $a$ and $b$ are <em>2-friendly</em> when $gcd(a,b)=2^t,t&gt;0$. For example, $24$ and $40$ are <em>2-friendly</em> because $gcd(24,40)=8=2^3$ while $24$ and $36$ are not because $gcd(24,36)=12=2^2\cdot 3$ not a power of $2$.</p><p>Let $f(n)$ be the number of pairs, $(p,q)$, of positive integers with $1\leq p&lt;q\leq n$ such that $p$ and $q$ are <em>2-friendly</em>. You are given $f(10^2)=1031$ and $f(10^6)=321418433$ modulo $1000000007$ .</p><p>Find $f(10^{11})$ modulo $1000000007$.</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>问你所有满足$1\leq p&lt;q\leq 1e11$,并且$gcd(p,q)==2^t$的对数</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>显然可以对于每个$2^t$单独考虑,不妨设$2^t = x$,可以得到</p><p>$$<br>ans = \sum_{i=1}^{upper/x} \varphi(i)<br>$$</p><p>然后显然是各种筛法搞一下,我这里用的杜教筛,然后稍微推一推就可以得到</p><p>$$<br>s(m) = \frac{m\ast (m+1)}{2} - \sum_{d=2}^{m} s(\lfloor \frac{m}{d} \rfloor)<br>$$</p><p>然后分块一下,递归搞下去就行了$\dots$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> upper = <span class="number">1e11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> (a+b)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> (a%mod)*(b%mod)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span>&#123; <span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:mul(mod-mod/a,inv(mod%a)); &#125;</span><br><span class="line"><span class="keyword">int</span> inv2 = inv(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">bool</span> p[maxm];</span><br><span class="line"><span class="keyword">int</span> pri[maxm];<span class="comment">//质数</span></span><br><span class="line"><span class="keyword">int</span> phi[maxm];<span class="comment">//欧拉函数前缀和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>;i&lt;maxm;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!p[i])&#123;</span><br><span class="line">pri[++pri[<span class="number">0</span>]] = i;</span><br><span class="line">phi[i] = i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;maxm;j++)&#123;</span><br><span class="line">p[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%pri[j]) phi[i*pri[j]] = phi[i]*(pri[j]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">phi[i*pri[j]] = phi[i]*pri[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;maxm;i++) phi[i] = add(phi[i],phi[i<span class="number">-1</span>]);<span class="comment">//因为只会用到前缀和,所以我们直接预处理成前缀和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m&lt;maxm) <span class="keyword">return</span> phi[m];<span class="comment">//查表</span></span><br><span class="line"><span class="keyword">if</span>(mp[m]) <span class="keyword">return</span> mp[m];<span class="comment">//记忆化</span></span><br><span class="line"><span class="keyword">int</span> ret = mul(m,mul(m+<span class="number">1</span>,inv2));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">2</span>,r;l&lt;=m;l = r+<span class="number">1</span>) &#123;<span class="comment">//分块</span></span><br><span class="line">r = m/(m/l);</span><br><span class="line">ret = add(ret,mod-mul(solve(m/l),r-l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mp[m] = ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">2</span>;x&lt;=upper;x&lt;&lt;=<span class="number">1</span>) &#123;<span class="comment">//单独统计每一个2的幂</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">ans = add(ans,solve(upper/x));</span><br><span class="line">ans = add(ans,mod<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=643&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>Project Euler 222 Sphere Packing</title>
    <link href="http://zuhiul.github.io/2019/01/04/PE222/"/>
    <id>http://zuhiul.github.io/2019/01/04/PE222/</id>
    <published>2019-01-03T16:00:00.000Z</published>
    <updated>2019-04-14T08:29:12.064Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=222" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>What is the length of the shortest pipe, of internal radius $50$mm, that can fully contain $21$ balls of radii $30$mm, $31$mm, …, $50$mm?</p><p>Give your answer in micrometres ($10^{-6}$ m) rounded to the nearest integer.</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>让你在一个内径$50$的圆管里塞$21$个内径分别为$31-50$的小球,问你圆管最短是多少</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>比较显然是dp</p><p>考虑dp状态:dp[i][j]表示选择小球对应的集合为j,并且用第i个小球结尾,然后我们转移的时候就直接添加一个小球,对于剩余的小球枚举一个结尾,取最优解就行了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">double</span> ans[maxm][<span class="number">1</span>&lt;&lt;maxm];</span><br><span class="line"><span class="keyword">int</span> num[maxm+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//得到两个小球的距离</span></span><br><span class="line"><span class="keyword">int</span> t = a+b+<span class="number">60</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>*<span class="built_in">sqrt</span>(t*<span class="number">2</span><span class="number">-100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;maxm;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;maxm);j++) ans[i][j] = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;maxm);s++) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;maxm;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="number">0</span>)&#123;<span class="comment">//初值条件</span></span><br><span class="line">ans[i][<span class="number">1</span>&lt;&lt;i] = i+<span class="number">30</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((s &gt;&gt; i &amp; <span class="number">1</span>)==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> t = s|(<span class="number">1</span>&lt;&lt;i);<span class="comment">//用S来扩展t</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;maxm;j++) <span class="keyword">if</span>(s&gt;&gt;j&amp;<span class="number">1</span>) ans[i][t] = min(ans[i][t],ans[j][s]+cal(i,j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> rans = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;maxm;i++) rans = min(rans,ans[i][(<span class="number">1</span>&lt;&lt;maxm)<span class="number">-1</span>]+i+<span class="number">30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.0f\n"</span>,rans*<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=222&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="DP" scheme="http://zuhiul.github.io/tags/DP/"/>
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>Project Euler 122 Efficient exponentiation</title>
    <link href="http://zuhiul.github.io/2019/01/02/PE122/"/>
    <id>http://zuhiul.github.io/2019/01/02/PE122/</id>
    <published>2019-01-01T16:00:00.000Z</published>
    <updated>2019-04-14T08:27:27.678Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=122" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>The most naive way of computing $n^{15}$ requires fourteen multiplications:</p><p>$n \times n \times \dots \times n = n^{15}$</p><p>But using a “binary” method you can compute it in six multiplications:</p><p>\begin{eqnarray}<br>n \times n &amp;= n^2\\<br>n^2 \times n^2 &amp;= n^4\\<br>n^4 \times n^4 &amp;= n^8\\<br>n^8 \times n^4 &amp;= n^{12}\\<br>n^{12} \times n^2 &amp;= n^{14}\\<br>n^{14} \times n &amp;= n^{15}\\<br>\end{eqnarray}</p><p>However it is yet possible to compute it in only five multiplications:</p><p>\begin{eqnarray}<br>n \times n &amp;= n^2\\<br>n^2 \times n &amp;= n^3\\<br>n^3 \times n^3 &amp;= n^6\\<br>n^6 \times n^6 &amp;= n^{12}\\<br>n^{12} \times n^3 &amp;= n^{15}\\<br>\end{eqnarray}</p><p>We shall define $m(k)$ to be the minimum number of multiplications to compute $n^k$; for example $m(15) = 5$.</p><p>For $1 \leq k \leq 200$, find $\sum m(k)$.</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>我们知道快速计算一个数的幂次有各种不同的方法,快速幂只是其中一种而且不是最快的,然后问你对于1~200的幂次来说,最少需要几次乘法操作.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有一个<a href="https://en.wikipedia.org/wiki/Addition_chain" target="_blank" rel="noopener">wiki</a>讲的就是这个问题,可以看一看….</p><p>我们可以发现,对于所有幂次来说,我们按照最后一步操作的数来构成他的前驱,然后我们会发现他是一棵树,然后我们直接构造出这颗树出来,就是最优答案…..</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s[<span class="number">222</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">1e8</span>,ind = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=a;i++)&#123;<span class="comment">//枚举每一个比他小的数,看是否可以作为他的前驱</span></span><br><span class="line"><span class="keyword">if</span>(s[i].size()+<span class="number">1</span>&gt;=now) <span class="keyword">continue</span>;<span class="comment">//如果不能优化解就不继续搜索</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:s[i])<span class="comment">//枚举每一个前驱的子元素</span></span><br><span class="line"><span class="keyword">if</span>(s[i].find(a-x)!=s[i].end())&#123;<span class="comment">//如果能构成a</span></span><br><span class="line">now = s[i].size()+<span class="number">1</span>;<span class="comment">//更新解</span></span><br><span class="line">ind = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:s[ind]) s[a].insert(i);<span class="comment">//保存路径</span></span><br><span class="line">s[a].insert(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">s[<span class="number">1</span>].insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=<span class="number">200</span>;i++) cal(i);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">200</span>;i++) ans+=s[i].size()<span class="number">-1</span>;<span class="comment">//要把里面的1剪掉,因为合成1不要代价</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=122&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>Project Euler 143 Investigating the Torricelli point of a triangle</title>
    <link href="http://zuhiul.github.io/2018/12/28/PE143/"/>
    <id>http://zuhiul.github.io/2018/12/28/PE143/</id>
    <published>2018-12-27T16:00:00.000Z</published>
    <updated>2019-04-14T08:28:05.155Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=143" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>Let ABC be a triangle with all interior angles being less than $120$ degrees. Let $X$ be any point inside the triangle and let $XA = p, XC = q$, and $XB = r$.</p><p>Fermat challenged Torricelli to find the position of X such that $p + q + r$ was minimised.</p><p>Torricelli was able to prove that if equilateral triangles AOB, BNC and AMC are constructed on each side of triangle ABC, the circumscribed circles of AOB, BNC, and AMC will intersect at a single point, T, inside the triangle. Moreover he proved that T, called the Torricelli/Fermat point, minimises $p + q + r$. Even more remarkable, it can be shown that when the sum is minimised, $AN = BM = CO = p + q + r$ and that AN, BM and CO also intersect at T.</p><p><img src="https://raw.githubusercontent.com/zuhiul/just-for-fun/master/ForBlog/img/PE143.gif" alt="avatar"></p><p>If the sum is minimised and a, b, c, p, q and r are all positive integers we shall call triangle ABC a Torricelli triangle. For example, $a = 399, b = 455, c = 511$ is an example of a Torricelli triangle, with $p + q + r = 784$.</p><p>Find the sum of all distinct values of $p + q + r ≤ 120000$ for Torricelli triangles.</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>就是三个角都小于120度的三角形存在费马点,然后让你找到所有这样的三角形,使得图上对应的六条边都是整数,其中$T$就是费马点.然后你要找到所有$p+q+r$不同的所有三角形,然后把$p+q+r$求和.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于每一个圆来说,因为里面的三角形是对边三角形,然后因为$T$在园上,于是有$T$对应的角大小一定是$180-60 = 120$度,然后同理可得,三个角都是$120$度,然后我们运用余弦定理可以得到$p^2+q^2+pq=b^2$,因为我们只要$p+q+r$不同的解,所以我们不妨设$p&gt;=q&gt;=r$,因为三个角都是$120$度,所以余弦定理都成立,所以我们可以得到</p><p>\begin{eqnarray}<br>q^2+r^2+qr &amp;= a^2\\<br>p^2+q^2+pq &amp;= b^2\\<br>p^2+r^2+pr &amp;= c^2\\<br>p&gt;=q&gt;=r\\<br>\end{eqnarray}</p><p>然后我们对于每对关系,可以显然发现都应该是类似的,然后我们可以存下来每个关系,然后暴搜就行了,emmmmmm$\dots$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> upper = <span class="number">1.2e5</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; to[upper+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> ans[upper&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>;i&lt;=upper;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j = min(upper-i,i);j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x = i*i+j*j+i*j;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> y = <span class="built_in">sqrt</span>(x);</span><br><span class="line"><span class="keyword">if</span>(y*y==x) to[i].insert(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=upper;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j:to[i])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k:to[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(i+j+k&gt;upper) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(to[i].count(k))&#123;</span><br><span class="line">ans[i+j+k] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=upper;i++) <span class="keyword">if</span>(ans[i]) rans+=i;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;rans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=143&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>gcd and fibonacii</title>
    <link href="http://zuhiul.github.io/2018/12/28/gcd_fibonacci/"/>
    <id>http://zuhiul.github.io/2018/12/28/gcd_fibonacci/</id>
    <published>2018-12-27T16:00:00.000Z</published>
    <updated>2019-04-14T08:30:26.887Z</updated>
    
    <content type="html"><![CDATA[<p>前两天看到一个比较奇怪的公式,然后队友让证明一下,公式如下</p><p>$$<br>gcd(f_i,f_j) = f_{gcd(i,j)}<br>$$</p><a id="more"></a><p>下面给出证明</p><h1 id="gcd-f-i-f-i-1-1"><a href="#gcd-f-i-f-i-1-1" class="headerlink" title="$gcd(f_i,f_{i-1}) = 1$"></a>$gcd(f_i,f_{i-1}) = 1$</h1><p>\begin{eqnarray}<br>gcd(f_i,f_{i-1}) &amp;=&amp; gcd(f_{i-1}+f_{i-2},f_{i-1})\\<br>&amp;=&amp; gcd(f_{i-2},f_{i-1})\\<br>&amp;=&amp; gcd(f_{i-3},f_{i-2})\\<br>&amp;=&amp; \dots\\<br>&amp;=&amp; gcd(f_1,f_2)\\<br>&amp;=&amp; 1\\<br>\end{eqnarray}</p><h1 id="f-i-j-f-i-1-cdot-f-j-f-i-cdot-f-j-1"><a href="#f-i-j-f-i-1-cdot-f-j-f-i-cdot-f-j-1" class="headerlink" title="$f_{i+j} = f_{i-1}\cdot f_j + f_i\cdot f_{j+1}$"></a>$f_{i+j} = f_{i-1}\cdot f_j + f_i\cdot f_{j+1}$</h1><p>首先,$j = 1$时有 $f_{i+1} = f_{i-1}+f_i$ 显然成立,</p><p>当$j = 2$时有</p><p>\begin{eqnarray}<br>f_{i+2} &amp;=&amp; f_{i+1} + f_{i}\\<br>&amp;=&amp; (f_{i}+f_{i-1}) + f_{i}\\<br>&amp;=&amp; f_{i-1} \cdot 1 + f_{i} \cdot 2\\<br>&amp;=&amp; f_{i-1} \cdot f_j + f_i \cdot f_{j+1}\\<br>\end{eqnarray}</p><p>然后我们证明,当$j = k-1$和$j = k-2$成立时,$j = k$也成立</p><p>也就是说已知</p><p>$$<br>\begin{cases}<br>f_{i+k-1} &amp;=&amp; f_{i-1}\cdot f_{k-1} + f_{i}\cdot f_k\\<br>f_{i+k-2} &amp;=&amp; f_{i-1}\cdot f_{k-2} + f_{i}\cdot f_{k-1}\\<br>\end{cases}<br>$$</p><p>然后我们累加上面两式,可以得到</p><p>$$<br>f_{i+k-1}+f_{i+k-2} = f{i-1}\cdot f_{k-1} + f_{i}\cdot f_k + f{i-1}\cdot f_{k-2} + f_{i}\cdot f_{k-1}<br>$$</p><p>$$<br>\therefore<br>\begin{eqnarray}<br>f_{i+k} &amp;=&amp; f_{i-1}\cdot (f_{k-1}+f{k-2}) + f_{i}\cdot (f_{k}+f_{k-1})\\<br>        &amp;=&amp; f_{i-1}\cdot f_{k} + f_{i}\cdot f_{k+1}\\<br>\end{eqnarray}<br>$$</p><h1 id="gcd-f-i-j-f-i-gcd-f-i-f-j"><a href="#gcd-f-i-j-f-i-gcd-f-i-f-j" class="headerlink" title="$ gcd(f_{i+j},f_{i}) = gcd(f_{i},f_{j}) $"></a>$ gcd(f_{i+j},f_{i}) = gcd(f_{i},f_{j}) $</h1><p>$$<br>\begin{eqnarray}<br>gcd(f_{i+j},f_{i}) &amp;=&amp; gcd(f_{i-1}\cdot f_j + f_i\cdot f_{j+1},f_{i})\\<br>&amp;=&amp; gcd(f_{i-1}\cdot f_{j},f_{i})\\<br>&amp;=&amp; gcd(f_{j},f_{i})  (\because gcd(f_{i},f_{i-1}) = 1)\\<br>\end{eqnarray}<br>$$</p><p>所以上面的结论可以继续推广,容易得到</p><p>$$<br>gcd(f_{i},f_{j}) = gcd(f_{i\%j},f_{j})<br>$$</p><h1 id="gcd-f-i-f-j-f-gcd-i-j"><a href="#gcd-f-i-f-j-f-gcd-i-j" class="headerlink" title="$gcd(f_{i},f_{j}) = f_{gcd(i,j)} $"></a>$gcd(f_{i},f_{j}) = f_{gcd(i,j)} $</h1><p>由上面的结论,我们容易得到,我们不断调用上面的结论,直到$i==1||j==1$,然后可以得到,如果$k=gcd(i,j)$,那么有$gcd(f_{i},f_{j}) = gcd(f_{k},f_{1}) = f_{k} = f_{gcd(i,j)}$</p><p>命题得证</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天看到一个比较奇怪的公式,然后队友让证明一下,公式如下&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;gcd(f_i,f_j) = f_{gcd(i,j)}&lt;br&gt;$$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>IC(answer.chepter1)</title>
    <link href="http://zuhiul.github.io/2018/12/24/IC_chepter1/"/>
    <id>http://zuhiul.github.io/2018/12/24/IC_chepter1/</id>
    <published>2018-12-23T16:00:00.000Z</published>
    <updated>2019-04-14T08:28:39.412Z</updated>
    
    <content type="html"><![CDATA[<p>作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢<br><a id="more"></a></p><p>1.利用反证法容易得到,如果$n$和$m$都是奇数,那么$n*m$也是奇数,显然不可覆盖,所以$n$和$m$至少有一个偶数</p><p>2.我们定义行号从上到下为$1\dots m$,列号从左到右为$1\dots n$,然后我们就可以得到被切掉的那个方块只可能是奇数行奇数列,或者偶数行偶数列,我们考虑对这两种方案分别进行构造来得到我们想要的答案.</p><ul><li>奇数行奇数列:对于和他在同一行同一列的方块来说,因为他去掉了,所以剩下的一定是可以匹配的偶数,也就是说我们可以匹配上这一行一列,对于剩下的一定都是偶数行偶数列的联通块,显然可以构造</li><li>奇数行奇数列:这个稍微麻烦一点,我们可以选择他周围的奇数行奇数列的一个子矩阵,显然可以螺旋式的构造,也就是说我们用完左上角,对于剩下的容易证明也是两个偶数的联通块,同样可以构造,看图<br><img src="https://raw.githubusercontent.com/zuhiul/just-for-fun/master/ForBlog/img/IC1-1.png" alt="avatar"></li></ul><p>3.显然是不能获得自由的,因为我们可以将这个棋盘黑白二染色,然后可以发现对顶角颜色相同,每一步颜色都会反转,一共要走63步,所以最后一步一定会在异色块上,所以不行.</p><p>4.(a)对于每一个$n$来说我们直接考虑最后一块的摆放方法,如果是竖着放,那么剩下的就是$f(n-1)$的子问题,如果是横着放,那么倒数第二块显然也是横着放的,所以剩下的就是$f(n-2)$的子问题,所以显然可以得到的是$f(n) = f(n-1)+f(n-2)$,也就是说答案就是fibonacci.$\therefore f(12) = 233$</p><p>4.(b)这里我们可以考虑DP来做,具体程序如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxm][<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">3</span>] = dp[<span class="number">0</span>][<span class="number">6</span>] = dp[<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">4</span>] = dp[<span class="number">1</span>][<span class="number">7</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;maxm;i++)&#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i<span class="number">-2</span>][<span class="number">3</span>]+dp[i<span class="number">-2</span>][<span class="number">6</span>]+dp[i<span class="number">-2</span>][<span class="number">0</span>];</span><br><span class="line">dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+dp[i<span class="number">-2</span>][<span class="number">1</span>];</span><br><span class="line">dp[i][<span class="number">3</span>] = dp[i][<span class="number">0</span>]+dp[i<span class="number">-2</span>][<span class="number">3</span>];</span><br><span class="line">dp[i][<span class="number">4</span>] = dp[i][<span class="number">1</span>];</span><br><span class="line">dp[i][<span class="number">6</span>] = dp[i][<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以发现$g(n) = 4\ast g(n-2)-g(n-4)$</p><p>5.用4.(b)的代码容易可得,$g(4) = 11$</p><p>6.同样采用反证法容易证得$n$是偶数,下面我们考虑$n$是奇数扣掉中间一块的情况.不妨假设八个角上的颜色是黑色,可以得到黑块数量是$4k^3+6k^2+3k+1$,白块的数量是$4k^3+6k^2+3k$,我们可以分两种情况讨论,我们假设$n = 2k+1$</p><ul><li>当k是奇数时,也就是$k = 2t+1$,即$n = 4t+3$,中间块是白色的.然后扣掉白块后,显然黑块和白块不匹配,然后不行鸭.</li><li>当k是偶数时,也就是$k = 2t$,即$n = 4t+1$,中间块是黑色的,扣掉黑块后,白块和黑块是匹配的,可能可以.下面我们证明$n = 4t+1$时是可行的<ul><li>我们按照层数拆分,我们抽掉其中的第$2t+1$层,我们可以得到,这一层显然是可行的,类比于二阶的时候,我们扣掉中心块</li><li>对于剩下的两个联通块,我们显然可以得到是他们对称,我们只考虑上面的$2t$层的部分,我们每两层考虑一下</li><li>对于相连的两层,也就是$2\ast n\ast n$的形状,我们显然可以构造,所以整个三维结构是可以构造的.</li></ul></li></ul><p>7.首先证明$a$既是$n$的因子,又是$m$的因子</p><ul><li>因为$a$是$b$的因子,所以$a\ast b$的可以看成多个$a\ast a$的,采用反证法,假设$a$不是$m$的因子,那么对于剩下的$(m%a)\ast (n%a)$的矩阵显然不可以用$a\ast a$的矩阵填满,所以$m%a==0&amp;&amp;n%a==0$.</li></ul><p>再证$b$是$n$或者$m$的因子</p><ul><li>同样反证法,我们将$a,b,m,n$同时缩小$a$倍,然后可以转化成,现在有一个$x\ast y$的棋盘,我要用一个$1\ast z$的棋盘去覆盖他,但是$gcd(x,z)=gcd(y,z)=1$,这个可以显然发现是不可能的</li></ul><p>8.先证:存在完美覆盖$\rightarrow$存在平凡完美覆盖</p><ul><li>利用习题7,我们得到如果存在完美覆盖,那么$gcd(n,a)=gcd(m,a)=a$并且$gcd(m,b)=b$,然后我们显然可以让$b$的朝向指向$m$的方向,也就是存在平凡完美覆盖</li></ul><p>再证:存在平凡完美覆盖$\rightarrow$存在完美覆盖</p><ul><li>显然</li></ul><p>9.显然,举个简单例子$n=5,m=6,a=2,b=3$存在完美覆盖,但是不存在平凡完美覆盖.</p><p>10.假设存在不妨设四个变量是$a,b,c,d$,那么可以得到$a+b=b+c$即$a=c$显然不能构成幻方</p><p>11.12.13 如图</p><p><img src="https://raw.githubusercontent.com/zuhiul/just-for-fun/master/ForBlog/img/IC1-2.png" alt="avatar"></p><p>14.所有可能的构造如图</p><p><img src="https://raw.githubusercontent.com/zuhiul/just-for-fun/master/ForBlog/img/IC1-3.png" alt="avatar"></p><p>15.暴力枚举的,确实没有解,并不知道为什么……</p><p>16.$n$阶幻方,幻方总和是$n^2\ast (n^2+1)/2$,所以每一行每一列求和都是$n\ast (n^2+1)/2$,现在替换后每一行每一列的和换成了$n\ast (n^2+1) - n\ast (n^2+1)/2 = n\ast (n^2+1)/2$所以可能是个幻方,然后因为里面的元素都是属于$[1,n^2]$之间的,所以$n^2+1-a$可以保证换完之后每个元素还是只出现一次,所以新生成的还是幻方.</p><p>17.给出$n=4$和$n=8$时的图…….</p><p><img src="https://raw.githubusercontent.com/zuhiul/just-for-fun/master/ForBlog/img/IC1-4.png" alt="avatar"></p><p>18.这个应该是显然的,因为二阶幻方都没有,显然没有二阶幻方体.</p><p>19.首先我们拆开来看没一个单独的平面,我们可以得到,对于一个四阶幻方来说,如果对角线也满足幻和,那么显然可以得到任意三阶子矩阵的对顶角之和等于幻和的一半,所以我们任取出四阶幻方体的任一三阶子体,可以得到类似于$a+b=b+c$的等式,也就是说存在$a==c$的情况,这显然和题意不符,所以不可能存在四阶幻方体.</p><p>20.首先,$10$和$5$一个颜色,$1,3,7,9$一个颜色,$2,4,6,8$一种颜色,可以得到可以由三种颜色构成,然后,$1,2,10$相互接壤,显然需要三种及以上颜色来涂,方案数为$3\ast 2\ast 1 = 6$.</p><p>21.(a) 二阶的显然不存在,书后面给了答案,还有一个比较简单的想法就是如果存在显然可以得到类似于$a==b$的结论,所以不存在.</p><p>(b) 暴搜剪枝,emmmmm……如图</p><p><img src="https://raw.githubusercontent.com/zuhiul/just-for-fun/master/ForBlog/img/IC1-5.jpg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢&lt;br&gt;
    
    </summary>
    
    
      <category term="IC" scheme="http://zuhiul.github.io/tags/IC/"/>
    
  </entry>
  
  <entry>
    <title>IC(answer.chepter2)</title>
    <link href="http://zuhiul.github.io/2018/12/24/IC_chepter2/"/>
    <id>http://zuhiul.github.io/2018/12/24/IC_chepter2/</id>
    <published>2018-12-23T16:00:00.000Z</published>
    <updated>2019-04-14T08:28:50.217Z</updated>
    
    <content type="html"><![CDATA[<p>作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢<br><a id="more"></a></p><p>1.$\emptyset$ : $4^5 = 1024$.$\lbrace a\rbrace$ : $5\times 4\times 4\times 4 = 320$.$\lbrace b\rbrace$ : $5\times 5\times 5\times 2 = 250$.$\lbrace a,b\rbrace$ : $4\times 4\times 4\times 2 = 128$</p><p>2.$(13!)^4 = 1503561738404723998944447273369600000000$.</p><p>3.<br>$$<br>\left(<br>    \begin{matrix}<br>        52\\<br>        5<br>    \end{matrix}<br>\right)<br>=2598960<br>$$</p><p>4.(a) $5\times 3\times 7\times 2 = 210$<br>(b) $620 = 2^2+3^1+5^1+7^1$,$3\times 2\times 2\times 2 = 24$<br>(c) $10^{10} = 2^{10} 5^{10}$,$11\times 11 = 121$</p><p>5.因为$10 = 2\times 5$,所以我们只用统计$2,5$的数量就行了,然后我们可以发现,$2$的数量显然多于$5$的数量,所以我们只用统计$5$的个数就是答案.下面给出一个通用的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(a) ret+=a/=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.小数据暴力,大数据模拟</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者自己辛苦原创,如有错误or转载or其他用途请联系qq:669415029,谢谢&lt;br&gt;
    
    </summary>
    
    
      <category term="IC" scheme="http://zuhiul.github.io/tags/IC/"/>
    
  </entry>
  
  <entry>
    <title>Project Euler 463 A weird recurrence relation</title>
    <link href="http://zuhiul.github.io/2018/12/23/PE463/"/>
    <id>http://zuhiul.github.io/2018/12/23/PE463/</id>
    <published>2018-12-22T16:00:00.000Z</published>
    <updated>2019-04-14T08:29:47.077Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=463" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>The function $f$ is defined for all positive integers as follows:</p><p>$f(1)$ = $1$</p><p>$f(3)$ = $3$</p><p>$f(2n)$ = $f(n)$</p><p>$f(4n+1)$ = $2\cdot f(2n+1)-f(n)$</p><p>$f(4n+3)$ = $3\cdot f(2n+1)-2\cdot f(n)$</p><p>The function $S(n)$ is defined as $\sum_{i=1}^{n} f(i)$.</p><p>$S(8)=22$ and $S(100)=3604$.</p><p>Find $S(3^{37})$. Give the last $9$ digits of your answer.</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>就是给你一个序列,问你这个序列的前缀和是多少</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>显然是推公式嘛.</p><p>根据题意我们显然可以得到</p><p>$f(4n)+f(4n+1)+f(4n+2)+f(4n+3) = 6\cdot f(2n+1) - 2\cdot f(n)$ for $n\geq 1$</p><p>然后我们每四项加一下就可以得到下面这个公式</p><p>\begin{eqnarray}<br>S(4n+3) &amp;=&amp; \sum_{i=1}^{4i+3} f(i)\\<br>        &amp;=&amp; 5 + \sum_{i=4}^{4i+3} f(i)\\<br>        &amp;=&amp; 5 + \sum_{i=1}^{n} (6\cdot f(2i+1) - 2\cdot f(i))\\<br>        &amp;=&amp; 5 + 6\sum_{i=1}^{n} (f(2i+1)+f(2i)) - 8\sum_{i=1}^{n} f(i)\\<br>        &amp;=&amp; 5 + 6\sum_{i=2}^{2n+1} f(i) - 8\sum_{i=1}^{n} f(i)\\<br>        &amp;=&amp; 5 - 6 + 6\sum{i=1}{2n+1} f(i) - 8\sum_{i=1}^{n} f(i)\\<br>        &amp;=&amp; -1 + 6\sum{i=1}{2n+1} f(i) -8\sum_{i=1}^{n} f(i)\\<br>\end{eqnarray}</p><p>然后瞎搞就行了$\dots$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> (a+b)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> a*b%mod;&#125;</span><br><span class="line"><span class="keyword">int</span> num[maxm];</span><br><span class="line"><span class="keyword">int</span> sum[maxm];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;maxm&amp;&amp;num[a]) <span class="keyword">return</span> num[a];</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>((a&amp;<span class="number">1</span>)^<span class="number">1</span>) <span class="keyword">return</span> f(a&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((a&amp;<span class="number">3</span>)==<span class="number">3</span>) <span class="keyword">return</span> add(mul(<span class="number">3</span>,f(a&gt;&gt;<span class="number">1</span>)),mod-(f(a&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> add((f(a&gt;&gt;<span class="number">1</span>|<span class="number">1</span>)&lt;&lt;<span class="number">1</span>),mod-f(a&gt;&gt;<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;maxm) <span class="keyword">return</span> sum[a];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a%<span class="number">4</span>==<span class="number">3</span>)&#123;</span><br><span class="line">ret = add(ret,mul(<span class="number">6</span>,S(a&gt;&gt;<span class="number">1</span>)));</span><br><span class="line">ret = add(ret,mod-mul(<span class="number">8</span>,S(a&gt;&gt;<span class="number">2</span>)));</span><br><span class="line">ret = add(ret,mod<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(a%<span class="number">4</span>!=<span class="number">3</span>) ret = add(ret,mod-f(++a));</span><br><span class="line">ret = add(ret,S(a));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;maxm;i++) num[i] = f(i),sum[i] = add(sum[i<span class="number">-1</span>],num[i]);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> nouse = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">37</span>;i++)&#123;</span><br><span class="line">nouse = (nouse&lt;&lt;<span class="number">2</span>)-nouse;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;S(nouse)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=463&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>matlab</title>
    <link href="http://zuhiul.github.io/2018/12/23/matlab/"/>
    <id>http://zuhiul.github.io/2018/12/23/matlab/</id>
    <published>2018-12-22T16:00:00.000Z</published>
    <updated>2019-05-05T02:40:47.791Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统级命令"><a href="#系统级命令" class="headerlink" title="系统级命令"></a>系统级命令</h3><a id="more"></a><table><thead><tr><th style="text-align:center">命令名称</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">clear</td><td style="text-align:center">清楚内存中所有的或指定的变量和函数</td></tr><tr><td style="text-align:center">cd</td><td style="text-align:center">显示和改变当前工作目录</td></tr><tr><td style="text-align:center">clc</td><td style="text-align:center">擦除MATLAB工作窗口中所有显示的内容</td></tr><tr><td style="text-align:center">clf</td><td style="text-align:center">擦除MATLAB当前工作窗口中的图形</td></tr><tr><td style="text-align:center">dir</td><td style="text-align:center">列出当前或者指定目录下的子目录和文件清单</td></tr><tr><td style="text-align:center">disp</td><td style="text-align:center">在运行中显示变量或文字信息</td></tr><tr><td style="text-align:center">echo</td><td style="text-align:center">控制运行的文字命令是否显示</td></tr><tr><td style="text-align:center">hold</td><td style="text-align:center">控制当前的图形窗口对象是否被刷新</td></tr><tr><td style="text-align:center">home</td><td style="text-align:center">擦除命令窗口中的内容,并把光标移动到命令窗口</td></tr><tr><td style="text-align:center">pack</td><td style="text-align:center">收集内存碎片以扩大内存空间</td></tr><tr><td style="text-align:center">quit</td><td style="text-align:center">关闭并退出MATLAB</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">显示所指定文件的全部内容</td></tr><tr><td style="text-align:center">exit</td><td style="text-align:center">退出MATLAB</td></tr><tr><td style="text-align:center">save</td><td style="text-align:center">将工作区的变量存放到指定文件</td></tr><tr><td style="text-align:center">load</td><td style="text-align:center">回复保存过的变量</td></tr></tbody></table><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">ans</td><td style="text-align:center">结果的缺省变量名</td></tr><tr><td style="text-align:center">pi</td><td style="text-align:center">圆周率</td></tr><tr><td style="text-align:center">i,j</td><td style="text-align:center">虚数单位</td></tr><tr><td style="text-align:center">inf</td><td style="text-align:center">无穷大</td></tr><tr><td style="text-align:center">NaN</td><td style="text-align:center">not a number</td></tr></tbody></table><h3 id="矩阵函数"><a href="#矩阵函数" class="headerlink" title="矩阵函数"></a>矩阵函数</h3><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">complex</td><td style="text-align:center">将两个矩阵并成一个复矩阵</td></tr><tr><td style="text-align:center">zeros(a,b)</td><td style="text-align:center">a*b全0阵</td></tr><tr><td style="text-align:center">ones(a,b)</td><td style="text-align:center">a*b全1阵</td></tr><tr><td style="text-align:center">eye(a,b)</td><td style="text-align:center">a*b单位矩阵</td></tr><tr><td style="text-align:center">randi([a,b],m,n)</td><td style="text-align:center">m*n在a,b之间等概率随机整数矩阵</td></tr><tr><td style="text-align:center">randn(a,b)</td><td style="text-align:center">产生均值为0,方差为1的a*b的高斯分布随机阵</td></tr><tr><td style="text-align:center">repmat(a,b,c)</td><td style="text-align:center">将a矩阵铺放成b<em>c的形式,总大小size(a)</em>b*c</td></tr><tr><td style="text-align:center">size(a)</td><td style="text-align:center">确定矩阵大小,返回[行数,列数]</td></tr><tr><td style="text-align:center">length(a)</td><td style="text-align:center">确定向量元素的个数</td></tr><tr><td style="text-align:center">numel(a)</td><td style="text-align:center">确定矩阵中元素个数</td></tr><tr><td style="text-align:center">find()</td><td style="text-align:center">查找矩阵中满足条件的下标,或者行列</td></tr><tr><td style="text-align:center">reshape(a,b,c)</td><td style="text-align:center">将a变成b行c列(按列重拍)</td></tr><tr><td style="text-align:center">a’</td><td style="text-align:center">转置,复数则共轭转置</td></tr><tr><td style="text-align:center">a(:)</td><td style="text-align:center">变成一列</td></tr><tr><td style="text-align:center">rot90</td><td style="text-align:center">旋转</td></tr><tr><td style="text-align:center">fliplr</td><td style="text-align:center">左右翻转</td></tr><tr><td style="text-align:center">flipud</td><td style="text-align:center">上下翻转</td></tr><tr><td style="text-align:center">diag</td><td style="text-align:center">抽取主对角线</td></tr><tr><td style="text-align:center">tril</td><td style="text-align:center">抽取上三角</td></tr><tr><td style="text-align:center">triu</td><td style="text-align:center">抽取下三角</td></tr><tr><td style="text-align:center">max</td><td style="text-align:center">各列最大值</td></tr><tr><td style="text-align:center">min</td><td style="text-align:center">各列最小值</td></tr><tr><td style="text-align:center">sort</td><td style="text-align:center">各列递增排序</td></tr><tr><td style="text-align:center">sum</td><td style="text-align:center">各列求和</td></tr><tr><td style="text-align:center">mean</td><td style="text-align:center">各列平均值</td></tr><tr><td style="text-align:center">std</td><td style="text-align:center">各列标准差</td></tr><tr><td style="text-align:center">var</td><td style="text-align:center">各列方差</td></tr></tbody></table><h3 id="基本数学函数"><a href="#基本数学函数" class="headerlink" title="基本数学函数"></a>基本数学函数</h3><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">abs(x)</td><td style="text-align:center">x中每个实数元素的绝对值,复数元素的模</td></tr><tr><td style="text-align:center">sqrt(x)</td><td style="text-align:center">x中每个元素求平方根</td></tr><tr><td style="text-align:center">exp(x)</td><td style="text-align:center">指数运算</td></tr><tr><td style="text-align:center">real(x)</td><td style="text-align:center">求实部</td></tr><tr><td style="text-align:center">imag(x)</td><td style="text-align:center">求虚部</td></tr><tr><td style="text-align:center">conj(x)</td><td style="text-align:center">求共轭</td></tr><tr><td style="text-align:center">angle(x)</td><td style="text-align:center">求相位角</td></tr><tr><td style="text-align:center">sin(x)</td><td style="text-align:center">正弦</td></tr><tr><td style="text-align:center">cos(x)</td><td style="text-align:center">余弦</td></tr><tr><td style="text-align:center">asin(x)</td><td style="text-align:center">反正弦</td></tr><tr><td style="text-align:center">acos(x)</td><td style="text-align:center">反余弦</td></tr><tr><td style="text-align:center">tan(x)</td><td style="text-align:center">正切</td></tr><tr><td style="text-align:center">atan(x)</td><td style="text-align:center">反正切</td></tr><tr><td style="text-align:center">log10(x)</td><td style="text-align:center">常用对数lgx</td></tr><tr><td style="text-align:center">log(x)</td><td style="text-align:center">自然对数lnx</td></tr><tr><td style="text-align:center">loga(b)</td><td style="text-align:center">任意对数</td></tr><tr><td style="text-align:center">mod(x,y)</td><td style="text-align:center">求余函数</td></tr><tr><td style="text-align:center">rem(x,y)</td><td style="text-align:center">输出对应元素的余数</td></tr><tr><td style="text-align:center">sign(x)</td><td style="text-align:center">求矩阵中元素的正负号</td></tr><tr><td style="text-align:center">lcm(x,y)</td><td style="text-align:center">最小公倍数</td></tr><tr><td style="text-align:center">gcd(x,y)</td><td style="text-align:center">最大公约数</td></tr><tr><td style="text-align:center">round(a)</td><td style="text-align:center">四舍五入</td></tr><tr><td style="text-align:center">fix(a)</td><td style="text-align:center">按0的方向取整</td></tr><tr><td style="text-align:center">floor(a)</td><td style="text-align:center">向负无穷方向取整</td></tr><tr><td style="text-align:center">ceil(a)</td><td style="text-align:center">向正无穷方向取整</td></tr><tr><td style="text-align:center">randperm(n)</td><td style="text-align:center">产生一个长度为n的排列</td></tr></tbody></table><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">plot(x,y,’option’)</td><td style="text-align:center">x横轴,y纵轴,逐点连折线绘制二维图形,参数见下表</td></tr><tr><td style="text-align:center">plot(y)</td><td style="text-align:center">y为向量,以下标作为x轴,y为纵轴,绘制曲线</td></tr><tr><td style="text-align:center">title(‘text’)</td><td style="text-align:center">添加标题</td></tr><tr><td style="text-align:center">xlabel(‘text’)</td><td style="text-align:center">x轴加标注</td></tr><tr><td style="text-align:center">ylabel(‘text’)</td><td style="text-align:center">y轴加标记</td></tr><tr><td style="text-align:center">legend(‘图例1’,’图例2’,…)</td><td style="text-align:center">添加图例</td></tr><tr><td style="text-align:center">text(x,y,’text’)</td><td style="text-align:center">在指定位置添加文本字符串</td></tr><tr><td style="text-align:center">gtext(‘text’)</td><td style="text-align:center">用鼠标放置文本</td></tr><tr><td style="text-align:center">axis([xmin xmax ymin ymax zmin zmax])</td><td style="text-align:center">调整坐标</td></tr><tr><td style="text-align:center">hold</td><td style="text-align:center">图形保持函数</td></tr><tr><td style="text-align:center">subplot</td><td style="text-align:center">子图分割命令</td></tr><tr><td style="text-align:center">stem</td><td style="text-align:center">离散序列</td></tr></tbody></table><h4 id="绘图参数表"><a href="#绘图参数表" class="headerlink" title="绘图参数表"></a>绘图参数表</h4><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">含义</th><th style="text-align:center">符号</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">y</td><td style="text-align:center">黄</td><td style="text-align:center">b</td><td style="text-align:center">蓝</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">洋红</td><td style="text-align:center">w</td><td style="text-align:center">白</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">青</td><td style="text-align:center">k</td><td style="text-align:center">黑</td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">红</td><td style="text-align:center">g</td><td style="text-align:center">绿</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">实线</td><td style="text-align:center">–</td><td style="text-align:center">虚线</td></tr><tr><td style="text-align:center">:</td><td style="text-align:center">点线</td><td style="text-align:center">-.</td><td style="text-align:center">点划线</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">点</td><td style="text-align:center">o</td><td style="text-align:center">圆</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">叉号</td><td style="text-align:center">+</td><td style="text-align:center">加号</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">向上的三角形</td><td style="text-align:center">v</td><td style="text-align:center">向下的三角形</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于号</td><td style="text-align:center">&lt;</td><td style="text-align:center">小于号</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">正方形</td><td style="text-align:center">d</td><td style="text-align:center">菱形</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">五角星</td><td style="text-align:center">h</td><td style="text-align:center">六角星</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">星号</td></tr></tbody></table><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">abs</td><td style="text-align:center">字符串到ascii转换</td></tr><tr><td style="text-align:center">str2mat</td><td style="text-align:center">字符串转换成字符矩阵</td></tr><tr><td style="text-align:center">setstr</td><td style="text-align:center">ascii转字符串</td></tr><tr><td style="text-align:center">num2str</td><td style="text-align:center">数值转字符串</td></tr><tr><td style="text-align:center">str2num</td><td style="text-align:center">字符串转换成数值</td></tr><tr><td style="text-align:center">dec2bin</td><td style="text-align:center">十进制数转二进制字符串</td></tr><tr><td style="text-align:center">bin2dec</td><td style="text-align:center">二进制串转十进制</td></tr><tr><td style="text-align:center">int2str</td><td style="text-align:center">将数值取整后转成字符串</td></tr><tr><td style="text-align:center">upper</td><td style="text-align:center">字符串转换成大写</td></tr><tr><td style="text-align:center">lower</td><td style="text-align:center">字符串转换成小写</td></tr><tr><td style="text-align:center">sprintf</td><td style="text-align:center">用格式控制,数字转字符串</td></tr><tr><td style="text-align:center">sscanf</td><td style="text-align:center">格式控制,字符串转数字</td></tr></tbody></table><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">input(‘text’)</td><td style="text-align:center">键盘提示输入</td></tr><tr><td style="text-align:center">fprintf()</td><td style="text-align:center">格式输出</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;系统级命令&quot;&gt;&lt;a href=&quot;#系统级命令&quot; class=&quot;headerlink&quot; title=&quot;系统级命令&quot;&gt;&lt;/a&gt;系统级命令&lt;/h3&gt;
    
    </summary>
    
    
      <category term="live" scheme="http://zuhiul.github.io/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>Project Euler 368 A Kempner-like series</title>
    <link href="http://zuhiul.github.io/2018/12/21/PE368/"/>
    <id>http://zuhiul.github.io/2018/12/21/PE368/</id>
    <published>2018-12-20T16:00:00.000Z</published>
    <updated>2019-04-14T08:29:37.975Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=368" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>The <strong>harmonic</strong> series $1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\dots$ is well known to be divergent.</p><p>If we however omit from this series every term where the denominator has a $9$ in it, the series remarkably enough converges to approximately $22.9206766193$.</p><p>This modified harmonic series is called the <strong>Kempner</strong> series.</p><p>Let us now consider another modified harmonic series by omitting from the harmonic series every term where the denominator has $3$ or more equal consecutive digits. One can verify that out of the first $1200$ terms of the harmonic series, only $20$ terms will be omitted.<br>These $20$ omitted terms are:</p><p>$$\frac{1}{111},\frac{1}{222},\frac{1}{333},\frac{1}{444},\frac{1}{555},\frac{1}{666},\frac{1}{777},\frac{1}{888},\frac{1}{999},\frac{1}{1000},\frac{1}{1110}, \frac{1}{1111},\frac{1}{1112},\frac{1}{1113},\frac{1}{1114},\frac{1}{1115},\frac{1}{1116},\frac{1}{1117},\frac{1}{1118},\frac{1}{1119}$$</p><p>This series converges as well.</p><p>Find the value the series converges to.<br>Give your answer rounded to $10$ digits behind the decimal point.</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>就是,调和级数不是发散的嘛,然后让你删掉那些分母含有连续三个相同数字的,然后可以证明剩下的级数是收敛的,然后问你收敛于多少.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>做法比较巧妙,下面一点点分析.</p><p>首先我们令$S_1(n,d)$表示一个包含所有这样的$n$位数的集合,集合中所有的$n$位数最后一位是$n$,并且倒数第二位不是$n$.</p><p>$S_2(n,d)$表示一个包含所有这样的$n$位数的集合,集合中所有的$n$位数最后两位是$n$,并且倒数第三位不是$n$.</p><p>然后我们令</p><p>$f_1(n,d,j)$ = $\sum_{x\in S_1(n,d)} \frac{1}{x^j}$</p><p>$f_2(n,d,j)$ = $\sum_{x\in S_2(n,d)} \frac{1}{x^j}$</p><p>然后答案显然就是</p><p>$\sum_{i=1}^{99} \frac{1}{i}+\sum_{n=3}^{\infty } \sum_{d=0}^{9} [f_1(n,d,1)+f_2(n,d,1)]$</p><p>关键是我们怎么算$f_1(n,d,j)$和$f_2(n,d,j)$</p><p>二者分析方法一样,这里给出$f_2(n,d,j)$怎么推出来的.</p><p>首先根据定义我们有</p><p>$f_2(n,d,j)$ = $\sum_{x\in S_2(n,d)} \frac{1}{x^j}$</p><p>我们不妨枚举每一个$x$,然后累加就是答案,所以子问题就是如何快速计算$\frac{1}{x^j} where x \in S_2(n,d)$</p><p>因为最后一位是$d$,所以我们不妨设$x$ = $y\ast 100+d\ast 10+d$</p><p>然后可以得到</p><p>$$<br>(\frac{1}{x\ast 100+d\ast 10+d})^j=\frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot (\frac{1}{1+\frac{d}{x\ast 100+d\ast 10}})^j<br>$$</p><p>然后我们将第三个分式化简.</p><p>考虑到</p><p>$(1+a)^{-b} = \sum_{i=0}^{\infty } C_{b+i-1}^i \cdot (-a)^b$</p><p>所以上式可以化简为</p><p>\begin{eqnarray}<br>(\frac{1}{x\ast 100+d\ast 10+d})^j<br>&amp;=&amp; \frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot \sum_{i=0}^{\infty } C_{j+i-1}^{i}(\frac{-d}{x\ast 100+d\ast 10})^i\\<br>&amp;=&amp; \frac{1}{10^j} \cdot \frac{1}{(x\ast 10+d)^j} \cdot \sum_{i=0}^{\infty } C_{j+i-1}^{i}(\frac{-d}{10})^i\cdot(\frac{1}{x\ast 10+d})^i\\<br>&amp;=&amp; \frac{1}{10^j} \sum_{i=0}^{\infty } C_{j+i-1}^{i} \cdot (\frac{-d}{10})^i \cdot (\frac{1}{x\ast 10+d})^{i+j}\\<br>\end{eqnarray}</p><p>然后我们考虑累加所有的$x$也就是原来的$f_2(n,d,j)$</p><p>可以得到</p><p>$$f_2(n,d,j) = \frac{1}{10^j} \sum_{i=0}^{\infty } (\frac{-d}{10})^i \cdot C_{j+i-1}^{i} \cdot f_1(n-1,d,i+j)$$</p><p>同理可以推得 $f_1(n,d,j)$</p><p>然后就是代码如下啦啦啦$\dots$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">double</span> C[maxm*<span class="number">3</span>][maxm*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">double</span> f1[<span class="number">2</span>][<span class="number">10</span>][maxm+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> f2[<span class="number">2</span>][<span class="number">10</span>][maxm+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//预处理出组合数和前99项的答案</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;maxm*<span class="number">3</span>;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>) C[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> C[i][j] = C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;<span class="number">100</span>;i++) ans+=<span class="number">1.0</span>/i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">0</span>;d&lt;=<span class="number">9</span>;d++)&#123;<span class="comment">//预处理出n = 3的情况</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=maxm;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pre = <span class="number">10</span>;pre&lt;<span class="number">100</span>;pre++)&#123;</span><br><span class="line"><span class="keyword">int</span> fir = pre/<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sec = pre%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(fir==sec&amp;&amp;sec==d) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(sec==d) f2[<span class="number">1</span>][d][j]+=<span class="number">1.0</span>/<span class="built_in">pow</span>(pre*<span class="number">10</span>+d,j);</span><br><span class="line"><span class="keyword">else</span> f1[<span class="number">1</span>][d][j]+=<span class="number">1.0</span>/<span class="built_in">pow</span>(pre*<span class="number">10</span>+d,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans+=f1[<span class="number">1</span>][d][<span class="number">1</span>]+f2[<span class="number">1</span>][d][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> nouse = <span class="number">4</span>;nouse&lt;=<span class="number">10000</span>;nouse++)&#123;<span class="comment">//滚动的算n&gt;=4的时候</span></span><br><span class="line"><span class="keyword">int</span> now = nouse&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> las = now^<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">0</span>;d&lt;=<span class="number">9</span>;d++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=maxm;j++)&#123;</span><br><span class="line">f1[now][d][j] = f2[now][d][j] = <span class="number">0</span>;<span class="comment">//别忘了初始化</span></span><br><span class="line"><span class="keyword">double</span> pre = <span class="number">1.0</span>/<span class="built_in">pow</span>(<span class="number">10.0</span>,j);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=maxm;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i+j&lt;=maxm) f2[now][d][j]+=pre*C[j+i<span class="number">-1</span>][i]*f1[las][d][i+j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">10</span>;x++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x==d) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(i+j&lt;=maxm) f1[now][d][j]+=pre*C[j+i<span class="number">-1</span>][i]*(f1[las][x][i+j]+f2[las][x][i+j]);</span><br><span class="line">&#125;</span><br><span class="line">pre*=-d/<span class="number">10.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans+=f1[now][d][<span class="number">1</span>]+f2[now][d][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=368&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>Project Euler 492 Exploding sequence</title>
    <link href="http://zuhiul.github.io/2018/12/12/PE492/"/>
    <id>http://zuhiul.github.io/2018/12/12/PE492/</id>
    <published>2018-12-11T16:00:00.000Z</published>
    <updated>2019-05-01T00:43:25.248Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://projecteuler.net/problem=492" target="_blank" rel="noopener">开启传送门</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><a id="more"></a><p>Define the sequence $a_1, a_2, a_3,\dots$ as:</p><ul><li>$a_1 $=$ 1$</li><li>$a_{n+1} = 6a_n^2 + 10a_n + 3$ for $n \geq 1$.</li></ul><p>Examples:</p><p>$a_3 $=$ 2359$</p><p>$a_6 $=$ 269221280981320216750489044576319$</p><p>$a_6 mod 1000000007 $=$ 203064689$</p><p>$a_{100} mod 1000000007 $=$ 456482974$</p><p>Define $B(x,y,n)$ as $\sum (a_n mod $ $p)$ for every prime $p$ such that $x \leq p \leq x+y$.</p><p>Examples:</p><p>$B(10^9, 10^3, 10^3)$ = $23674718882$</p><p>$B(10^9, 10^3, 10^{15})$ = $20731563854$</p><p>Find $B(10^9, 10^7, 10^{15})$.</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个二次递推序列,问你这个数列的第$10^{15}$项膜上一堆质数之后求和是多少.</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>看了<a href="https://blog.csdn.net/ACdreamers/article/details/44997467" target="_blank" rel="noopener">大佬</a>的题解之后才做出来的,还是太菜了$\dots$</p><p>下面是分析.</p><p>首先我们令$b_n = 6a_n+5$</p><p>于是有</p><p>$b_1$ = $11$</p><p>$b_{n+1} $=$ b_n^2-2$</p><p>然后我们令　$ x + \frac{1}{x}$ = $11$</p><p>可以显然发现　$b_n$ = $x^{2^{n-1}} + \frac{1}{x^{2^{n-1}}}$</p><p>于是不妨设　$x$ = $\frac{11+\sqrt{117}}{2}$</p><p>$\therefore b_n$ = $(\frac{11+\sqrt{117}}{2})^{2^{n-1}} + (\frac{11-\sqrt{117}}{2})^{2^{n-1}}$</p><p>然后我们可以直接算就行了</p><p>我们搞出递推式，然后用矩阵乘法的做法来做</p><p>我们考虑一个更一般的问题，</p><p>令$f_n = (\frac{11+\sqrt{117}}{2})^n + (\frac{11-\sqrt{117}}{2})^n$</p><p>然后我们考虑$f_n$如何求解</p><p>首先我们假设$f_n = x\ast f_{n-1}+y\ast f_{n-2}$</p><p>$$令 (\frac{11+\sqrt{117}}{2})^{n-2} = a$$</p><p>$$令 (\frac{11-\sqrt{117}}{2})^{n-2} = b$$</p><p>则有<br>\begin{cases}<br>\begin{eqnarray}<br>f_n &amp;=&amp; a\ast (\frac{11+\sqrt{117}}{2})^2+b\ast (\frac{11-\sqrt{117}}{2})^2\\<br>&amp;=&amp; a\ast (\frac{238+22\sqrt{117}}{4})+b\ast (\frac{238-22\sqrt{117}}{4})\\<br>f_{n-1}&amp;=&amp;a\ast (\frac{11+\sqrt{117}}{2})+b\ast (\frac{11-\sqrt{117}}{2})\\<br>f_{n-2}&amp;=&amp;a+b \\<br>\end{eqnarray}<br>\end{cases}</p><p>\begin{eqnarray}<br>&amp;\therefore&amp; a\ast (\frac{238+22\sqrt{117}}{4})+b\ast (\frac{238-22\sqrt{117}}{4})\\<br>&amp;=&amp; x\ast a\ast (\frac{11+\sqrt{117}}{2})+x\ast b\ast (\frac{11-\sqrt{117}}{2}) + y\ast (a+b)\\<br>\end{eqnarray}</p><p>将非根号项提出来，可以得到</p><p>$\therefore a\ast \frac{119}{2}+b\ast \frac{119}{2}$=$xa\ast \frac{11}{2}+xb\ast \frac{11}{2}+y(a+b) $</p><p>同理将根号项提出可以得到</p><p>$a\ast \frac{11}{2}+b\ast \frac{-11}{2}$=$xa\ast \frac{1}{2}+xb\ast \frac{-1}{2} $</p><p>然后可以解得</p><p>\begin{cases}<br>x = 11\\<br>y = -1<br>\end{cases}</p><p>也就是说$f_n$ = $11\ast f_{n-1} - f_{n-2}$</p><p>好了，我们得到了$f_n$的递推式，然后考虑原问题，也就是说</p><p>$$<br>\left(<br>    \begin{matrix}<br>        b_{n+1}\\<br>        b_n<br>    \end{matrix}<br>\right)<br>=\left(<br>    \begin{matrix}<br>        11 &amp; -1\\<br>        1 &amp; 0<br>    \end{matrix}<br>\right)^{2^{n-1}-1}<br>\left(<br>    \begin{matrix}<br>        b_2\\<br>        b_1<br>    \end{matrix}<br>\right)<br>=\left(<br>    \begin{matrix}<br>        11 &amp; -1\\<br>        1 &amp; 0<br>    \end{matrix}<br>\right)^{2^{n-1}-1}<br>\left(<br>    \begin{matrix}<br>        119\\<br>        11<br>    \end{matrix}<br>\right)<br>$$</p><p>$\because n$ 很大($10^{15}$)</p><p>$\therefore 2^{n-1}-1$很大,以至于我们不能方便的计算</p><p>然后我们考虑降低指数</p><p>具体分析看<a href="https://blog.csdn.net/ACdreamers/article/details/44997467" target="_blank" rel="noopener">大佬</a>的分析,可以得到循环节可以是$(p+1)(p-1)$</p><p>这个值我们可以接受,然后直接裸的矩阵ksm就行了$\dots$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给大佬递上我奇丑无比的代码　(<em>/ω＼</em>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> r = l+<span class="number">1e7</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123; <span class="keyword">return</span> (a+b)%mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">a = add(a,mod,mod);</span><br><span class="line">b = add(b,mod,mod);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = add(ret,a,mod);</span><br><span class="line">a = add(a,a,mod);</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = mul(ret,a,mod);</span><br><span class="line">a = mul(a,a,mod);</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&amp;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i*i&lt;=a;i++) <span class="keyword">if</span>(a%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">2</span>;j++) <span class="built_in">cout</span>&lt;&lt;mat[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">p <span class="title">mul</span><span class="params">(p a,p b,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">p ret;</span><br><span class="line"><span class="built_in">memset</span>(ret.mat,<span class="number">0</span>,<span class="keyword">sizeof</span> ret.mat);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j  =<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">ret.mat[i][j] = add(ret.mat[i][j],mul(a.mat[i][k],b.mat[k][j],mod),mod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">p <span class="title">qpow</span><span class="params">(p a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">p ret;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">2</span>;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">2</span>;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i==j) ret.mat[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ret.mat[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = mul(ret,a,mod);</span><br><span class="line">a = mul(a,a,mod);</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> prime)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MOD = prime*prime<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> zhi = qpow(<span class="number">2</span>,n<span class="number">-1</span>,MOD);</span><br><span class="line">zhi = add(zhi,MOD<span class="number">-1</span>,MOD);</span><br><span class="line"></span><br><span class="line">p base;</span><br><span class="line">base.mat[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">11</span>,base.mat[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">base.mat[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span> ,base.mat[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">base = qpow(base,zhi,prime);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret1 = mul(base.mat[<span class="number">1</span>][<span class="number">0</span>],<span class="number">119</span>,prime);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret2 = mul(base.mat[<span class="number">1</span>][<span class="number">1</span>],<span class="number">11</span>,prime);</span><br><span class="line"><span class="keyword">return</span> add(ret1,ret2,prime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> mul(mod-mod/a,inv(mod%a,mod),mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i&lt;=r;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(is_prime(i))&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> bn = solve(i);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> now1 = add(bn,i<span class="number">-5</span>,i);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> an = mul(now1,inv(<span class="number">6</span>,i),i);</span><br><span class="line">ans+=an;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">100000</span>==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=492&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://zuhiul.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="PE" scheme="http://zuhiul.github.io/tags/PE/"/>
    
  </entry>
  
</feed>
